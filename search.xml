<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>一道有趣的算法题：15个瓶子，4只老鼠，测试哪瓶有毒？</title>
      <link href="//mouse-drug-water.html"/>
      <url>//mouse-drug-water.html</url>
      
        <content type="html"><![CDATA[<h1 id="请听题"><a href="#请听题" class="headerlink" title="请听题"></a>请听题</h1><blockquote><p>有15个瓶子，其中最多有一瓶有毒，现在有四只老鼠，喝了有毒的水之后，第二天就会死。如何在第二天就可以判断出哪个瓶子有毒？<br><a id="more"></a></p></blockquote><h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>&emsp;&emsp;用二进制给每个瓶子进行编码0001-1111，如下图所示。四只老鼠分别喝第n位是1的瓶子的水，比如第1只老鼠喝1（0001）、3（0011）、5（0101）、7（0111）、9（1001）、11（1011）、13（1101）、15（1111）号瓶子的水。第二天，再通过4只老鼠的存活状态的组合来判断具体哪一瓶有毒。对于老鼠的存活状态，有生和死两种状态，0表示存活，1表示死亡，比如0011，即第1、2只老鼠死亡，第3、4只老鼠存活，0011进制表示的瓶子为3号瓶子，因此3号瓶子有毒。具体组合和结果如下图所示。<br><img src="http://pic.cloverkim.com/瓶子编号.jpg" alt="" title="瓶子编号"><br><img src="http://pic.cloverkim.com/老鼠存活组合.jpg" alt="" title="老鼠存活组合"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)drugWater:(NSString *)mice &#123;</span><br><span class="line">    NSInteger drug = 0;     // 有毒的瓶子编号</span><br><span class="line">    int mices[miceNum] = &#123;0&#125;;</span><br><span class="line">    </span><br><span class="line">    for (NSInteger i = 0; i &lt; [mice length]; i++) &#123;</span><br><span class="line">        mices[i] = [[mice substringWithRange:NSMakeRange(i, 1)] intValue];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (NSInteger i = 0; i &lt; miceNum; i++) &#123;</span><br><span class="line">        drug |= (mices[i] &lt;&lt; (miceNum - i - 1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (drug == 0) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, @&quot;无毒&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;有毒的瓶子是第 %ld 瓶&quot;, (long)drug);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关说明：</p><ul><li>方法传的mice参数为，4只老鼠的存活状态的字符串，比如0011。</li><li>根据之前的分析结果，我们用位运算来得出有毒的瓶子号即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《怦然心动》文德琳·范·德拉安南</title>
      <link href="//reading_Flipped.html"/>
      <url>//reading_Flipped.html</url>
      
        <content type="html"><![CDATA[<h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><p>&emsp;&emsp;朱莉安娜·贝克虔诚地相信三件事：树是圣洁的，特别是她最爱的无花果树；她在后院里饲养的鸡下的蛋是最卫生的；总有一天她会和布莱斯·罗斯基接吻。二年级时，在看到布莱斯蓝眼睛的那一瞬间，朱莉的心就被他击中了。不幸的是，布莱斯对她从来都没有感觉。而且，他认为朱莉有点怪，怎么会有人把养鸡和坐在树上看成乐趣呢？没想到，到了八年级，布莱斯开始觉得朱莉不同寻常的兴趣和对于家庭的自豪感使她显得很有魅力。而朱莉则开始觉得布莱斯漂亮的蓝眼睛也许和他本人一样，其实很空洞。毕竟，怎么会有人不把别人对树和鸡的感觉当回事呢？文德琳·范·德拉安南编著的《怦然心动》是在网络获得极高赞誉的电影《怦然心动》的同名原著，描述了青春期中男孩女孩之间的有趣战争。<a id="more"></a><br><img src="http://pic.cloverkim.com/《怦然心动》.jpg" alt="" title="《怦然心动》"></p><h1 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h1><p>&emsp;&emsp;文德琳•范•德拉安南 是美国著名的儿童作家，她1965年出生在芝加哥一个贫穷的工人家庭，父母都是狂热的文学爱好者。童年的生活，没有可口的零食和漂亮的洋娃娃，每当夜幕降临，父母下班回到家，这边是文德琳最幸福的时光，她和几个哥哥围在炉子旁，听母亲日复一日地给他们讲故事。这样的经历，造就了日后最为经典的《萨米凯斯》系列小说，前后四次荣获埃德加爱伦坡奖。<br>&emsp;&emsp;备注：埃德加爱伦坡奖：为全世界优秀侦探小说家创设的最具权威的奖项。该奖由美国推理作家协会（MWA）创立于1946年。获奖作品由美国侦探作家协会指定成员组成的委员会裁定。</p><h1 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h1><p>&emsp;&emsp;几年前，我就看完了由这本书改编的电影，但那个时候只是觉得这是一个关于青春朦胧的初恋故事。但当看完书之后，如果你也看完了这本书，我想你应该也会有跟我一样的感受，那就是这是一个关于成长的故事，辨别是非善恶与选择美。<br>&emsp;&emsp;整本书采用第一人称交替转换的线性叙事结构，将朱莉和布莱斯的心理写得透彻细致，那些瞬间的欢愉，微妙的痛楚都把握得恰到好处。<br>&emsp;&emsp;一个虽贫穷却幸福，另一个虽富裕却冷漠，两个不同的家庭环境，造就了朱莉和布莱斯全然不同的性格特征。朱莉独特善良且勇敢，她爱她的家人，她的邻居以及那颗高大的无花果树；而布莱斯畏畏缩缩，敏感怯懦，太看重他人对自己的评价。<br>&emsp;&emsp;布莱斯的外公对布莱斯的成长起着关键性的作用，因为外公并不想让布莱斯跟他母亲一样，20多年后才学会如何去发现，去认知和把握真正的美，当然也不想让布莱斯成为跟他父亲一样的人。外公就像一个引路人，引导了布莱斯一点点的了解自己和他人。这一切的开始，都要从布莱斯和外公的第一个谈话开始。<br>&emsp;&emsp;“她为什么不是你的朋友，布莱斯？”<br>&emsp;&emsp;“这姑娘很有骨气，你为什么不找个时间请她来家里玩呢？”<br>&emsp;&emsp;“你知道吗，不是每个人的隔壁都住着一个这样的女孩。”<br>&emsp;&emsp;短短的几句话，外公其实希望布莱斯能认真的看一看朱莉，能勇敢的面对朱莉。但布莱斯却总试着逃避。再到后来外公说：“他现在就像个懦夫，不过我对他还抱有希望。”不难看出，布莱斯其实也在成长着，只是还需要一定的时间。<br>&emsp;&emsp;朱莉，她独立、坚强、执着、善良，我想那颗高大的无花果树正是朱莉内心的象征。整体大于部分之和，但并不是所有人都是整体大于部分之和，朱莉观察了自己周围的同学，得出了大部分人都是整体小于部分之和，但却无法判断出布莱斯，那是因为朱莉的怦然心动导致了无法辨别。直到有一天，布莱斯的外公对朱莉说：“超越他的眼睛、他的笑容和他闪亮的头发——看看他到底是什么样子。”朱莉才开始逐渐明白。<br>&emsp;&emsp;小说的最后，以布莱斯在朱莉院子种下了一颗无花果树，以及朱莉觉得此时是时候好好了解下布莱斯为结尾，结束了整个故事。此时，我想，那颗无花果树，正是布莱斯心中，一个善意的开始，它终将不断茁壮成长，长成参天大树。<br>&emsp;&emsp;我想，一个人的改变是需要时间的，特别是以一种积极的方式的改变，是朱莉的善良和美好以及对整个世界、对布莱斯的爱改变了他。如果一个人不是到了无药可救的地步，那么请不要放弃他，指不定他证一点一点的摸索着黑暗，一步一步的发现并解读美。<br>&emsp;&emsp;<strong>“有些人浅薄，有些人金玉其外败絮其中，但是总有一天，你会遇到一个如彩虹般绚丽的人，他会让你觉得你以前遇到过的所有人都只是浮云。”</strong></p><h1 id="经典语句、读书笔记"><a href="#经典语句、读书笔记" class="headerlink" title="经典语句、读书笔记"></a>经典语句、读书笔记</h1><ol><li>超越他的眼睛、他的笑容和他闪亮的头发——看看他到底是什么样子。</li><li>主宰自己命运的感觉真好！我感觉自己充满力量，正确而坚定。</li><li>当你回首过去，会发现这是很明显的事，也很容易作出抉择，但不幸的是，大多数人看到藏在表面之下的真相时，已经太晚了。</li><li>你知道吗，不是每个人的隔壁都住着一个这样的女孩。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://book.douban.com/subject/7154675/" target="_blank" rel="noopener">豆瓣读书</a></li><li><a href="https://www.amazon.cn/dp/B00PF8JZHG/ref=sr_1_4?ie=UTF8&amp;qid=1541575686&amp;sr=8-4&amp;keywords=%E6%80%A6%E7%84%B6%E5%BF%83%E5%8A%A8" target="_blank" rel="noopener">亚马逊图书</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 静心阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青春 </tag>
            
            <tag> 小说 </tag>
            
            <tag> 成长 </tag>
            
            <tag> 文学 </tag>
            
            <tag> 美国 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《罗杰疑案》阿加莎·克里斯蒂</title>
      <link href="//reading_The-Murder-of-Roger-Ackroyd.html"/>
      <url>//reading_The-Murder-of-Roger-Ackroyd.html</url>
      
        <content type="html"><![CDATA[<h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><p>&emsp;&emsp;金丝艾伯特村里坐落着两座豪宅，“皇家围场”是其中之一，而居住其中的弗拉尔斯太太刚刚过世。此后不久，她的情人，也就是住在另一所大宅里的罗杰·艾克罗伊德先生便得知，弗拉尔斯太太一年前杀害了自己的丈夫，最终因愧疚而自杀。更重要的是，罗杰还发现她在死之前一直被一个神秘人敲诈。他展开她最后的来信，打算读出那个人的名字，可惜没有人能听到，因为一把短剑插进了他的后颈…<a id="more"></a><br>&emsp;&emsp;之后的故事情节便是谢泼德医生协助侦探波克对案子进行展开调查。随着案件细节不断的挖掘以及涉及到此案的人逐渐吐露自己所隐瞒的内容，读者会觉得每个人都像是凶手或者帮凶，因为涉及此案的人都能从罗杰的死中直接或者间接的获取到好处；但又觉得可以排除所有人，因为他们几乎都有不在场证明和不具备作案的可能性，那么凶手到底是谁呢？<br>&emsp;&emsp;是谁一直在勒索弗拉尔斯太太，害得她绝望到自杀？是谁杀死了罗杰·艾克罗伊德？<br><img src="http://pic.cloverkim.com/%E3%80%8A%E7%BD%97%E6%9D%B0%E7%96%91%E6%A1%88%E3%80%8B.jpg" alt="" title="《罗杰疑案》"></p><h1 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h1><p>&emsp;&emsp;阿加莎·克里斯蒂（AgathaChristie，1890-1976），英国推理女作家。<br>&emsp;&emsp;阿加莎·克里斯蒂的第一步小说《斯泰尔斯庄园奇案》写于第一次世界大战末，战时她担任志愿救护队员。在这部小说中她塑造了一个可爱的小个子比利时侦探赫尔克里·波格，成为继福尔摩斯之后侦探小说中最受读者欢迎的侦探形象。1962年，阿加莎·克里斯蒂写出了自己的成名作《罗杰疑案》。1952年她的剧本《捕鼠器》被搬上舞台，此后连续上演，时间之长久，创下了世界戏剧史上空前的记录。<br>&emsp;&emsp;1976年，她以85岁高龄去世。</p><h1 id="作品的影响"><a href="#作品的影响" class="headerlink" title="作品的影响"></a>作品的影响</h1><p>&emsp;&emsp;作为阿加莎·克里斯蒂的成名作，《罗杰疑案》在案件结构的安排，作品情节的设计，心理学的使用等方面体现了作者的作品独有的特点，并获得了社会的广泛认可。根据美国推理作家协会票选出来的史上最经典的一百部推理小说排行榜，《罗杰疑案》高居第12名。</p><h1 id="人物关系图"><a href="#人物关系图" class="headerlink" title="人物关系图"></a>人物关系图</h1><p><img src="http://pic.cloverkim.com/%E7%BD%97%E6%9D%B0%E7%96%91%E6%A1%88-%E4%BA%BA%E7%89%A9%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="" title="人物关系图"></p><h1 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h1><p>&emsp;&emsp;这是我读的第一本侦探类型的小说，而且这本书基本是在上下班搭地铁时看完的。在一天的下班回宿舍的地铁上，跟往前一样，开始打开kindle开始阅读，此时的阅读的进度已经到90%了，随着案件的剥茧抽丝，嫌疑人的逐渐排除，我却依旧无法猜出谁是真正的凶手，因为谁都有嫌疑，但又没有谁能做到，我的脑海里一直闪着两个疑问：<strong>是谁一直在勒索弗拉尔斯太太，害得她绝望到自杀？是谁杀死了罗杰·艾克罗伊德？</strong><br>&emsp;&emsp;回到宿舍，吃完饭后便继续阅读了起来，当看到了真相，看到了凶手的名字时，心中难掩激动的心情，起着鸡皮疙瘩的同时惊叹着。作者阿加莎的思维究竟缜密到何种程度，才能写出这样的小说？<br>&emsp;&emsp;不得不说，作者阿加莎完美地将悬念保留到了最后一刻，在侦探波洛揭晓答案的刹那，读者就像身临其境一般，仿佛我们就在现场，如此巧妙的悬念与无法想象的真相让我们不得不赞叹。也许，看完这本小说，你也会有一种感受：谁也想不到的凶手。<br>&emsp;&emsp;由不可思议到不可思议，从你翻开这本书的第一页开始…</p><h1 id="经典语句"><a href="#经典语句" class="headerlink" title="经典语句"></a>经典语句</h1><ol><li>当一个人达到了终生奋斗的目标，通过辛勤劳动换来了某种消遣和娱乐，但他突然发觉自己在惦记着往日的繁忙生活，你可知道这是什么滋味？</li><li>对一个男人，你怎么敲诈他都行，但对一个女人，你就不能逼得太厉害，因为女人的内心有一种说真话的强烈愿望。有多少丈夫一辈子蒙骗自己的妻子，最后带着秘密安然去世！有多少蒙骗自己丈夫的妻子在跟丈夫吵架时却说出真话，从而毁了自己的一生！她们被逼的太厉害，在危急时刻，当然，她们事后会感到后悔，她们不顾安危而最后陷入绝境，为图一时的极大满足而把事实吐露出来。</li><li>“女人，”波洛以概括性的语言说，“我不可思议的！她们毫无根据地随意推测–推测的结果往往是正确的，这确实是一种奇迹。真正的原因还不在这一点。女人能够下意识地观察到许多细节的问题，她们并不知道其中的原因，但她们的下意识会把这些细节组合在一起–人们把这种现象称之为结果自觉。”</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://book.douban.com/subject/1807516/" target="_blank" rel="noopener">豆瓣读书</a></li><li><a href="https://baike.baidu.com/item/%E7%BD%97%E6%9D%B0%E7%96%91%E6%A1%88/8154008?fr=aladdin" target="_blank" rel="noopener">百度百科-罗杰疑案</a></li><li><a href="https://www.amazon.cn/dp/B00T238N5U/ref=sr_1_6?s=digital-text&amp;ie=UTF8&amp;qid=1540970943&amp;sr=1-6" target="_blank" rel="noopener">亚马逊图书</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 静心阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
            <tag> 侦探 </tag>
            
            <tag> 悬疑 </tag>
            
            <tag> 英国 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《我是猫》夏目漱石</title>
      <link href="//reading_cat.html"/>
      <url>//reading_cat.html</url>
      
        <content type="html"><![CDATA[<h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><p>&emsp;&emsp;《我是猫》，是日本“国民大作家”夏目漱石的巅峰之作，这本书确立了夏目漱石在文学史上的地位。<br>&emsp;&emsp;小说采用幽默、讽刺、滑稽的手法，借助一只猫的视觉、听觉、感觉，以主人公中学教员珍野苦沙弥的日常起居为主线，穿插了邻居资本家金田企图嫁女不成阴谋报复苦沙弥的矛盾冲突，嘲笑了明治时代知识分子空虚的精神生活，讥讽他们自命清高，却无所事事；不满现实，却无力反抗；平庸无聊，却贬斥世俗的矛盾性格，鞭挞金田等资产阶级人物及帮凶的势力、粗鄙、凶残的本性。小说构思奇巧，描写夸张，结构灵活，具有鲜明的艺术特色。<br><a id="more"></a><br><img src="http://pic.cloverkim.com/%E3%80%8A%E6%88%91%E6%98%AF%E7%8C%AB%E3%80%8B.jpg" alt="" title="《我是猫》"></p><h1 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h1><p>&emsp;&emsp;夏目漱石（1867~1916）是日本近代首屈一指的文学巨匠。他原名夏目进之助，笔名漱石，取至“漱石枕流”（《晋书》孙楚语）。夏目漱石一生著有两部文论、大量俳句、几百首汉诗，若干随笔和书信，但在文学上的最大贡献是以他十几部长篇小说和大批短篇小说竖起批判现实主义文学的丰碑，给后来的作家以深刻的启迪。夏目一生坚持对明知社会的批判态度，以他的具有鲜明个性的、丰富多彩的艺术才能，在日本近代文学史上占有重要的地位。</p><h1 id="作品的影响"><a href="#作品的影响" class="headerlink" title="作品的影响"></a>作品的影响</h1><p>&emsp;&emsp;《我是猫》是日本文学大师夏目漱石的代表作，向被奉为世界名著之一。小说通过猫的视觉观察明治维新后的日本社会，以幽默辛辣的语言，嘲笑和鞭挞了人类固有的弱点和金钱世界的社会时弊，还大量饮用了古今东西哲学大师的名言，外外闪射着机智和文采，嬉笑怒骂皆成文章。作品语言则典俚合炉，雅俗共赏，读来令人在笑声中抑制不住惊叹。</p><h1 id="主要人物"><a href="#主要人物" class="headerlink" title="主要人物"></a>主要人物</h1><h2 id="作为第一视角的猫君（这里不能归类为人物）"><a href="#作为第一视角的猫君（这里不能归类为人物）" class="headerlink" title="作为第一视角的猫君（这里不能归类为人物）"></a>作为第一视角的猫君（这里不能归类为人物）</h2><p>&emsp;&emsp;“我是猫，还没有名字”，这便是这本书的开头。它本来是被一书生所养，后来被书生抛弃后，被中学教师苦沙弥所收养。这是一只抓不到老鼠的猫，终日在教师苦沙弥家白吃白喝无所事事，还嫌弃着教师家的穷苦。我们的猫君平时一边对人类所做的各种蠢事而嗤之以鼻，一边又搞一些五花八门的事情来给自己消遣解闷，比如吃年糕、捉老鼠的滑稽场面，捕蝉、溜松、逗螳螂等。</p><h2 id="猫的主人-——-中学英语教师苦沙弥"><a href="#猫的主人-——-中学英语教师苦沙弥" class="headerlink" title="猫的主人 —— 中学英语教师苦沙弥"></a>猫的主人 —— 中学英语教师苦沙弥</h2><p>&emsp;&emsp;书中一开始，就介绍了苦沙弥兴趣很广泛，比如写俳句、写新体诗、学过弦乐、唱过“谣曲”，拉过小提琴，绘画等等，但可惜只有三分钟的热度，用书中的话说：哪方面都没有过人的本事，一事无成。比较有意思的是，他非常喜欢买书，又经常窝进书房，但翻不上几页书就开始呼呼大睡。作为一名中学英语教师却不思进取，没有过多的真才实学，就连写一篇英文文章都能错误百出。又常常会因为一些小事而大动肝火、愤愤不平，但处理事情却总是虎头蛇尾。自己贫穷，渴望金钱，却看不起实业家赚钱的阴险手段。</p><h2 id="美学家迷亭"><a href="#美学家迷亭" class="headerlink" title="美学家迷亭"></a>美学家迷亭</h2><p>&emsp;&emsp;迷亭是苦沙弥的朋友之一，他非常有个性，一副玩世不恭的样子、又唯恐天下不乱。迷亭热衷于一本正经的胡说八道，胡诌八扯的家常便饭，但为人正直，心眼不坏。没事就喜欢去苦沙弥家里坐着，而且每次去苦沙弥家，总是大摇大摆进去，大摇大摆地坐下，大声嚷嚷，毫不拘谨。用网上的一句话说：有些人平庸，有些人乏味，有些人金玉其外败絮其中，而你很少会遇见一位迷亭先生。</p><h2 id="理学士水岛寒月"><a href="#理学士水岛寒月" class="headerlink" title="理学士水岛寒月"></a>理学士水岛寒月</h2><p>&emsp;&emsp;寒月是苦沙弥以前教过的学生，是一个好男人的同时，又是一个典型的书呆子。他的行为总是有些奇怪，让人摸不着头脑。他曾因为吃香菇而绷断了一颗牙齿；为了当上博士去研究“上吊力学”、“紫外线对青蛙眼珠的影响”等，浪费大好的青春整天待在实验室里磨玻璃球；高中时，为了买小提琴又不让别人发现而大费周章。有意思的是，他与金田家女儿的婚事，金田家一心想让寒月尽快成为博士，迎娶金田小姐。但最后的结局是寒月回老家和另外一个女人结了婚，并没有因为金田家的财产而同意与金田小姐结婚，这一定程度上打击了当时资产阶级的势力。</p><h2 id="新体诗人智越东风君"><a href="#新体诗人智越东风君" class="headerlink" title="新体诗人智越东风君"></a>新体诗人智越东风君</h2><p>&emsp;&emsp;智越东风君是一个新体诗人，与同好之人组织了一个朗读会。比较有意思的一件事是，他遇上了一对德国夫妇，想借此机会好好展示下他的德语，起初翻译的很流利，但到很难的句子时，却因翻译不出来而手足无措。</p><h2 id="哲学者八木独仙"><a href="#哲学者八木独仙" class="headerlink" title="哲学者八木独仙"></a>哲学者八木独仙</h2><p>&emsp;&emsp;八木独仙信奉消极主义哲学，常说些让人不能理解的话。他希望通过自身修养求得安身立命。</p><h1 id="经典语句、阅读标注"><a href="#经典语句、阅读标注" class="headerlink" title="经典语句、阅读标注"></a>经典语句、阅读标注</h1><ol><li>天上有星辰，地上有露华，空中有飞禽，地面有走兽，池里有金鱼，枯木有寒鸦。</li><li>说起来，人类这种东西原本就是仗着自己身强力壮。一个个都那么妄自尊大。</li><li>我只是开个玩笑，人们就把它当真是常有的事，所以就感觉开玩笑可以极大地激发滑稽美感，格外有趣！</li><li>我像个乖戾的牡蛎似的老是窝在书房里，从不想了解外界，却又装出一副唯独自己最达观的面孔，真有点滑稽。</li><li>由这个例子可知，人类从利己主义推出的“公平”原理，也许比猫族的观念进步，但是，若论人的智慧，却比猫还不如。</li><li>难得的机缘，会驱使所有动物做出他们不喜欢做的事来。</li><li>临危之际，能为平日所不能为之事，此谓之“天佑”。</li><li>这世上就是有一种自作多情的人，遇见个眼睛斜视的人，就以为是看上他了。</li><li>人类这种东西，为了消磨时间而强迫自己做口舌运动，除了会胡诌些并不可笑的事，然后莫名其妙地傻笑一通或是以此为乐外，一无所能。</li><li>真理虽然在我这里，权力却在别人那里。此时只有两条路：或委曲求全，唯命是从；或偷偷摸摸地我行我素。</li><li>人总是把无能为力的事情当做不会发生。</li><li>比鸿毛还轻的是灰尘，比灰尘还轻的是清风，比清风还轻的是女人，比女人还轻的是虚无…</li><li>假如是高明的父母，把我们生得能够适应于当下的社会，那就是幸福的。然而，如果生得不合格，那么，除了与世人格格不入，离群索居，或是忍耐到适应于社会的时候为止之外，没有其他路可走。</li><li>遍观人世间，往往越是无能无才的小人，越是肆意妄为，削尖脑袋想要爬上不可胜任其职的官位，其实这种性格，早在孩童时期就已经萌芽了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 静心阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
            <tag> 文学 </tag>
            
            <tag> 日本 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - runtime实践·关联对象（Associated Object）</title>
      <link href="//runtime-associated-object.html"/>
      <url>//runtime-associated-object.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是关联对象"><a href="#什么是关联对象" class="headerlink" title="什么是关联对象"></a>什么是关联对象</h1><p>&emsp;&emsp;关联对象是指某个对象通过一个唯一的key连接到一个类的实例上。我们都知道，可以使用Category来扩展方法，那Category可以添加属性吗？相信很多人都会回答不可以，答案其实是可以的，只是不会自动生成getter/setter方法的实现，也不会自动生成成员变量，在我们调用的时候就会crash了。如果要添加一个属性，那就要用到runtime的关联对象了。<br><a id="more"></a></p><h1 id="如何关联对象"><a href="#如何关联对象" class="headerlink" title="如何关联对象"></a>如何关联对象</h1><p>&emsp;&emsp;来看下runtime提供给我们的3个API方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 关联对象</span><br><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</span><br><span class="line">// 获取关联的对象</span><br><span class="line">id objc_getAssociatedObject(id object, const void *key)</span><br><span class="line">// 移除关联的对象</span><br><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure></p><p>相关说明：</p><ul><li>id object：被关联的对象</li><li>const void *key：关联的key，要求唯一</li><li>id value：关联的对象</li><li>objc_AssociationPolicy policy：内存管理的策略</li></ul><p>objc_AssociationPolicy的枚举值和相关说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = 0,            // 指定一个弱引用相关联的对象</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,  // 指定相关对象的强引用，非原子性</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,    // 指定相关的对象被复制，非原子性</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = 01401,        // 指定相关对象的强引用，原子性</span><br><span class="line">    OBJC_ASSOCIATION_COPY = 01403           // 指定相关的对象被复制，原子性   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;当对象被释放时，会根据这个策略会决定是否释放关联的对象，当策略是RETAIN/COPY时，会释放关联的对象，当是ASSIGN时，将不会释放。需要注意的是，我们不需要主动调用removeAssociated方法来解除关联的对象，如果需要解除指定的对象，可以使用setAssociatedObject置nil来实现。</p><p>使用步骤：</p><ul><li>创建对应类的一个Category，创建要添加的属性。</li><li>重写属性的setter方法，在setter方法中调用objc_setAssociatedObject进行关联对象。</li><li>重写属性的getter方法，在getter方法中return objc_getAssociatedObject（获取到的关联对象）</li><li>需要注意的是：key一定要唯一，可以定义成宏。</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol><li>给UITapGestureRecognizer动态添加一个NSString类型的属性，方便传递字符串类型的信息，当然UITapGestureRecognizer本身也有tag。</li></ol><p>&emsp;&emsp;在.h文件中进行声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface UITapGestureRecognizer (NSString)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *tapString;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在.m文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static NSString *tapStringKey = @&quot;tapString&quot;;</span><br><span class="line"></span><br><span class="line">@implementation UITapGestureRecognizer (NSString)</span><br><span class="line"></span><br><span class="line">- (void)setTapString:(NSString *)tapString &#123;</span><br><span class="line">    objc_setAssociatedObject(self, &amp;tapStringKey, tapString, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)tapString &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;tapStringKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在viewController中就可以调用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapAction:)];</span><br><span class="line">tap.tapString = @&quot;触摸了！&quot;;</span><br><span class="line">[self.view addGestureRecognizer:tap];</span><br><span class="line"></span><br><span class="line">- (void)tapAction:(UITapGestureRecognizer *)tap &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, tap.tapString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>假如封装好了一个页面缺省图，我们定义为BlankPageView，如果我们要为每个UIView添加一个blankPageView属性时，可以使用关联对象的方法。</li></ol><p>&emsp;&emsp;在setter方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static char BlankPageViewKey;</span><br><span class="line"></span><br><span class="line">- (void)setBlankPageView:(BlankPageView *)blankPageView &#123;</span><br><span class="line">    objc_setAssociatedObject(self, &amp;BlankPageViewKey,</span><br><span class="line">                                blankPageView,</span><br><span class="line">                                OBJC_ASSOCIATION_RETAIN_NONATOMIC);               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在getter方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BlankPageView *)blankPageView &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;BlankPageViewKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>以UIButton为例，使用关联对象完成一个函数的点击回调</li></ol><p>&emsp;&emsp;在分类的.h文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^BtnActionCallBack)(UIButton *btn);</span><br><span class="line"></span><br><span class="line">@interface UIButton (ActionBlock)</span><br><span class="line"></span><br><span class="line">- (void)btnActionCallBack:(BtnActionCallBack)callBack;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在.m文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static NSString *btnActionKey = @&quot;btnAction&quot;;</span><br><span class="line"></span><br><span class="line">- (void)btnActionCallBack:(BtnActionCallBack)callBack &#123;</span><br><span class="line">    objc_setAssociatedObject(self, &amp;btnActionKey, callBack, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    </span><br><span class="line">    [self addTarget:self action:@selector(btnAction) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)btnAction &#123;</span><br><span class="line">    BtnActionCallBack callBack = objc_getAssociatedObject(self, &amp;btnActionKey);</span><br><span class="line">    </span><br><span class="line">    if (callBack) &#123;</span><br><span class="line">        callBack(self);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.testBtn btnActionCallBack:^(UIButton * _Nonnull btn) &#123;</span><br><span class="line">    NSLog(@&quot;button action call back&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><ol start="4"><li>关联观察者对象<br>&emsp;&emsp;当在一个Category的实现中使用KVO时，建议用一个自定义的关联对象而不是该对象本身作为观察者。比如AFNetworking，为loading控件监听NSURLSessionTask以获取网络进度的分类中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIActivityIndicatorView (AFNetworking)</span><br><span class="line">- (AFActivityIndicatorViewNotificationObserver *)af_notificationObserver &#123;</span><br><span class="line">    </span><br><span class="line">    AFActivityIndicatorViewNotificationObserver *notificationObserver = objc_getAssociatedObject(self, @selector(af_notificationObserver));</span><br><span class="line">    if (notificationObserver == nil) &#123;</span><br><span class="line">        notificationObserver = [[AFActivityIndicatorViewNotificationObserver alloc] initWithActivityIndicatorView:self];</span><br><span class="line">        objc_setAssociatedObject(self, @selector(af_notificationObserver), notificationObserver, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    return notificationObserver;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setAnimatingWithStateOfTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    [[self af_notificationObserver] setAnimatingWithStateOfTask:task];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/916aef6f7ab1" target="_blank" rel="noopener">简书 - 陈满iOS - iOS开发·runtime原理与实践: 关联对象篇(Associated Object)(应用场景：为分类添加“属性”，为UI控件关联事件Block体，为了不重复获得某种数据)</a></li><li><a href="https://www.jianshu.com/p/c68cc81ef763" target="_blank" rel="noopener">简书 - 明仔Su - iOS runtime实战应用：关联对象</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 实践 </tag>
            
            <tag> runtime </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - runtime实践·消息转发（Message Forwarding）</title>
      <link href="//runtime-message-forwarding.html"/>
      <url>//runtime-message-forwarding.html</url>
      
        <content type="html"><![CDATA[<h1 id="消息传递机制"><a href="#消息传递机制" class="headerlink" title="消息传递机制"></a>消息传递机制</h1><p>&emsp;&emsp;在OC中，当调用了某个对象的方法时，其实质上就是向该对象发送了一条消息，OC的方法最终被生成了C函数，并附带额外的参数。消息传递机制中所调用的核心函数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(id _Nullable self, SEL _Nonnull op, ...)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>&emsp;&emsp;该函数是个参数可变的函数，能接收两个及以上的参数，第一个参数为方法接收者，第二个参数为选择器，后续的参数则为方法调用所需要的相应参数。<br>&emsp;&emsp;举个🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[array insertObject:message atIndex: 3];</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在编译时，我们上面所写的OC函数会被转化成如下C函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(array, @selector(insertObject:atIndex:), message, 3);</span><br></pre></td></tr></table></figure></p><h1 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h1><p>&emsp;&emsp;当向某个对象发送一条消息时，若该对象的方法列表以及它相应继承链上的方法列表都无法找到以该消息选择子作为key的方法实现时，则会触发消息转发机制。<br>&emsp;&emsp;如果没有方法的实现，程序会在运行时crash并抛出<strong>unrecognized selector sent to instance</strong>的异常，但在抛出异常之前，OC的runtime会给我们3次拯救程序的机会。</p><ol><li>动态方法解析</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当接收到未能识别的选择子时，运行时系统会调用该函数用以给对象一次机会来添加相应的方法实现，如果用户在该函数中动态添加了相应方法的实现，则跳转到方法的实现部分，并将该实现存入缓存中，以供下次调用。举个🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void) btnActionMethod &#123;</span><br><span class="line">    NSLog(@&quot;btnAction&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel == @selector(btnAction)) &#123;</span><br><span class="line">        class_addMethod([self class], sel, class_getMethodImplementation([self class], @selector(btnActionMethod)),  &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;关于class_addMethod方法const char *types参数：</p><ul><li>“v@:”：这是一个void类型的方法，没有参数传入</li><li>“i@:”：这是一个int类型的方法，没有参数传入</li><li>“i@:@”：这是一个int类型的方法，有一个参数传入</li><li>更多相关，可以参考官方文档说明：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100" target="_blank" rel="noopener">Type Encodings</a></li></ul><ol start="2"><li>备援接收者</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果运行时在消息转发的第一步中未找到所调用方法的实现，那么当前接收者还有第二次机会进行未知选择子的处理。这是运行时系统会调用上述方法，并将未知选择子作为参数传入，该方法可以返回一个能处理该选择子的对象，运行时系统会根据返回的对象进行查找，若找到则跳转到相应的方法的实现，则消息转发结束。</p><ol start="3"><li>完整的消息转发</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当运行时系统检测到第二步中用户未返回能处理相应选择子的对象时，那么来到这一步就要启动完成的消息转发机制了。该方法可以改变消息调用目标，运行时系统根据所改变的调用目标，向调用目标方法列表中查询对应方法的实现并实现跳转，这种方式和第二步的操作非常相似。当然，你也可以修改方法的选择子，亦或者向所调用方法中追加一个参数等来跳转到相关方法的实现。<br>&emsp;&emsp;最后，如果消息转发的第三步还未能处理未知选择子的话，那么最终会调用NSObject类的如下方法，用以异常的抛出，表明该选择子最终未能处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;对于完整的消息转发流程图如下图所示：<br><img src="http://pic.cloverkim.com/消息转发流程图.jpg" alt="" title="消息转发流程图"></p><h1 id="消息转发实例-amp-验证"><a href="#消息转发实例-amp-验证" class="headerlink" title="消息转发实例&amp;验证"></a>消息转发实例&amp;验证</h1><p>&emsp;&emsp;在新建的Project中，添加Cat、Dog、Rabbit三个类，并在每个类的.h文件中声明jump方法。</p><ol><li>我们用Cat类来验证消息转发的第一步方法：resolveInstanceMethod:，在该方法中动态添加jump方法的实现，使用runtime的class_addMethod方法，该方法用以向该类的实例对象中添加相应的方法实现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void jump(id self, SEL cmd) &#123;</span><br><span class="line">    NSLog(@&quot;%@  jump&quot;, self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if ([NSStringFromSelector(sel) isEqualToString:@&quot;jump&quot;]) &#123;</span><br><span class="line">        class_addMethod(self, sel, (IMP)jump, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后在ViewController中创建Cat对象，并调用jump方法，如果Cat类中没有实现jump方法，正常的情况下，是会crash，但我们在resolveInstanceMethod: 方法中动态添加了方法的实现，则会跳转到新的方法实现中，因此才不会导致crash。控制台的打印如下：<br><img src="http://pic.cloverkim.com/动态方法解析.jpg" alt="" title="动态方法解析"></p><ol start="2"><li>我们用Dog类来验证消息转发的第二步过程，根据上面所述的流程图中，为了能让运行时系统能够运行到forwardingTargetForSelector: 方法，我们需要在resolveInstanceMethod: 方法中返回NO，并且在forwardingTargetForSelector: 方法中返回Cat类的实例对象，让Cat类的实例对象去处理Dog的jump方法。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;jump&quot;]) &#123;</span><br><span class="line">        return [[Cat alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在ViewController中创建Dog对象，并调用jump方法。由于我们在forwardingTargetForSelector: 方法中，返回了Cat的实例对象，因此Dog的jump方法转发给了能处理Dog jump方法的Cat对象，并跳转到Cat对象的jump方法中，因此也不会导致crash。控制台的打印如下：<br><img src="http://pic.cloverkim.com/备援接收者.jpg" alt="" title="备援接收者"></p><ol start="3"><li>最后用Rabbit类来验证消息转发的第三个步骤的过程。为了能触发完整的消息转发，我们需要将resolveInstanceMethod: 方法返回NO，并且在forwardingTargetForSelector: 方法中返回nil。另外，在实现forwardInvocation: 方法时，还需要实现methodSignatureForSelector: 方法，并将相应的选择子的描述返回。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[[Cat alloc] init]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;jump&quot;]) &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后在ViewController中创建Rabbit的实例，并调用jump方法，由于我们通过完整的消息转发，将方法的实现跳转到了Cat实例中，因此不但不会crash，还会执行Cat的jump方法，控制台的打印如下：<br><img src="http://pic.cloverkim.com/完整的消息转发.jpg" alt="" title="完整的消息转发"></p><h1 id="引申-向一个nil对象发送消息会怎样？"><a href="#引申-向一个nil对象发送消息会怎样？" class="headerlink" title="引申 - 向一个nil对象发送消息会怎样？"></a>引申 - 向一个nil对象发送消息会怎样？</h1><p>&emsp;&emsp;结论：OC中向为nil的对象发送消息，程序是不会crash的。<br>&emsp;&emsp;因为OC的函数都是通过<code>objc_msgSend</code>进行消息发送来实现，相对于C和C++来说，对于空指针的操作会引起crash问题，而<code>objc_msgSend</code>会通过判断self来决定是否发送消息，如果self为nil，那么selector也会为空，直接返回，不会出现问题。视方法返回值，向nil发消息可能会返回nil（返回值为对象），0（返回值为一些基础数据）或0X0（返回值为id）等。但对于<code>[NSNull null]</code>对象发送消息时，是会crash的，因为NSNull类只有一个null方法。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/junhuawang/p/5196291.html" target="_blank" rel="noopener">博客园 - 俊华的博客 - Runtime 运行时之一：消息转发</a></li><li><a href="https://www.jianshu.com/p/2fd4b930588e" target="_blank" rel="noopener">简书 - 陈满iOS - iOS开发·runtime原理与实践: 消息转发篇(Message Forwarding) (消息机制，方法未实现+API不兼容奔溃，模拟多继承)</a></li><li><a href="https://www.jianshu.com/p/11dca953f962" target="_blank" rel="noopener">简书 - 高浩浩浩浩浩浩 - Objc中向一个nil对象发送消息会怎样</a></li><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 实践 </tag>
            
            <tag> runtime </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - runtime实践·方法交换（Method Swizzling）</title>
      <link href="//runtime-method-swizzling.html"/>
      <url>//runtime-method-swizzling.html</url>
      
        <content type="html"><![CDATA[<h1 id="了解几个概念"><a href="#了解几个概念" class="headerlink" title="了解几个概念"></a>了解几个概念</h1><ol><li>Selector（typedef struct objc_selector *SEL）：在运行时Selectors用来代表一个方法的名字。Selector是一个在运行时被注册（或映射）的C类型字符串。Selector由编译期产生并且在当类被加载进内存时由运行时自动进行名字和实现的映射。</li><li>Method（typedef struct objc_method *Method）：是一个不透明的用来代表一个方法的定义的类型。<a id="more"></a></li><li>Implementation（typedef id(*IMP)(id,SEL,…)）：这个数据类型指向一个方法的实现的最开始的地方。该方法为当前CPU架构使用标准的C方法调用来实现。该方法的第一个参数指向调用方法的自身（即内存中类的实例对象，若是调用类方法，该指针则是指向元类对象(metaclass)）；第二个参数是这个方法的名字Selector，该方法的真正参数紧随其后。</li></ol><p>&emsp;&emsp;理解Selector，Method，Implementation这三个概念之间关系的最好方式是：在运行时，类(Class)维护了一个消息分发列表来解决消息的正确发送。每一个消息列表的入口是一个方法(Method)，这个方法映射了一对键值对，其中键值是这个方法的名字Selector(SEL)，值是指向这个方法实现的函数指针Implementation(IMP)。Method Swizzling修改了类的消息分发列表使得已经存在的Selector映射了另一个Implementation，同时重命名了原生方法的实现为一个新的Selector。</p><h1 id="Method-Swizzling原理"><a href="#Method-Swizzling原理" class="headerlink" title="Method Swizzling原理"></a>Method Swizzling原理</h1><p>&emsp;&emsp;Method Swizzling是发生在运行时的，主要用于在运行时将两个Method进行交换，Method Swizzling配合类别可以实现在不干扰其他工程代码的情况下与系统的方法进行交换。<br><img src="http://pic.cloverkim.com/749c46aagy1fxmqwtqlguj20ft0b9aas.jpg" alt=""><br>&emsp;&emsp;在上图中，我们添加了selector3和IMP3，并让selector2指向了IMP3，而selector3则指向了IMP2，这样就实现了“方法交换”。<br>&emsp;&emsp;在Objective-C的runtime特性中，调用一个对象的方法就是给这个对象发送消息。是通过查找接收消息对象的方法列表，从方法列表中查找对应的SEL，这个SEL对应着一个IMP（一个IMP可以对应多个SEL），通过这个IMP找到对应的方法调用。<br>&emsp;&emsp;每个类中都有一个Dispatch Table，这个Dispatch Table本质是将类中的SEL和IMP进行对应。而我们的Method Swizzling就是对这个table进行了操作，让SEL对应另一个IMP。</p><h1 id="Method-Swizzling用法"><a href="#Method-Swizzling用法" class="headerlink" title="Method Swizzling用法"></a>Method Swizzling用法</h1><p>&emsp;&emsp;先给要交换的方法的类添加一个Category，然后在Category中的+(void)load（<a href="https://cloverkim.com/method_load_initialize.html">iOS开发 - +load 和 +initialize 方法</a>） 方法中添加Method Swizzling方法，我们用来交换的方法也写在Category中。</p><h2 id="两种使用方式："><a href="#两种使用方式：" class="headerlink" title="两种使用方式："></a>两种使用方式：</h2><ul><li>第1种：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)</span><br><span class="line"></span><br><span class="line">method_getImplementation(Method _Nonnull m) </span><br><span class="line"></span><br><span class="line">class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) </span><br><span class="line"></span><br><span class="line">class_replaceMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)</span><br></pre></td></tr></table></figure><ul><li>第2种：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)</span><br></pre></td></tr></table></figure><h1 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h1><ul><li>打印当前进入的controller的名称。为了方便日常开发的调试，我们可以交换系统viewDidLoad方法的实现，在新的方法中，打印当前控制器的名称，方便我们定位当前页面对应的controller。当然，线上版本并不需要，因此要打上DEBUG。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = [self class];</span><br><span class="line">        </span><br><span class="line">        SEL originalSelector = @selector(viewDidLoad);</span><br><span class="line">        SEL swizzledSelector = @selector(newViewDidLoad);</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line">        </span><br><span class="line">        BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        </span><br><span class="line">        if (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)newViewDidLoad &#123;</span><br><span class="line">    [self newViewDidLoad];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;=================================================&quot;);</span><br><span class="line">    NSLog(@&quot;进入%@ &quot;, NSStringFromClass([self class]));</span><br><span class="line">    NSLog(@&quot;=================================================&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>防止popToViewController方法，找不到对应的controller时，导致crash。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    Method oriMethod = class_getInstanceMethod([UINavigationController class], @selector(popToViewController:animated:));</span><br><span class="line">    Method exchangeMethod = class_getInstanceMethod([UINavigationController self], @selector(runtime_popToViewController:animated:));</span><br><span class="line">    method_exchangeImplementations(oriMethod, exchangeMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;UIViewController *&gt; *)runtime_popToViewController:(UIViewController *)controller animated:(BOOL)animated &#123;</span><br><span class="line">    if ([self.viewControllers containsObject:controller]) &#123;</span><br><span class="line">        return [self runtime_popToViewController:controller animated:animated];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        UIViewController *parent = controller.parentViewController;</span><br><span class="line">        while (parent != nil) &#123;</span><br><span class="line">            if ([self.viewControllers containsObject:parent]) &#123;</span><br><span class="line">                return [self runtime_popToViewController:parent animated:animated];</span><br><span class="line">            &#125;</span><br><span class="line">            parent = parent.parentViewController;</span><br><span class="line">        &#125;</span><br><span class="line">        NSAssert(YES, @&quot;navigation&apos;s controllers doesn&apos;t contain this controller&quot;);</span><br><span class="line">        return @[];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>防止因为数组越界而导致的crash（不推荐，有问题）<br>&emsp;&emsp;在iOS中NSNumber、NSArray、NSDictionary等这些类都是类簇（Class Clusters），一个NSArray的实现可能由多个类组成。所以如果想对NSArray进行Swizzling，必须获取到其“真身”进行Swizzling，直接对NSArray进行操作是无效的。这是因为Method Swizzling对NSArray这些的类簇是不起作用的。<br>&emsp;&emsp;因为这些类簇类，其实是一种抽象工厂的设计模式。抽象工厂内部有很多其他继承自当前类的子类，抽象工厂类会根据不同情况，创建不同的抽象对象来进行使用。例如我们调用NSArray的objectAtIndex：方法，这个类会在方法内部判断，内部创建不同抽象类进行操作。<br>&emsp;&emsp;所以如果我们对NSArray类进行Swizzling操作其实只是对父类进行了操作，在NSArray内部会创建其他子类来执行操作，真正执行Swizzling操作的并不是NSArray自身，所以我们应该对其“真身”进行操作。<br>&emsp;&emsp;下面列举了NSArray和NSDictionary本类的类名，可以通过Runtime函数取出本类：</li></ul><table><thead><tr><th>类名</th><th>真身</th></tr></thead><tbody><tr><td>NSArray</td><td>__NSArrayI</td></tr><tr><td>NSMutableArray</td><td>__NSArrayM</td></tr><tr><td>NSDictionary</td><td>__NSDictionaryI</td></tr><tr><td>NSMutableDictionary</td><td>__NSDictionaryM</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    Method oriMethod = class_getInstanceMethod(object_getClass(@&quot;__NSArrayI&quot;), @selector(objectAtIndex:));</span><br><span class="line">    Method exchangeMethod = class_getInstanceMethod(object_getClass(@&quot;__NSArrayI&quot;), @selector(runtime_objectAtIndex:));</span><br><span class="line">    method_exchangeImplementations(oriMethod, exchangeMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)runtime_objectAtIndex:(NSUInteger)index &#123;</span><br><span class="line">    if (self.count - 1 &lt; index) &#123;</span><br><span class="line">        NSAssert(YES, @&quot;Array indices are out of bounds&quot;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [self runtime_objectAtIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里需要注意：</strong></p><ul><li>当创建的数组，为空时，其class为<strong>NSArray0，当数组只有一个元素时，其class为</strong>NSSingleObjectArrayI，其他情况下，其class才为__NSArrayI。因此使用上述的方法进行防止crash时，需要考虑使用。因此不推荐该方法。</li><li>为何在交换的方法中，调用该方法，为何不调用原交换方法？因为系统的方法已经被我们交换了，因此我们写的交换方法的SEL指向的其实是系统原来的方法，如果我们再调用原交换方法的话，就会造成死循环了。这里需要注意！</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/6bcff1f9feee" target="_blank" rel="noopener">简书 - 陈满iOS - iOS开发·runtime原理与实践: 方法交换篇(Method Swizzling)(iOS“黑魔法”，埋点统计，禁止UI控件连续点击，防奔溃处理)</a></li><li><a href="http://www.cocoachina.com/ios/20180426/23192.html" target="_blank" rel="noopener">CocoaChina - 枣泥布丁 - iOS开发之 Method Swizzling 深入浅出</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 实践 </tag>
            
            <tag> runtime </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法学习 - 选择排序</title>
      <link href="//selection_sort.html"/>
      <url>//selection_sort.html</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&emsp;&emsp;初始时在序列中找到最小（大）的元素，放到序列的起始位置作为已排序序列；然后再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。直到所有元素均排列完毕。<br><a id="more"></a></p><h1 id="Swift-实现"><a href="#Swift-实现" class="headerlink" title="Swift 实现"></a>Swift 实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func selection_sort(_ array: inout [Int]) &#123;</span><br><span class="line">    var minIndex = 0</span><br><span class="line">    for i in 0..&lt;array.count - 1 &#123;</span><br><span class="line">        minIndex = i</span><br><span class="line">        for j in (i + 1)..&lt;array.count &#123;</span><br><span class="line">            if array[j] &lt; array[minIndex] &#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if minIndex != i &#123;</span><br><span class="line">            array.swapAt(minIndex, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var selectionArrays: [Int] = [3, 6, 4, 2, 9, 8, 5]</span><br><span class="line">selection_sort(&amp;selectionArrays)</span><br></pre></td></tr></table></figure><p><br></p><h1 id="和冒泡排序的区别"><a href="#和冒泡排序的区别" class="headerlink" title="和冒泡排序的区别"></a>和冒泡排序的区别</h1><p>&emsp;&emsp;冒泡排序通过依次交换相邻两个顺序不符合的元素位置，从而将当前最小（大）的元素放到合适的位置；而选择排序每次遍历依次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。</p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>&emsp;&emsp;比较次数O(n^2 ) 第一次内循环比较n-1次，然后是n-2次，n-3次，…，最后一次内循环比较1次。共比较的次数是(n-1) + (n-2) + … + 1，求等差数列和，得n * (n - 1) / 2。其时间复杂度为O(n^2 )。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法学习 - 希尔排序</title>
      <link href="//shell_sort.html"/>
      <url>//shell_sort.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>&emsp;&emsp;先将整个待排序的序列按照以增量gap=count/2的方式分割成为若干个子序列，再分别进行直接插入排序，待整个序列基本有序，即增量gap=1时，再对全体记录进行依次直接插入排序。<br><a id="more"></a><br><img src="http://pic.cloverkim.com/shell_sort.jpg" alt="" title="希尔排序示例图"><br>在上图中：<br>初始时，有一个大小为10的无序序列，颜色相同为一组。<br>在第一趟排序中，初始增量gap=count/2=5，意味着整个数组被分为5组，[9,5] [3,4] [2,6] [8,1] [7,5]，对这5组数据进行直接插入排序。<br>在第二趟排序中，我们把上次的增量gap缩小一半，gap=5/2=2，数组被分为2组，[5,2,5,4,8] [3,1,9,6,7]，再对这2组数据进行直接插入排序。<br>在第三趟排序中，再次将增量缩小为一半，gap=2/2=1，此时，整个数组为1组，[2,1,4,3,5,6,5,7,8,9]，再对最后一组数据进行直接插入排序，排序结束。</p><h1 id="Swift-实现"><a href="#Swift-实现" class="headerlink" title="Swift 实现"></a>Swift 实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func shellSort(_ array: inout [Int]) &#123;</span><br><span class="line">    var gap = array.count / 2</span><br><span class="line">    var j = 0</span><br><span class="line">    while gap &gt; 0 &#123;</span><br><span class="line">        for i in gap..&lt;array.count &#123;</span><br><span class="line">            let temp = array[i]</span><br><span class="line">            j = i</span><br><span class="line">            while j &gt;= gap &amp;&amp; temp &lt; array[j - gap] &#123;</span><br><span class="line">                array[j] = array[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            &#125;</span><br><span class="line">            array[j] = temp</span><br><span class="line">        &#125;</span><br><span class="line">        gap = gap / 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var shellArrays: [Int] = [9, 3, 2, 8, 7, 5, 4, 6, 1, 5]</span><br><span class="line">shellSort(&amp;shellArrays)</span><br></pre></td></tr></table></figure><h1 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h1><p>&emsp;&emsp;由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对位置，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，如上述数据中的5,5，最后其稳定性就会被打乱，所以希尔排序是不稳定的。</p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>&emsp;&emsp;希尔排序的时间复杂度是根据增量gap有关的。<br>&emsp;&emsp;在最优的情况下，即元素已经排好序，时间复杂度为：O(n^1.3 )<br>&emsp;&emsp;在最差的情况下，时间复杂度为O(n^2 )</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - KVC原理分析</title>
      <link href="//ios_kvc-principle.html"/>
      <url>//ios_kvc-principle.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>&emsp;&emsp;KVC（全称key-value coding）键值编码。在iOS开发中，允许开发者通过key直接访问对象的属性，或者给对象的属性进行赋值，而不需要调用明确的存取方法。这样就可以在运行时动态的访问和修改对象的属性，而不是在编译时确定。<br>&emsp;&emsp;KVC的定义是通过对NSObject的扩展来实现的，定义在NSKeyValueCoding.h文件中，是一个非正式协议。<br><a id="more"></a></p><h1 id="KVC相关方法"><a href="#KVC相关方法" class="headerlink" title="KVC相关方法"></a>KVC相关方法</h1><p>&emsp;&emsp;在NSKeyValueCoding中，KVC最为重要的方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 通过key来取值</span><br><span class="line">- (id)valueForKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">// 通过keyPath来取值</span><br><span class="line">- (id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line"></span><br><span class="line">// 通过key来设值</span><br><span class="line">- (void)setValue:(id)value forKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">// 通过keyPath来设值</span><br><span class="line">- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;NSKeyValueCoding中还有其他的相关方法，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// KVC提供属性值确认的API，它可以用来检查set的值是否正确，为不正确的值做一个替换值或者拒绝设值新值并返回错误原因</span><br><span class="line">- (BOOL)validateValue:(inout id  _Nullable *)ioValue forKey:(NSString *)inKey error:(out NSError * _Nullable *)outError;</span><br><span class="line"></span><br><span class="line">// 如果key不存在，且没有KVC无法搜索到任何和key有关的字段或者属性，则会调用这个方法，默认是抛出异常</span><br><span class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">// 和上一个方法一样，上一个方法为设值，该方法为取值</span><br><span class="line">- (id)valueForUndefinedKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">// 如果在setValue方法时给value传nil，则会调用该方法</span><br><span class="line">- (void)setNilValueForKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">// 输入一组key，返回该组key对应的value，再转成字典返回，用于将model转字典</span><br><span class="line">- (NSDictionary&lt;NSString *,id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;</span><br></pre></td></tr></table></figure></p><h1 id="寻找key的策略"><a href="#寻找key的策略" class="headerlink" title="寻找key的策略"></a>寻找key的策略</h1><h2 id="setValue-forKey-方法赋值的原理"><a href="#setValue-forKey-方法赋值的原理" class="headerlink" title="setValue:forKey:方法赋值的原理"></a>setValue:forKey:方法赋值的原理</h2><p>&emsp;&emsp;设值会调用<code>setValue:forKey:</code>方法，其大致步骤如下流程图所示：<br><img src="http://pic.cloverkim.com/setValue-forKey-流程图.jpg" alt="" title="setValue:forKey:流程图"></p><ol><li>查找<code>set&lt;Key&gt;:</code>或<code>_set&lt;Key&gt;:</code>命名的setter，按照这个顺序，如果找到，则调用这个方法并将值传进去。</li><li>如果没有发现一个简单的setter，但是<code>accessInstanceVariablesDirectly</code>类属性返回YES，则查找一个命名规则为_key、_isKey、key、isKey的实例变量。按照这个顺序，如果查找到则将value赋值给实例变量。</li><li>如果没有找到setter或实例变量，则调用<code>setValue:forUndefinedKey:</code>方法，并默认抛出一个异常。</li></ol><h2 id="valueForKey-方法取值的原理"><a href="#valueForKey-方法取值的原理" class="headerlink" title="valueForKey:方法取值的原理"></a>valueForKey:方法取值的原理</h2><p>&emsp;&emsp;当调用<code>valueForKey:</code>方法时，KVC对key的搜索顺序有点不同于<code>setValue:forKey:</code>方法，大致步骤如下：</p><ol><li>首先按<code>get&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code>的顺序查找getter方法，找到直接调用。<ul><li>若方法的返回结果类型是一个对象指针，则直接返回结果。</li><li>若类型为能够转化为NSNumber的基本数据类型，转换为NSNumber后返回；否则转换为NSValue返回。</li></ul></li><li><p>若上面的getter没有找到，则查找<code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;Key&gt;AtIndexes</code>格式的方法。<br>如果<code>countOf&lt;Key&gt;</code>和另外两个方法中的一个找到，那么就会返回一个可以响应NSArray所有方法的集合代理。发送给这个代理集合的NSArray消息方法，就会以<code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;Key&gt;AtIndexes</code>这几个方法组合的形式调用。如果receiver的类实现了<code>get&lt;Key&gt;:range:</code>方法，该方法也会用于性能优化。</p></li><li><p>还没查到，那么查找<code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>、<code>memberOf&lt;Key&gt;:</code>格式的方法。如果这3个方法都找到，那么久返回一个可以相应NSSet所有方法的集合代理。发送给这个代理集合的NSSet消息方法，就会以<code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>、<code>memberOf&lt;Key&gt;:</code>组合的形式调用。</p></li><li><p>还是没查到，那么如果类方法<code>accessInstanceVariablesDirectly</code>返回YES，那么按<code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code>的顺序直接搜索实例变量。如果搜索到了，则返回receiver相应实例变量的值。</p></li><li><p>再没有查到，调用<code>valueForUndefinedKey:</code>方法，抛出异常。</p></li></ol><h1 id="使用keyPath"><a href="#使用keyPath" class="headerlink" title="使用keyPath"></a>使用keyPath</h1><p>&emsp;&emsp;在实际开发过程中，一个类的成员变量有可能是自定义类或者其他的复杂数据类型，我们可以先用KVC获取该属性，然后再用KVC来获取这个自定义类的属性。但这样比较繁琐，因此KVC提供了一个解决方案，keyPath。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;                  //通过KeyPath来取值</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;  //通过KeyPath来设值</span><br></pre></td></tr></table></figure></p><h1 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h1><p>&emsp;&emsp;使用KVC过程中最常见的异常就是不小心使用了错误的key，或者在设值时不小心传了nil的值，KVC有特定的方法处理这些异常。</p><ul><li>KVC处理nil异常，如果在设值过程中，不小心传了nil值，KVC会调用方法<code>setNilValueForKey:</code>，这个默认方法是抛出<code>NSInvalidArgumentException</code>异常，所以一般而言最好重写这个方法，对异常进行处理。</li><li>KVC处理UndefinedKey异常，如果在设值取值传的key不存在时，程序就会crash，设值会调用到<code>setValue:forUndefinedKey:</code>方法，而取值会调用<code>valueForUndefinedKey:</code>方法，这两个方法默认都是抛出<code>NSUndefinedKeyException</code>异常，因此如果要避免程序crash，可以重写这两个方法。</li></ul><h1 id="集合类运算"><a href="#集合类运算" class="headerlink" title="集合类运算"></a>集合类运算</h1><h2 id="集合运算符格式"><a href="#集合运算符格式" class="headerlink" title="集合运算符格式"></a>集合运算符格式</h2><p>&emsp;&emsp;KVC提供的<code>valueForKeyPath:</code>方法非常强大，可以通过该方法对集合对象进行“深入”操作，在其keyPath中嵌套集合运算符，例如求一个数组中对象某个属性的count。集合运算符的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyPathToCollection.@collentionOperator.keyPathToproperty</span><br></pre></td></tr></table></figure></p><ul><li>keyPathToCollection：Left key path，要操作的集合对象，若调用<code>valueForKeyPath:</code>方法的对象本来就是集合对象，则可以为空。</li><li>collectionOperator：Collection operator，集合操作符，一般以@开头。</li><li>keyPathToproperty：Right key path，要运算的属性。</li></ul><h2 id="集合运算符的分类"><a href="#集合运算符的分类" class="headerlink" title="集合运算符的分类"></a>集合运算符的分类</h2><p>&emsp;&emsp;集合运算符主要分为以下三类：</p><ul><li>集合操作符：处理集合包含的对象，并根据操作符的不同返回不同的类型，返回值以NSNumber为主。</li><li>数组操作符：根据操作符的条件，将符合条件的对象包含在数组中返回。</li><li>嵌套操作符：处理集合对象中嵌套其他集合对象的情况，返回结果也是一个集合对象。</li></ul><h3 id="集合操作符"><a href="#集合操作符" class="headerlink" title="集合操作符"></a>集合操作符</h3><p>&emsp;&emsp;为了演示集合操作符，我们新建一个项目，定义一个Book类，有bookName和bookPrice属性，然后在main函数中，新建一个Book数组，再对数组进行集合操作。详细操作如下：</p><ul><li><p><code>@avg</code>用来计算集合中<code>right keyPath</code>指定的属性的平均值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *avgNum = [bookrack valueForKeyPath:@&quot;@avg.bookPrice&quot;];</span><br><span class="line">NSLog(@&quot;avg: %f&quot;, [avgNum floatValue]);</span><br></pre></td></tr></table></figure></li><li><p><code>@count</code>用来计算集合中对象的数量。注意：@count操作符不需要写rightKeyPath，如果写了也会被忽略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *count = [bookrack valueForKeyPath:@&quot;@count&quot;];</span><br><span class="line">NSLog(@&quot;count: %f&quot;, [count floatValue]);</span><br></pre></td></tr></table></figure></li><li><p><code>@sum</code>用来计算集合中<code>right keyPath</code>指定的属性的总和。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *sum = [bookrack valueForKeyPath:@&quot;@sum.bookPrice&quot;];</span><br><span class="line">NSLog(@&quot;sum: %f&quot;, [sum floatValue]);</span><br></pre></td></tr></table></figure></li><li><p><code>@max</code>用来查找集合中<code>right keyPath</code>指定属性的最大值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *max = [bookrack valueForKeyPath:@&quot;@max.bookPrice&quot;];</span><br><span class="line">NSLog(@&quot;max: %f&quot;, [max floatValue]);</span><br></pre></td></tr></table></figure></li><li><p><code>@min</code>用来查找集合中<code>right keyPath</code>指定属性的最小值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *min = [bookrack valueForKeyPath:@&quot;@min.bookPrice&quot;];</span><br><span class="line">NSLog(@&quot;min: %f&quot;, [min floatValue]);</span><br></pre></td></tr></table></figure></li></ul><h3 id="数组操作符"><a href="#数组操作符" class="headerlink" title="数组操作符"></a>数组操作符</h3><ul><li><p><code>@unionOfObjects</code>将集合中的所有对象的同一个属性放在数组中返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *priceArray = [bookrack valueForKeyPath:@&quot;@unionOfObjects.bookPrice&quot;];</span><br><span class="line">NSLog(@&quot;unionOfObjects: %@&quot;, priceArray);</span><br></pre></td></tr></table></figure></li><li><p><code>@distinctUnionOfObjects</code>将集合中对象的属性进行去重后并返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *nameArray = [bookrack valueForKeyPath:@&quot;@distinctUnionOfObjects.bookName&quot;];</span><br><span class="line">NSLog(@&quot;distinctUnionOfObjects: %@&quot;, nameArray);</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;需要注意：以上两个方法，如果操作的属性为nil，则在添加到数组中时会导致crash。</p><h3 id="嵌套操作符"><a href="#嵌套操作符" class="headerlink" title="嵌套操作符"></a>嵌套操作符</h3><p>&emsp;&emsp;由于嵌套操作符是需要对嵌套的集合对象进行操作，所以新建了一个racks数组，其中包含了两个Book类型对象的数组。</p><ul><li><p><code>@unionOfArrays</code>是用来操作集合内部的集合对象，将所有<code>right keyPath</code>对应的对象放在一个数组中返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *unionArray = [racks valueForKeyPath:@&quot;@unionOfArrays.bookName&quot;];</span><br><span class="line">NSLog(@&quot;unionOfArrays: %@&quot;, unionArray);</span><br></pre></td></tr></table></figure></li><li><p><code>@distinctUnionOfArrays</code>是用来操作集合内部的集合对象，将所有<code>right keyPath</code>对应的对象放在一个数组中，并进行去重后返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *distinctArray = [racks valueForKeyPath:@&quot;@distinctUnionOfArrays.bookPrice&quot;];</span><br><span class="line">NSLog(@&quot;distinctUnionOfArrays: %@&quot;, distinctArray);</span><br></pre></td></tr></table></figure></li></ul><h1 id="KVC-安全性检查"><a href="#KVC-安全性检查" class="headerlink" title="KVC 安全性检查"></a>KVC 安全性检查</h1><p>&emsp;&emsp;在使用KVC时，由于传入的key或者keyPath是一个字符串，因此很容易写错或者属性本身修改后忘记修改对应的字符串，导致crash。<br>&emsp;&emsp;解决的方案为，利用反射机制，通过<code>@selector()</code>获取到方法的SEL，然后通过<code>NSStringFromSelector()</code>将SEL反射为字符串。这样在<code>@selector()</code>中传入方法名的过程中，编译器会有合法性检查，如果方法不存在或者未实现时，会报对应的警告。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self valueForKey:NSStringFromSelector(@selector(object))];</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/BasicPrinciples.html#//apple_ref/doc/uid/20002170-BAJEAIEE" target="_blank" rel="noopener">Apple官方文档</a></li><li><a href="https://www.jianshu.com/p/f6c41ffb88df" target="_blank" rel="noopener">简书 - 拧发条鸟xds - iOS 关于KVC的一些总结</a></li><li><a href="https://imlifengfeng.github.io/article/493/" target="_blank" rel="noopener">个人blog - 李峰峰博客 - iOS KVC详解</a></li><li><a href="https://www.jianshu.com/p/1d39bc610a5b" target="_blank" rel="noopener">简书 - 刘小壮 - KVC原理剖析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - 对MRC和ARC的理解</title>
      <link href="//ios_memory-management.html"/>
      <url>//ios_memory-management.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理基本概念"><a href="#内存管理基本概念" class="headerlink" title="内存管理基本概念"></a>内存管理基本概念</h1><p>&emsp;&emsp;在OC的内存管理，其实就是引用计数的管理。内存管理就是在程序需要时程序员分配一段内存空间，而当使用完后将它释放。如果对内存资源使用不当，不存会造成内存资源的浪费，甚至会导致程序crash等。<br><a id="more"></a></p><h1 id="MRC-手动内存管理"><a href="#MRC-手动内存管理" class="headerlink" title="MRC - 手动内存管理"></a>MRC - 手动内存管理</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>&emsp;&emsp;我们都知道，当一个对象没有被任何变量引用时，就会被释放。那是怎么知道对象已经没有被任何变量引用了呢？答案就是Objc的引用计数了，相关说明如下：</p><ul><li>每个对象都有自己的引用计数器，而且是一个整数。</li><li>任何一个对象，刚创建的时候，引用计数都为1。</li><li>当结束使用该对象时，其引用计数则减1.</li><li>当引用计数器为0时，对象占用的内存就会被系统回收，对象将被释放。</li></ul><p>&emsp;&emsp;引用计数器的相关操作如下：</p><ul><li>当对象被创建，即通过alloc/new/copy等方法时，其引用计数器的初始值为1。</li><li>当给对象发送retain消息时，其引用计数器加1。</li><li>当给对象发送release消息时，其引用计数器减1。 </li><li>最后当对象的引用计数器为0时，Objc会给对象发送dealloc消息来销毁对象。</li></ul><h2 id="内存管理的规律"><a href="#内存管理的规律" class="headerlink" title="内存管理的规律"></a>内存管理的规律</h2><p>&emsp;&emsp;在MRC模式下，必须遵循：谁创建、谁释放、谁引用、谁管理的原则。这里用一个简单的🌰来进行说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 当对象被创建时，其引用计数器初始值为1</span><br><span class="line">    Dog *dog = [[Dog alloc] init];</span><br><span class="line">    NSLog(@&quot;retainCount = %lu&quot;, (unsigned long)[dog retainCount]);  // 1</span><br><span class="line">    </span><br><span class="line">    // 给对象发送retain消息时，其引用计数器加1</span><br><span class="line">    [dog retain];</span><br><span class="line">    NSLog(@&quot;retainCount = %lu&quot;, (unsigned long)[dog retainCount]);  // 2</span><br><span class="line">    </span><br><span class="line">    // 给dog指向的Dog实例对象发送一条release消息，其引用计数器会减1</span><br><span class="line">    [dog release];</span><br><span class="line">    NSLog(@&quot;retainCount = %lu&quot;, (unsigned long)[dog retainCount]);  // 1</span><br><span class="line">    </span><br><span class="line">    // 若再给dog指向的对象发送release消息，其引用计数器会为0，系统就会释放该对象</span><br><span class="line">    // 最后会调用Dog类的dealloc方法，释放该对象</span><br><span class="line">    [dog release];</span><br></pre></td></tr></table></figure></p><h2 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h2><h3 id="关于unrecognized-selector-sent-to-instance的crash"><a href="#关于unrecognized-selector-sent-to-instance的crash" class="headerlink" title="关于unrecognized selector sent to instance的crash"></a>关于<code>unrecognized selector sent to instance</code>的crash</h3><p>&emsp;&emsp;这是因为对象已经被释放（引用计数为0），这个时候再发消息给这个对象时，就会crash，因为这个时候这个对象就是一个野指针。正确且安全的做法是将对象置为nil，使它成为一个空指针。</p><h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><ul><li>没有存储任何内存地址的地址就称为空指针（NULL指针）</li><li>空指针就是被赋值为0的指针，在摸鱼被具体初始化之前，其指为0。</li></ul><h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>&emsp;&emsp;野指针不是NULL指针，是指向“垃圾”内存（不可用内存）的指针。<br>&emsp;&emsp;来举个🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cat *cat = [[Cat alloc] init];</span><br><span class="line">[cat setName:@&quot;小猫&quot;];</span><br><span class="line">[cat release];</span><br><span class="line">[cat setName:@&quot;小猫&quot;];</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在执行下面代码的时候，最后一行会出现野指针的错误，并且crash。相关说明：</p><ul><li>假设Cat对象的地址为0xff43，指针变量的地址为0xee44，cat中存储的是Cat对象的地址0xff43，即指针变量cat指向了这个Cat对象。</li><li>在执行完<code>[cat release];</code>时，给cat指向的Cat对象发送了一条release消息，Cat对象接收到release消息后，会马上被销毁，所占用的内存会被回收。Cat对象被销毁了，地址为0xff43的内存地址就变成了“垃圾内存”，然而指针变量cat仍然指向这一块内存，这时候，cat就称为野指针。</li><li>在最后一行代码中，cat所指向的Cat对象发送了一条setName:消息，但是Cat对象已经被销毁了，它所占的内存已经是垃圾内存，如果我们还去访问这一块内存，那么就会报野指针错误。</li><li>因此，要避免野指针错误导致的crash，我们需要在Cat对象被回收之后，将指针变量cat置为nil，变成空指针，没有指向任何对象，因此setName:消息不会发送出去，也不会造成crash。</li></ul><h2 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h2><h3 id="简介及原理"><a href="#简介及原理" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>&emsp;&emsp;当我们不再使用一个对象的时候，应该将其释放。但我们很难理清一个对象什么时候不再使用，也就不知何时释放，为了解决这个问题，Objc提供了autorelease方法来解决这个问题。<br>&emsp;&emsp;autorelease实质上是把对release的调用延迟了，对于每一个autorelease，系统只是把该对象放入了当前的autorelease pool中，当改池子被释放时，该池子中的所有对象会被调用release。<br>&emsp;&emsp;这里需要特别注意：<strong>autorelease方法会返回本身对象，且调用完autorelease方法后，对象的retainCount不变。</strong></p><h3 id="autorelease的好处"><a href="#autorelease的好处" class="headerlink" title="autorelease的好处"></a>autorelease的好处</h3><ul><li>不需要关心对象释放的时间</li><li>不需要关心什么时候、在哪里调用release方法</li></ul><h3 id="autorelease的创建和使用"><a href="#autorelease的创建和使用" class="headerlink" title="autorelease的创建和使用"></a>autorelease的创建和使用</h3><h4 id="两种创建方式："><a href="#两种创建方式：" class="headerlink" title="两种创建方式："></a>两种创建方式：</h4><ul><li><p>使用NSAutoreleasePool进行创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">Cat *cat = [[Cat alloc] init];</span><br><span class="line">[cat autorelease];</span><br><span class="line">[pool release];</span><br></pre></td></tr></table></figure></li><li><p>使用@autoreleasepool创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">        Cat *cat = [[Cat new] autorelease];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><ul><li>自动释放池实质上只是在释放的时候给池子中所有对象发送release消息，不保证对象一定会销毁，如果自动释放池向对象发送release消息后对象的引用计数仍大于1，那对象就会无法销毁。</li><li>一些大内存消耗对象的重复创建时，使用@autoreleasepool时，需要将@autoreleasepool放在for循环里面，如果整个for循环是在@autorelease中，则还是会使得内存暴涨。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 99999; ++i) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSString *log = [NSString stringWithFormat:@&quot;%d&quot;, i];</span><br><span class="line">         NSLog(@&quot;%@&quot;, log);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="MRC下使用ARC"><a href="#MRC下使用ARC" class="headerlink" title="MRC下使用ARC"></a>MRC下使用ARC</h2><p>&emsp;&emsp;在项目的Build Phases的Compile Sources中选择需要使用ARC方式的.m文件，然后双击该文件，在弹出的对话框中输入<code>-fobjc-arc</code>即可。</p><h1 id="ARC自动内存管理"><a href="#ARC自动内存管理" class="headerlink" title="ARC自动内存管理"></a>ARC自动内存管理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;自动的引用计数（Automatic Referencen Count 简称ARC），苹果在WWDC 2011年大会上提出的用于内存管理的技术。使用ARC后，编译器会我们管理好对象的内存，何时需要保持对象，何时需要自动释放对象，编译器会在合适的地方为我们插入retain、release和autorelease。</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>&emsp;&emsp;只要还有一个强指针变量指向对象，对象就会保持在内存中。</p><h2 id="强指针和弱指针"><a href="#强指针和弱指针" class="headerlink" title="强指针和弱指针"></a>强指针和弱指针</h2><ul><li>默认所有实例变量和局部变量都是强指针。</li><li>弱指针指向的对象被回收后，弱指针会自动变为nil指针，不会引发野指针错误。</li></ul><h2 id="ARC的注意点"><a href="#ARC的注意点" class="headerlink" title="ARC的注意点"></a>ARC的注意点</h2><ul><li>不允许调用release、retain、autorelease、retainCount方法</li><li>重写父类的dealloc方法时，不能再调用[super dealloc];</li><li>两个类相互引用时，其中一个类使用strong，另一个类使用weak</li></ul><h2 id="ARC下使用MRC"><a href="#ARC下使用MRC" class="headerlink" title="ARC下使用MRC"></a>ARC下使用MRC</h2><p>&emsp;&emsp;在项目的Build Phases的Compile Sources中选择需要使用MRC方式的.m文件，然后双击该文件，在弹出的对话框中输入<code>-fno-objc-arc</code>即可</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 基础 </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - KVO原理分析与使用</title>
      <link href="//ios_kvo-principle.html"/>
      <url>//ios_kvo-principle.html</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>&emsp;&emsp;KVO全称KeyValueObserving，是Objective-C对观察者设计模式的一种实现。允许对象监听另一个对象特定属性的改变，并在改变时接收到事件。由于KVO的实现机制，所以对属性才会好发生作用，一般继承自NSObject的对象都默认支持KVO。</p><a id="more"></a><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>&emsp;&emsp;当观察某对象A时，KVO机制动态创建一个对象A的子类，并为这个新的子类重写了被观察属性keyPath的setter方法。setter方法随后负责通知观察对象属性的改变。<br>&emsp;&emsp;KVO使用了isa-swizzling来实现。当观察对象A时，KVO机制动态创建一个新的类为：NSKVONotifying_A，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter方法，setter方法会负责在调用原setter方法之前和之后，通知所有观察对象属性值的更改情况。<br>&emsp;&emsp;NSKVONotifying_A类：被观察对象的isa指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类NSKVONotifying_A类，来实现当前类属性值改变的监听。<br>&emsp;&emsp;子类setter方法：KVO的键值观察通知依赖于NSObject的两个方法：<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>，在存取数值的前后分别调用2个方法：被观察属性发生改变之前，<code>willChangeValueForKey:</code>被调用，通知系统该keyPath的属性值即将变更；当改变发生后，<code>didChangeValueForKey:</code>被调用，通知系统该keyPath的属性值已经变更；之后，<code>observeValueForKeyPath: ofObject: change: context:(void *)context;</code> 也会被调用。</p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ol><li>KVO的<code>addObserver</code>和<code>removeObserver</code>必须是成对的，如果重复调用remove则会导致NSRangeException类型的crash，如果忘记remove，则会在观察者释放后再次接收到KVO回调时会导致crash。</li><li>观察者观察的是属性，只有遵循KVO变更属性值的方式才会执行KVO的回调方法。如果赋值没有通过setter方法或者KVC，而是直接修改属性对应的成员变量，是不会触发KVO机制，更加不会调用回调方法。所以使用KVO机制的前提是遵循KVO的属性设置方法来变更属性值。</li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>&emsp;&emsp;通过<code>addObserver:forKeyPath:options:context:</code>方法注册观察者，观察者可以接收kayPath属性的变化事件。在注册观察者时，可以传入options参数，参数是一个枚举类型。如果传入<code>NSKeyValueObservingOptionNew</code>和<code>NSKeyValueObservingOptionOld</code>表示接收新值和旧值，默认为只接收新值。如果想再注册观察者后，立即接收一次回调，则可以为options参数传入<code>NSKeyValueObservingOptionInitial</code>。<br>&emsp;&emsp;还可以通过方法的context参数传入任意类型的对象，在接收消息回调的代码中可以接收到这个对象。</p><h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><p>&emsp;&emsp;观察者需要实现<code>observeValueForKeyPath:ofObject:change:context:</code>方法，当KVO时间到来时会调用这个方法，如果没有实现该方法会导致crash。change是一个字典，里面存放KVO属性相关的值，根据注册观察者时，options参数传入的枚举来返回。枚举会对应相应key来从字典中取出值，例如<code>NSKeyValueChangeOldKey</code>字段，存储改变之前的旧值。<br>&emsp;&emsp;如果被观察对象是集合对象，在<code>NSKeyValueChangeKindKey</code>字段中会包含<code>NSKeyValueChangeInsertion</code>、<code>NSKeyValueChangeRemoval</code>、<code>NSKeyValueChangeReplacement</code>的信息，表示集合对象的操作方式。</p><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><p>&emsp;&emsp;当不需要监听或者观察者要销毁时，需要调用<code>removeObserver:forKeyPath:</code>方法，将KVO移除，否则会导致crash。</p><h1 id="应用举例（Swift）"><a href="#应用举例（Swift）" class="headerlink" title="应用举例（Swift）"></a>应用举例（Swift）</h1><p>&emsp;&emsp;我们在新建项目的storyboard上，放一个UIButton和一个UILabel，新建一个继承自NSObject的model类，model中有一个num变量，当点击按钮时，使num + 1，并在controller中监听num值得改变，然后显示在UILabel上。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@objcMembers class KVOModel: NSObject &#123;</span><br><span class="line">    </span><br><span class="line">    dynamic var num = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    @IBOutlet weak var numLabel: UILabel!</span><br><span class="line">    </span><br><span class="line">    var model = KVOModel()</span><br><span class="line">    var ob: NSKeyValueObservation!</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        ob = model.observe(\.num, options: [.old, .new]) &#123; [weak self] (ob, change) in</span><br><span class="line">            if let value = change.newValue &#123;</span><br><span class="line">                self?.numLabel.text = &quot;\(value)&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @IBAction func addBtnAction() &#123;</span><br><span class="line">        model.num += 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;相关说明：</p><ul><li>demo采用的是Swift，并且添加KVO监听的方式和OC的不一样，当然也可以用addObserver的方式。这样的好处是不需要手动remove了，但需要注意的是，观察的闭包没有被强引用，避免循环引用问题。</li><li>由于Swift本身屏蔽了运行时机制，只有NSObject才能支持KVO，Swift4中继承NSObject的Swift class不再默认全部bridge到OC，然而KVO又是一个纯OC的特性，所以在创建Swift class的时候需要增加<strong>@objcMembers</strong>关键字，另外被观察的属性也需要用<strong>dynamic</strong>关键字进行修饰，否则也无法观察到。</li><li>KVO之后返回的是一个<strong>NSKeyValueObservation</strong>实例，需要自己控制这个实例的生命周期。</li><li><strong>demo中，model的num的值直接controller中进行修改，这种做法是错误不可取的，在实际的项目中，千万不要这么使用。</strong></li></ul><h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p>&emsp;&emsp;这里推荐一个第三方，Facebook开源的替代KVO的解决方案<a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">FBKVOController</a>，它用block解决了以前使用KVO时代码散乱的缺点，详细可以看这篇文章：<a href="http://cloverkim.com/kvo_extension.html">iOS开发 - 分享一个关于KVO的扩展</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 基础 </tag>
            
            <tag> 观察者设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - NSNotification原理理解</title>
      <link href="//ios_notification-principle.html"/>
      <url>//ios_notification-principle.html</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>&emsp;&emsp;NSNotification是iOS中一个调度消息通知的类，采用单例设计模式，在开发中实现传值、回调等。在iOS中，NSNotification是使用观察者模式来实现用于跨层传递消息。</p><a id="more"></a><h1 id="三个主要类"><a href="#三个主要类" class="headerlink" title="三个主要类"></a>三个主要类</h1><h2 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h2><p>&emsp;&emsp;NSNotification包含了一些用于向其他对象发送通知的必要信息，包括名称、对象和可选字典，并由NSNotificationCenter或NSDistributedNotificationCenter的实例进行发送。name是标识通知的标记、object是保存发送通知的对象、userinfo存储其他相关对象。<strong>这里主要注意的是：NSNotification对象是不可变的。</strong></p><table><thead><tr><th style="text-align:center">字段名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">name</td><td style="text-align:center">通知的名称，用于通知的唯一标识</td></tr><tr><td style="text-align:center">object</td><td style="text-align:center">保存发送通知的对象</td></tr><tr><td style="text-align:center">userinfo</td><td style="text-align:center">存储其他相关对象</td></tr></tbody></table><p>&emsp;&emsp;可以使用<code>notificationWithName:object:</code> 或 <code>notificationWithName:object:userInfo:</code> 创建通知对象。但实际开发中，一般是直接使用NSNotificationCenter调用 <code>postNotificationName:object:</code> 或 <code>postNotificationName:object:userInfo:</code> ，这两个类方法会在内部直接创建NSNotification对象，并发出通知。<br>&emsp;&emsp;从官网文档可知，NSNotification是不能直接实例化的，如果用init方法进行实例化时，会引发异常。还有需要注意的是如果我们自己去实现构造方法时，不能在super上调用init方法。</p><h2 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h2><p>&emsp;&emsp;NSNotificationCenter提供了一套机制来发送通知，每个运行中的应用程序都有一个defaultCenter通知中心，我们可以创建新的通知中心来组织特定上下文中的通信。&emsp;&emsp;NSNotificationCenter暴露给外部的字段只有一个defaultCenter，并且该字段是只读的，暴露出来的方法分为三种：添加、移除通知观察者和发出通知。详细如下表所示：</p><table><thead><tr><th style="text-align:center">作用</th><th style="text-align:center">相关方法</th></tr></thead><tbody><tr><td style="text-align:center">添加通知观察者</td><td style="text-align:center">addObserver:selector:name:object:<br>addObserverForName:object:queue:usingBlock:</td></tr><tr><td style="text-align:center">移除通知观察者</td><td style="text-align:center">removeObserver: <br>removeObserver:name:object:</td></tr><tr><td style="text-align:center">发出通知</td><td style="text-align:center">postNotification:<br>postNotificationName:object: <br>postNotificationName:object:userInfo:</td></tr></tbody></table><p>&emsp;&emsp;相关说明：</p><ul><li><code>addObserverForName:object:queue:usingBlock:</code>方法，相比<code>addObserver:selector:name:object:</code>方法多了queue和block，queue就是决定将block回调提交到哪个队列里面执行。这里需要注意的是发送通知和接收通知的线程必须为同一个。常见情况下会把queue设置为主队列，因为主队列的任务都会在主线程下完成，因此可以用这种方式来实现通知更新UI。</li></ul><h2 id="NSNotificationQueue"><a href="#NSNotificationQueue" class="headerlink" title="NSNotificationQueue"></a>NSNotificationQueue</h2><p>&emsp;&emsp;简单理解为：通知中心的缓冲区。尽管通知中心已经分发通知，但放置到队列中的通知可能会延迟，直到runloop结束或者runloop空闲时才发送。如果有多个相同的通知，NSNotificationQueue会将其进行合并，以便在发布多个通知的情况下只发送一个通知。<br>&emsp;&emsp;通知队列按照先进先出(FIFO)的顺序维护通知。当一个通知移动到队列的前面时，队列将它发送到通知中心，然后再将通知分派给所有注册为观察者的对象。每个线程都有一个默认的通知队列，该队列与流程的默认通知中心相关联。我们也可以创建自己的通知队列。<br>&emsp;&emsp;和NSNotificationCenter一样，NSNotificationQueue也只暴露了一个字段：defaultQueue，返回当前线程的默认通知队列。方法分为：创建通知队列和管理通知。详细说明如下表所示：</p><table><thead><tr><th style="text-align:center">作用</th><th style="text-align:center">相关方法</th></tr></thead><tbody><tr><td style="text-align:center">创建通知队列</td><td style="text-align:center">initWithNotificationCenter:</td></tr><tr><td style="text-align:center">管理通知</td><td style="text-align:center">enqueueNotification:postingStyle:<br> dequeueNotificationsMatching:coalesceMask:<br>enqueueNotification:postingStyle:coalesceMask:forModes:</td></tr></tbody></table><p>&emsp;&emsp;方法相关说明：</p><ul><li><code>initWithNotificationCenter:</code> 初始化并返回指定通知中心的通知队列。</li><li><code>enqueueNotification:postingStyle:</code> 使用指定的发布样式向通知队列添加通知。</li><li><code>dequeueNotificationsMatching:coalesceMask:</code> 使用提供的匹配条件从匹配提供的通知的队列中删除所有通知。</li><li><code>enqueueNotification:postingStyle:coalesceMask:forModes:</code> 使用指定的发布样式、合并标准和运行循环模式向通知队列添加通知。</li></ul><p>&emsp;&emsp;在上面的方法中，需要注意的2个常量，相关说明如下：</p><ul><li><p>NSPostingStyle：用于指定何时发布通知</p><ul><li>NSPostASAP：在当前通知调用或者计时器结束时发出通知</li><li>NSPostWhenIdle：当runloop处于空闲时发出通知</li><li>NSPostNow：当合并通知完成之后立即发出通知</li></ul></li><li><p>NSNotificationCoalescing：用于指定通知如何合并</p><ul><li>NSNotificationNoCoalescing：不合并通知</li><li>NSNotificationCoalescingOnName：合并具有相同名称的通知</li><li>NSNotificationCoalescingOnSender： 将通知与相同的对象合并</li></ul></li></ul><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>&emsp;&emsp;NSNotificationCenter定义了两个Table，同时为了封装观察者信息，也定义了Observation保存观察者信息。他们的结构体可以简化如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct NCTbl &#123;</span><br><span class="line">    Observation   *wildcard;  // 保存既没有没有传入通知名字也没有传入object的通知</span><br><span class="line">    MapTable       nameless;  // 保存没有传入通知名字的通知</span><br><span class="line">    MapTable       named;     // 保存传入了通知名字的通知</span><br><span class="line">&#125; NCTable;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Obs &#123;</span><br><span class="line">    id        observer;       // 保存接受消息的对象</span><br><span class="line">    SEL       selector;       // 保存注册通知时传入的SEL</span><br><span class="line">    struct Obs    *next;      // 保存注册了同一个通知的下一个观察者</span><br><span class="line">    struct NCTbl  *link;      // 保存改Observation的Table</span><br><span class="line">&#125; Observation;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在NSNotificationCenter内部一共保存了两张表，一张用于保存添加观察者的时候传入的NotificationName的情况；一张用于保存添加观察者的时候没有传入NotificationCenter的情况，详细分析如下：</p><h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h2><h3 id="Named-Table"><a href="#Named-Table" class="headerlink" title="Named Table"></a>Named Table</h3><p>&emsp;&emsp;在Named Table中，NotificationName作为表的key，因为我们在注册观察者的时候是可以传入一个object参数用于只监听该对象发出的通知，并且一个通知可以添加多个观察者，所以还需要一张表用来保存object和observe的对应关系。这张表的key、value分别是以object为key，observe为value。所以对于Named Table，最终的结构为：</p><ul><li>首先外层有一个Table，以通知名称为key。其value同样是一个Table。</li><li>为了实现可以传入一个参数object用于只监听指定该对象发出的通知，及一个通知可以添加多个观察者。则内Table以传入的object为key，用链表来保存所有的观察者，并且以这个链表为value。</li></ul><p><img src="http://pic.cloverkim.com/Named Table.jpg" alt="" title="Named Table"></p><p>&emsp;&emsp;特别说明：在实际开发中，我们经常将object参数传nil，这个时候系统会根据nil自动产生一个key。相当于这个key对应的value（链表）保存的就是对于当前NotificationName没有传入object的所有观察者。当NotificationName被发送时，在链表中的观察者都会收到通知。</p><h3 id="UnNamed-Table"><a href="#UnNamed-Table" class="headerlink" title="UnNamed Table"></a>UnNamed Table</h3><p>&emsp;&emsp;UNamed Table结构比Named Table简单得多。因为没有NotificationName作为key。这里直接就以object为key，比Named Table少了一层Table嵌套。<br><img src="http://pic.cloverkim.com/UnNamed Table.jpg" alt="" title="UnNamed Table"></p><p>&emsp;&emsp;如果在注册观察者时没有传入NotificationName，同时没有传入object，所有的系统通知都会发送到注册的对象里。</p><h2 id="添加观察者的流程"><a href="#添加观察者的流程" class="headerlink" title="添加观察者的流程"></a>添加观察者的流程</h2><p>&emsp;&emsp;首先在初始化NSNotificationCenter时会创建一个对象，这个对象里面保存了Named Table、UNamed Table和其他信息。</p><ol><li>首先会根据传入的参数，实例化一个Observation。该Observation对象保存了观察者对象、接收到通知观察者对所执行的方法，由于Observation是一个链表，还保存了下一个Observation的地址。</li><li>根据是否传入通知的Name，选择在Named Table还是UNamed Table进行操作。</li><li>如果传入通知的name，则会先去用name去查找是否已经有对应的value（注意这个时候返回的value是一个Table）</li><li>如果没有对应的value，则创建一个新的Table，然后将这个Table以name为key添加到Named Table。如果有value，那直接去取出这个Table。</li><li>得到了保存Observation的Table之后，就通过传入的object拿对应的链表。如果object为空，会默认有一个key表示传入object为空的情况，取的时候也会直接用这个key去取，表示任何地方发送通知都会监听。</li><li>如果保存Observation的Table中根据object作为key没有找到对应的链表时，则会创建一个节点，作为头结点插入进去；如果找到了则直接在链表末尾插入之前实例化好的Observation中。</li></ol><p>&emsp;&emsp;在没有传入NotificationName的情况和上面的过程类似，只不过是直接根据object去对应的链表而已。如果既没有传入NotificationName，也没有传入object，则这个观察者会添加到wildcard链表中。</p><h2 id="发送通知的流程"><a href="#发送通知的流程" class="headerlink" title="发送通知的流程"></a>发送通知的流程</h2><p>&emsp;&emsp;发送通知一般是调用<code>postNotificationName:object:userInfo:</code>方法来实现。该方法内部会实例化一个NSNotification来保存传入的各种参数，包括name、object和userinfo。<br>&emsp;&emsp;发送通知的流程总体来说就是根据NotificationName查找到对应的Observer链表，然后遍历整个链表，给每个Observer结点中保存的对象及SEL，来向对象发送消息。具体流程如下：</p><ol><li>首先会定义一个数组ObserversArray来保存需要通知的Observer。之前在添加观察者的时候把既没有传入NotificationName，也没有传入object的，保存在了wildcard。因为这样观察者会监听所有NotificationName的通知，所以先把wildcard链表遍历一遍，将其中的Observer加到数组ObserversArray中。</li><li>找到以object为key的Observer链表。这个过程分为：在Named Table中查找，以及在UNamed Table中查找。然后将遍历找到的链表，同样加入到最开始创建的数组ObserversArray中。</li><li><p>至此，所有关于NotificationName的Observer（wildcard + UNamed Table + Named Table）已经加入到了数组ObserversArray中。接下来就是遍历这个ObserversArray数组，一次取出其中的Observer结点。因为这个结点保存了观察者对象以及selector。所以最终调用形式如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[observerNode-&gt;observer performSelector: o-&gt;selector withObject: notification];</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;这个方式也就能说明，发送通知的线程和接收通知的线程都是同一个线程。</p><h1 id="NSNotification与多线程"><a href="#NSNotification与多线程" class="headerlink" title="NSNotification与多线程"></a>NSNotification与多线程</h1><p>&emsp;&emsp;NSNotification和线程同步之间是什么关系呢？先看下官方文档的说明：</p><blockquote><p>In a multithreaded application, notifications are always delivered in the thread in which the notification was posted, which may not be the same thread in which an observer registered itself.</p></blockquote><p>翻译过来意思为：</p><blockquote><p>在多线程应用程序中，通知总是在发出通知的线程中传递，而该线程不一定是观察者观察者的那个线程。</p></blockquote><p>&emsp;&emsp;更多关于NSNotification与线程之间的关系，请阅读下面的文章：<a href="http://cloverkim.com/ios_notification-thread.html">iOS开发 - NSNotification和线程相关</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;总的来说，NSNotification的三个相关类的作用，可以用下图进行归纳总结。<br><img src="http://pic.cloverkim.com/总结.jpg" alt="" title="总结"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Notifications/Articles/Notifications.html" target="_blank" rel="noopener">Apple官方文档</a></li><li><a href="https://www.jianshu.com/p/83770200d476" target="_blank" rel="noopener">简书 - 纸简书生 - 深入理解iOS NSNotification</a></li><li><a href="https://blog.csdn.net/qq_18505715/article/details/76146575" target="_blank" rel="noopener">CSDN - YFL_iOS - iOS Notification实现原理</a></li><li><a href="https://www.jianshu.com/p/4f47a8f07f0e" target="_blank" rel="noopener">简书 - 高浩浩浩浩浩浩 - NSNotification 的细节</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - NSNotification和线程相关</title>
      <link href="//ios_notification-thread.html"/>
      <url>//ios_notification-thread.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题的开始"><a href="#问题的开始" class="headerlink" title="问题的开始"></a>问题的开始</h1><p>&emsp;&emsp;我们都知道NSNotification是线程同步的，但有时却很容易忽视线程同步这个特性带来的问题。比如举下面的例子：<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)notificationAction &#123;</span><br><span class="line">    NSLog(@&quot;开始发通知&quot;);</span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;knotificationDemo&quot; object:nil];</span><br><span class="line">    NSLog(@&quot;通知结束了&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后在接收通知的controller中模拟一个耗时的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)notify &#123;</span><br><span class="line">    NSLog(@&quot;模拟耗时操作&quot;);</span><br><span class="line">    [NSThread sleepForTimeInterval:3.0];</span><br><span class="line">    NSLog(@&quot;耗时操作结束&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;控制台的打印结果如下图所示：<br><img src="http://pic.cloverkim.com/006tNc79gy1fzoh957aghj30fi03ldgz.jpg" alt=""><br>&emsp;&emsp;看到执行结果的打印，我们就能大致理解Notification的线程同步的特性了。在主线程中发出通知，然后接收方在主线程处理逻辑，并接收方处理完毕时，发送方才能继续执行剩下的逻辑。<br>&emsp;&emsp;那么，Notification和线程同步之间到底是什么关系呢?<br>&emsp;&emsp;官方文档说明如下：</p><blockquote><p>In a multithreaded application, notifications are always delivered in the thread in which the notification was posted, which may not be the same thread in which an observer registered itself.</p><p>在多线程应用程序中，通知总是在发出通知的线程中传递，而该线程不一定是观察者观察者的那个线程。</p></blockquote><h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>&emsp;&emsp;那如果我们的Notification是在其他线程中post的，如何能在主线程中对这个Notification进行处理呢？或者说：如果我们希望一个Notification的post线程与接收线程不是同一个线程，应该怎么办？先来看下官方文档的相关说明：</p><blockquote><p>For example, if an object running in a background thread is listening for notifications from the user interface, such as a window closing, you would like to receive the notifications in the background thread instead of the main thread. In these cases, you must capture the notifications as they are delivered on the default thread and redirect them to the appropriate thread.</p></blockquote><blockquote><p>例如，如果在后台线程中运行的对象正在监听来自用户界面的通知，例如窗口关闭，则希望在后台线程而不是主线程中接收通知。在这些情况下，您必须在默认线程上传递通知时捕获它们，并将它们重定向到适当的线程中。</p></blockquote><p>&emsp;&emsp;官方文档中讲到了“重定向”，就是我们在Notification所在的默认线程中捕获这些分发的通知，然后将其重定向到指定的线程中。<br>&emsp;&emsp;一种重定向的实现思路是自定义一个通知队列（<strong>注意，不是NSNotificationQuene对象，而是一个数组</strong>），让这个队列去维护那些我们需要重定向的Notification。我们仍然是像平常一样去注册一个通知的观察者，当Notification来了时，先看看post这个Notification的线程是不是我们所期望的线程，如果不是，则将这个Notification存储到我们的队列中，并发送一个信号（Signal）到期望的线程中，来告诉这个线程需要处理一个Notification。指定的线程在收到信号后，将Notification从列表中移除，并进行处理。<br>&emsp;&emsp;下面借助官方文档给出的demo，进行测试看下实际结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&lt;NSMachPortDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property(nonatomic) NSMutableArray     *notifications;         // 通知队列</span><br><span class="line">@property(nonatomic) NSThread           *notificationThread;    // 期望线程</span><br><span class="line">@property(nonatomic) NSLock             *notificationLock;      // 用于对通知队列加锁的锁对象，避免线程冲突</span><br><span class="line">@property(nonatomic) NSMachPort         *notificationPort;      // 用于向期望线程发送信号的通信端口</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notify) name:@&quot;knotificationDemo&quot; object:nil];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;...&quot;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    // 初始化</span><br><span class="line">    self.notifications = [[NSMutableArray alloc] init];</span><br><span class="line">    self.notificationLock = [[NSLock alloc] init];</span><br><span class="line">    self.notificationThread = [NSThread currentThread];</span><br><span class="line">    self.notificationPort = [[NSMachPort alloc] init];</span><br><span class="line">    self.notificationPort.delegate = self;</span><br><span class="line">    </span><br><span class="line">    // 往当前线程的runloop添加端口源</span><br><span class="line">    // 当Mach消息到达而接收线程的runloop没有运行时，则内核会保存这条消息，直到下一次进入runloop</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:self.notificationPort forMode:(__bridge NSString *)kCFRunLoopCommonModes];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:@&quot;ktestNotification&quot; object:nil];</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;ktestNotification&quot; object:nil userInfo:nil];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleMachMessage:(void *)msg &#123;</span><br><span class="line">    [self.notificationLock lock];</span><br><span class="line">    </span><br><span class="line">    while ([self.notifications count]) &#123;</span><br><span class="line">        NSNotification *notification = [self.notifications objectAtIndex:0];</span><br><span class="line">        [self.notifications removeObjectAtIndex:0];</span><br><span class="line">        [self.notificationLock unlock];</span><br><span class="line">        [self processNotification:notification];</span><br><span class="line">        [self.notificationLock lock];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    [self.notificationLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)processNotification:(NSNotification *)notification &#123;</span><br><span class="line">    if ([NSThread currentThread] != self.notificationThread) &#123;</span><br><span class="line">        // 将通知转发到正确的线程</span><br><span class="line">        [self.notificationLock lock];</span><br><span class="line">        [self.notifications addObject:notification];</span><br><span class="line">        [self.notificationLock unlock];</span><br><span class="line">        [self.notificationPort sendBeforeDate:[NSDate date]</span><br><span class="line">                                   components:nil</span><br><span class="line">                                         from:nil</span><br><span class="line">                                     reserved:0];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 在这里处理通知</span><br><span class="line">        NSLog(@&quot;current thread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">        NSLog(@&quot;process notification&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;运行后的输出结果如下：<br><img src="http://pic.cloverkim.com/006tNc79gy1fzop4fxlmwj30ip03sjsk.jpg" alt=""></p><p>&emsp;&emsp;由上图的运行结果可以看出，我们在全局dispatch队列中抛出的Notification，如愿的在主线程中接收到了。<br>&emsp;&emsp;这种实现方式的具体解析以及其局限性大家可以参考官方文档<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Notifications/Articles/Threading.html#//apple_ref/doc/uid/20001289-CEGJFDFG" target="_blank" rel="noopener">Delivering Notifications To Particular Threads</a>。当然，更好的方法可能是我们自己去子类化一个NSNotificationCenter，或者单独写一个类来处理这种转发。<br>&emsp;&emsp;而且官方文档告诉我们，NSNotificationCenter是一个线程安全类，我们可以在多线程环境下使用同一个NSNotificationCenter对象而不需要加锁。原文在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html" target="_blank" rel="noopener">Threading Programming Guide</a>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Notifications/Articles/Notifications.html" target="_blank" rel="noopener">Apple官方文档 - Notification Programming Topics</a></li><li><a href="https://www.jianshu.com/p/4f47a8f07f0e" target="_blank" rel="noopener">简书 - 高浩浩浩浩浩浩 - NSNotification 的细节</a></li><li><a href="http://www.cocoachina.com/ios/20150316/11335.html" target="_blank" rel="noopener">Cocoa China - lansekuangtu - Notification与多线程</a></li><li><a href="http://inessential.com/2013/12/20/observers_and_thread_safety" target="_blank" rel="noopener">Observers and Thread Safety</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - 分享一个关于KVO的扩展</title>
      <link href="//kvo_extension.html"/>
      <url>//kvo_extension.html</url>
      
        <content type="html"><![CDATA[<h1 id="主要代码（Swift）"><a href="#主要代码（Swift）" class="headerlink" title="主要代码（Swift）"></a>主要代码（Swift）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">typealias KVONotificationBlock = (Any?, _ oldValue: Any?, _ value: Any?) -&gt; Void</span><br><span class="line"></span><br><span class="line">extension NSObject &#123;</span><br><span class="line">    //默认的函数，option的初始值是Initial|New, 监测打变化的值默认转到主线程</span><br><span class="line">    func observe(_ object: Any?, keyPath: String, block: @escaping KVONotificationBlock) &#123;</span><br><span class="line">        self.kvoController.observe(object, keyPath: keyPath, options:[.initial, .new], block:&#123;(observer: Any?, object: Any, change: [String: Any]) in</span><br><span class="line">            DispatchQueue.main.async(execute: &#123; () -&gt; Void in</span><br><span class="line">                block(observer, change[&quot;old&quot;], change[&quot;new&quot;]);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func observe(_ object: Any?, keyPath: String, options: NSKeyValueObservingOptions, mainThread: Bool, block: @escaping KVONotificationBlock) &#123;</span><br><span class="line">        self.kvoController.observe(object, keyPath: keyPath, options: options) &#123; (observer, object, change: [String: Any]) -&gt; Void in</span><br><span class="line">            if !mainThread || Thread.isMainThread == true  &#123;</span><br><span class="line">                block(observer, change[&quot;old&quot;], change[&quot;new&quot;]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                DispatchQueue.main.async(execute: &#123; () -&gt; Void in</span><br><span class="line">                    block(observer, change[&quot;old&quot;], change[&quot;new&quot;]);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func removeObserve(_ object: Any?, path: String) &#123;</span><br><span class="line">        self.kvoController.unobserve(object, keyPath: path);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func removeObserve(_ obj: Any?) &#123;</span><br><span class="line">        self.kvoController.unobserve(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func removeAll() &#123;</span><br><span class="line">        self.kvoController.unobserveAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h1><h2 id="使用的前提："><a href="#使用的前提：" class="headerlink" title="使用的前提："></a>使用的前提：</h2><p>&emsp;&emsp;使用<a href="https://github.com/cocoapods/cocoapods" target="_blank" rel="noopener">CocoaPods</a>，在我们的工程项目的Podfile文件添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;KVOController&apos;</span><br></pre></td></tr></table></figure></p><h2 id="kvoController是啥？"><a href="#kvoController是啥？" class="headerlink" title="kvoController是啥？"></a>kvoController是啥？</h2><p>&emsp;&emsp;<a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">FBKVOController</a>是Facebook开源的替代KVO的解决方案。它用block解决了以前使用KVO时代码散乱的缺点。</p><h2 id="为啥要用FBKVOController？"><a href="#为啥要用FBKVOController？" class="headerlink" title="为啥要用FBKVOController？"></a>为啥要用FBKVOController？</h2><p>&emsp;&emsp;kvo 全称 key-value observing，由 cocoa 框架提供的支持观察者模式的技术，结合 Objective-C 非常易用，在很多场合都可以有效地替换 NSNotificationCenter。但其也有一些致命的缺点，就是很容易导致引发 crash。譬如：只有addObserver，没有removeObserver。addObserver 和 removeObserver 必须配对出现，不然的话，等待你的就是crash。其调用的顺序：必须先添加观察者，然后处理业务，最后完成后移除观察者，释放掉观察者。removeObserver方法的调用，一般在dealloc()（OC）、deinit()（Swift）中。<br>&emsp;&emsp;而FBKVOController则是帮助我们更好的使用KVO。FBKVOController生命周期跟观察者绑定，则观察者释放时，由FBKVOController生成的实例也被释放，从 _FBKVOSharedController 移除对应的观察者信息，避免发消息给已释放观察者导致的crash。</p><h2 id="为啥要写这个扩展？"><a href="#为啥要写这个扩展？" class="headerlink" title="为啥要写这个扩展？"></a>为啥要写这个扩展？</h2><p>&emsp;&emsp;在controller中直接调用observe方法，传入对应的参数，在block回调中做该做的事情就可以。当然，也不需要手动移除监听。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">observe(scrollView, keyPath: #keyPath(UIScrollView.contentOffset)) &#123; [weak self] (weakSelf, oldValue, newValue) in</span><br><span class="line">    // 处理事情</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> kvo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - 底层解析weak的实现原理</title>
      <link href="//ios_weak-principle.html"/>
      <url>//ios_weak-principle.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;很少有人知道weak表其实是一个hash（哈希）表，key是所指对象的地址，value是weak指针的地址数组。大多数人只知道weak是弱引用，所引用对象的计数器不会加一，并在引用对象被释放的时候自动被置为nil。通常用于解决循环引用问题。但现在单知道这些已经不足以应对面试了，很多公司都会问weak的原理。weak的原理是什么？下面就分析一下weak的原理。<br><a id="more"></a></p><h1 id="weak-实现原理的概括"><a href="#weak-实现原理的概括" class="headerlink" title="weak 实现原理的概括"></a>weak 实现原理的概括</h1><p>&emsp;&emsp;runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，key是所指对象的地址，value是weak指针的地址（这个地址的值是所指对象指针的地址）数组。</p><h1 id="weak-的实现原理详细步骤"><a href="#weak-的实现原理详细步骤" class="headerlink" title="weak 的实现原理详细步骤"></a>weak 的实现原理详细步骤</h1><h2 id="一-、初始化"><a href="#一-、初始化" class="headerlink" title="(一)、初始化"></a>(一)、初始化</h2><p>&emsp;&emsp;初始化时，runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。<br>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">id __weak obj1 = obj;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在我们初始化一个weak变量时，runtime会调用NSObject.mm中的objc_initWeak函数，这个函数在Clang中的声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_initWeak(id *object, id value);</span><br></pre></td></tr></table></figure></p><p>而对于objc_initWeak()方法的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">id objc_initWeak(id *location, id newObj) &#123;</span><br><span class="line">// 查看对象实例是否有效</span><br><span class="line">// 无效对象直接导致指针释放</span><br><span class="line">    if (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 这里传递了三个 bool 数值</span><br><span class="line">    // 使用 template 进行常量参数传递是为了优化性能</span><br><span class="line">    return storeWeakfalse/*old*/, true/*new*/, true/*crash*/&gt;</span><br><span class="line">    (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以看出，这个函数仅仅是一个深层函数的调用入口，而一般的入口函数中，都会做一些简单的判断（例如objc_msgSend中的缓存判断），这里判断了其指针指向的类对象是否有效，无效直接释放，不再往深层调用函数。否则，object将被注册为一个指向value的<strong>weak对象。<br>&emsp;&emsp;注意：objc_initWeak函数有一个前提条件：就是object必须是一个没有被注册为</strong>weak对象的有效指针。而value则可以为空，或者指向一个有效的对象。</p><h2 id="二-、添加引用"><a href="#二-、添加引用" class="headerlink" title="(二)、添加引用"></a>(二)、添加引用</h2><p>&emsp;&emsp;添加引用时：objc_initWeak函数会调用objc_storeWeak()函数，objc_storeWeak()的作用是更新指针指向，创建对应的弱引用表。<br>objc_storeWeak的函数声明和具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_storeWeak(id *location, id value);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">// HaveOld:  true - 变量有值</span><br><span class="line">//          false - 需要被及时清理，当前值可能为 nil</span><br><span class="line">// HaveNew:  true - 需要被分配的新值，当前值可能为 nil</span><br><span class="line">//          false - 不需要分配新值</span><br><span class="line">// CrashIfDeallocating: true - 说明 newObj 已经释放或者 newObj 不支持弱引用，该过程需要暂停</span><br><span class="line">//          false - 用 nil 替代存储</span><br><span class="line">template bool HaveOld, bool HaveNew, bool CrashIfDeallocating&gt;</span><br><span class="line">static id storeWeak(id *location, objc_object *newObj) &#123;</span><br><span class="line">    // 该过程用来更新弱引用指针的指向</span><br><span class="line">    // 初始化 previouslyInitializedClass 指针</span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    // 声明两个 SideTable</span><br><span class="line">    // ① 新旧散列创建</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line">    // 获得新值和旧值的锁存位置（用地址作为唯一标示）</span><br><span class="line">    // 通过地址来建立索引标志，防止桶重复</span><br><span class="line">    // 下面指向的操作会改变旧值</span><br><span class="line">retry:</span><br><span class="line">    if (HaveOld) &#123;</span><br><span class="line">        // 更改指针，获得以 oldObj 为索引所存储的值地址</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (HaveNew) &#123;</span><br><span class="line">        // 更改新值指针，获得以 newObj 为索引所存储的值地址</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 加锁操作，防止多线程中竞争冲突</span><br><span class="line">    SideTable::lockTwoHaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">    // 避免线程冲突重处理</span><br><span class="line">    // location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改</span><br><span class="line">    if (HaveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line">    // 防止弱引用间死锁</span><br><span class="line">    // 并且通过 +initialize 初始化构造器保证所有弱引用的 isa 非空指向</span><br><span class="line">    if (HaveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        // 获得新对象的 isa 指针</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        // 判断 isa 非空且已经初始化</span><br><span class="line">        if (cls != previouslyInitializedClass  &amp;&amp;</span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">            // 对其 isa 指针进行初始化</span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (id)newObj));</span><br><span class="line">            // 如果该类已经完成执行 +initialize 方法是最理想情况</span><br><span class="line">            // 如果该类 +initialize 在线程中</span><br><span class="line">            // 例如 +initialize 正在调用 storeWeak 方法</span><br><span class="line">            // 需要手动对其增加保护策略，并设置 previouslyInitializedClass 指针进行标记</span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line">            // 重新尝试</span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ② 清除旧值</span><br><span class="line">    if (HaveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line">    // ③ 分配新值</span><br><span class="line">    if (HaveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table,</span><br><span class="line">                                                      (id)newObj, location,</span><br><span class="line">                                                      CrashIfDeallocating);</span><br><span class="line">        // 如果弱引用被释放 weak_register_no_lock 方法返回 nil</span><br><span class="line">        // 在引用计数表中设置若引用标记位</span><br><span class="line">        if (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            // 弱引用位初始化操作</span><br><span class="line">            // 引用计数那张散列表的weak引用对象的引用计数中标识为weak引用</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        // 之前不要设置 location 对象，这里需要更改指针指向</span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 没有新值，则无需更改</span><br><span class="line">    &#125;</span><br><span class="line">    SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">    return (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>撇开源码中各种锁操作，来看看这段代码都做了些什么：</p><ol><li>SideTable<br>&emsp;&emsp;SideTable这个结构体，引用计数和弱引用依赖表，主要用于管理对象的引用计数和weak表，在NSObject.m中声明其数据结构：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">// 保证原子操作的自旋锁</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    // 引用计数的 hash 表</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    // weak 引用全局 hash 表</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;对于slock和refcnts，第一个是为了防止竞争选择的自旋锁，第二个是协助对象的isa纸巾的extra_rc共同引用计数的变量。</p><ol start="2"><li>weak表<br>&emsp;&emsp;weak表是一个弱引用表，实现为一个weak_table_t结构体，存储了某个对象相关的所有的弱引用信息，其定义如下（objc_weak.h）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct weak_table_t &#123;</span><br><span class="line">    // 保存了所有指向指定对象的 weak 指针</span><br><span class="line">    weak_entry_t *weak_entries;</span><br><span class="line">    // 存储空间</span><br><span class="line">    size_t    num_entries;</span><br><span class="line">    // 参与判断引用计数辅助量</span><br><span class="line">    uintptr_t mask;</span><br><span class="line">    // hash key 最大偏移值</span><br><span class="line">    uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;这是一个全局弱引用hash表，使用不定类型对象的地址作为key，用weak_entry_t类型结构体对象作为value。其中的weak_entries成员，从字面意思看，即为弱引用表入口。<br>&emsp;&emsp;其中weak_entry_t是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用hash表。其定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef objc_object ** weak_referrer_t;</span><br><span class="line">struct weak_entry_t &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            weak_referrer_t *referrers;</span><br><span class="line">            uintptr_t        out_of_line : 1;</span><br><span class="line">            uintptr_t        num_refs : PTR_MINUS_1;</span><br><span class="line">            uintptr_t        mask;</span><br><span class="line">            uintptr_t        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        struct &#123;</span><br><span class="line">            // out_of_line=0 is LSB of one of these (don&apos;t care which)</span><br><span class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在weak_entry_t的结构体中，DisguisedPtrobjc_object&gt;是对泛型对象的指针做了一个封装，通过这个泛型类来解决内存泄漏的问题。从注释中，写out_of_line成员为最低有效位，当其为0的时候，weak_referrer_t成员将扩展为多行静态hash table。其实其中的weak_referrer_t是二维objc_object的别名，通过一个二维指针地址偏移，用下标作为hash的key，做成了一个弱引用散列。</p><ol start="3"><li><p>旧对象解除注册操作weak_unregister_no_lock<br>&emsp;&emsp;该方法主要作用是将旧对象在weak_table中解除weak指针的对应绑定。根据函数名，称之为解除注册操作。从源码中，可以知道其功能就是从weak_table中解除weak指针的绑定。而其中的遍历查询，就是针对于weak_entry中的多张弱引用散列表。</p></li><li><p>新对象添加注册操作weak_register_no_lock<br>&emsp;&emsp;这一步与上一步相反，通过weak_register_no_lock函数把新的对象进行注册操作，完成与对应的弱引用表进行绑定操作。</p></li><li><p>初始化弱引用对象流程一览<br>&emsp;&emsp;弱引用初始化，从上文的分析中可以看出，主要的操作部分就在弱引用表的取键、查询散列、创建弱引用表等操作，可以总结出如下的流程图：<br><img src="http://pic.cloverkim.com/749c46aagy1fxljq6knw6j20sg0sgwh5.jpg" alt=""></p></li></ol><h2 id="三-、释放"><a href="#三-、释放" class="headerlink" title="(三)、释放"></a>(三)、释放</h2><p>&emsp;&emsp;释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。<br>&emsp;&emsp;当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？当释放对象时，其基本流程如下：</p><ol><li>调用objc_release</li><li>因为对象的引用计数为0，所以执行dealloc函数</li><li>在dealloc中，调用了_objc_rootDealloc函数</li><li>在_objc_rootDealloc中，调用了object_disponse函数</li><li>调用objc_destructInstance</li><li>最后调用objc_clear_deallocating</li></ol><p>&emsp;&emsp;重点看对象被释放时调用的objc_clear_deallocation函数，该函数的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void  objc_clear_deallocating(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line">    assert(!UseGC);</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return;</span><br><span class="line">   obj-&gt;clearDeallocating();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;也就是调用了clearDeallocating函数，继续追踪可以发现，它最终是使用了迭代器来取weak表的value，调用weak_clear_no_lock，然后查找对应的value，将该weak指针置空，weak_clear_no_lock函数的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Called by dealloc; nils out all weak pointers that point to the</span><br><span class="line"> * provided object so that they can no longer be used.</span><br><span class="line"> *</span><br><span class="line"> * @param weak_table</span><br><span class="line"> * @param referent The object being deallocated.</span><br><span class="line"> */</span><br><span class="line">void weak_clear_no_lock(weak_table_t *weak_table, id referent_id)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    if (entry == nil) &#123;</span><br><span class="line">        /// XXX shouldn&apos;t happen, but does with mismatched CF/objc</span><br><span class="line">        //printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // zero out references</span><br><span class="line">    weak_referrer_t *referrers;</span><br><span class="line">    size_t count;</span><br><span class="line">    </span><br><span class="line">    if (entry-&gt;out_of_line) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (size_t i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        if (referrer) &#123;</span><br><span class="line">            if (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (*referrer) &#123;</span><br><span class="line">                _objc_inform(&quot;__weak variable at %p holds %p instead of %p. &quot;</span><br><span class="line">                             &quot;This is probably incorrect use of &quot;</span><br><span class="line">                             &quot;objc_storeWeak() and objc_loadWeak(). &quot;</span><br><span class="line">                             &quot;Break on objc_weak_error to debug.\n&quot;,</span><br><span class="line">                             referrer, (void*)*referrer, (void*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;objc_clear_deallocating函数的动作如下：</p><ol><li>从weak表中获取废弃对象的地址为键值得记录</li><li>将包含在 记录中的所有附有weak修饰符变量的地址，赋值为nil</li><li>将weak表中删除该记录</li><li>从引用计数表中删除废弃对象的地址为键值得记录</li></ol><p>&emsp;&emsp;看了objc_weak.mm的源码就明白了：其实weak表是一个hash（哈希）表，key是指向对象的地址，value是weak指针的地址数组。</p><h1 id="转载于"><a href="#转载于" class="headerlink" title="转载于"></a>转载于</h1><blockquote><p>标题：iOS 底层解析weak的实现原理（包含weak对象的初始化，引用，释放的分析）<br>作者：逍遥晨旭<br>链接：<a href="https://www.jianshu.com/p/13c4fb1cedea" target="_blank" rel="noopener">https://www.jianshu.com/p/13c4fb1cedea</a><br>來源：简书</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - +load 和 +initialize 方法</title>
      <link href="//method_load_initialize.html"/>
      <url>//method_load_initialize.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;Objective-C作为一门面向对象的开发语言，有类和对象的概念。编译后，类相关的数据结构会保留在目标文件中，在运行时得到解析和使用。在应用程序运行起来的时候，类的信息会有加载和初始化的过程。<br>&emsp;&emsp;就像Application有生命周期回调方法一样，在Objective-C的类被加载和初始化的时候，也可以收到方法回到，可以在适当的情况下做一些定制处理。而这正是load和initialize方法可以帮我们做到的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load;</span><br><span class="line">+ (void)initialize;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>&emsp;&emsp;可以看到这两个方法都是以“+”开头的类方法，返回值为空。通常情况下，我们在开发过程中可能不必关注这两个方法。如果有需要定制，我们可以在自定义的NSObject子类中给出这两个方法的实现，这样在类的加载和初始化过程中，自定义的方法可以得到调用。</p><h1 id="load方法"><a href="#load方法" class="headerlink" title="+load方法"></a>+load方法</h1><p>&emsp;&emsp;顾名思义，+load方法是在这个文件被程序装载时调用。只要是在Compile Sources中出现的文件总是会被装载，这与这个类是否被用到无关，因此+load方法总在main函数之前调用。<br>&emsp;&emsp;下面是Apple文档的相关描述：</p><blockquote><p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.<br>Discussion<br>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.<br>The order of initialization is as follows:</p><ol><li>All initializers in any framework you link to.</li><li>All +load methods in your image.</li><li>All C++ static initializers and C/C++ <strong>attribute</strong>(constructor) functions in your image.</li><li>All initializers in frameworks that link to you.<br>In addition:</li><li>A class’s +load method is called after all of its superclasses’ +load methods.</li><li>A category +load method is called after the class’s own +load method.<br>In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</li></ol></blockquote><h2 id="load函数调用特点如下："><a href="#load函数调用特点如下：" class="headerlink" title="load函数调用特点如下："></a>load函数调用特点如下：</h2><p>&emsp;&emsp;当类被引用进项目的时候就会执行+load方法（在main函数开始执行之前），与这个类是否被用到无关，每个类的+load方法<strong>只会自动调用一次</strong>。由于+load方法是系统自动加载的，因此不需要调用父类的+load方法，否则父类的+load方法会执行多次。</p><ul><li>当父类和子类都实现+load方法时，父类的+load方法执行顺序要优先于子类。</li><li>当子类未实现+load方法时，不会调用父类的+load方法。</li><li>类中的+load方法执行顺序要优先于类别(Category)</li><li>当有多个类别(Category)都实现了+load方法，这几个+load方法都会执行，但执行的顺序不确定，其执行的顺序与类别在Compile Sources中出现的顺序一致。</li><li>当然当有多个不同的类的时候，每个类的+load方法执行的顺序与其在Compile Sources出现的顺序一致。</li></ul><h2 id="下面通过🌰来验证"><a href="#下面通过🌰来验证" class="headerlink" title="下面通过🌰来验证"></a>下面通过🌰来验证</h2><p>&emsp;&emsp;新建3个类：Animal继承NSObject，Cat和Dog均继承Animal，并且新建3个Animal的分类，分别命名为Animal (Category1)、Animal (Category2)、Animal (Category3)<br>在Animal、Cat、Animal (Category1)、Animal (Category2)、Animal (Category3)均实现+load方法，并且打印对应的信息（Dog类除外）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下图所示：<br><img src="http://pic.cloverkim.com/load.jpg" alt="" title="+load"></p><p>由上图的运行结果可知：</p><ul><li>首先执行的父类Animal的load方法，再执行子类Cat的load方法，说明父类的load方法执行顺序要优先于子类。</li><li>子类Dog中没有实现load方法，没有打印对应的信息，说明子类没有实现load方法时，并不会调用父类的load方法。</li><li>然后执行的是3个分类的load方法，并且没有顺序，说明分类中的load方法的执行要晚于类的load方法，在多个分类中，只要实现了load方法，都会执行，但执行的顺序不确定。</li><li>最后执行的是main函数，说明在没有对类进行任何操作的情况下，load方法会被默认执行，并且是在main函数之前。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>&emsp;&emsp;从上面的分析中，main函数是整个应用程序的入口，而+load方法是在main函数之前执行的，并且只执行一次，所以使用时需要注意。</p><ul><li>不要做耗时操作<br>&emsp;&emsp;因为在执行main函数之前，所有实现的load方法执行完才会启动应用，因此在load方法中执行耗时操作时，必然会影响程序的启动时间。</li><li>不要做对象的初始化操作<br>&emsp;&emsp;因为在main函数之前自动调用，load方法调用的时候使用者根本就不能确定自己要使用的对象是否已经加载进来了，所以千万不能再这里初始化对象。</li><li>常用场景是在load方法中实现Method Swizzle<br>&emsp;&emsp;Method Swizzing是发生在运行时，主要用户在运行时将两个Method进行交换。</li></ul><h1 id="initialize方法"><a href="#initialize方法" class="headerlink" title="+initialize方法"></a>+initialize方法</h1><p>&emsp;&emsp;下面是Apple文档的相关描述：</p><blockquote><p>Initializes the class before it receives its first message.<br>Discussion<br>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.</p></blockquote><blockquote><p>The runtime sends the initialize message to classes in a thread-safe manner. That is, initialize is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until initialize completes.<br>…</p></blockquote><h2 id="initialize函数调用特点如下："><a href="#initialize函数调用特点如下：" class="headerlink" title="initialize函数调用特点如下："></a>initialize函数调用特点如下：</h2><p>&emsp;&emsp;initialize在类或者其子类的第一个方法被调用前调用。即使类文件被引用进项目，但是没有使用，initialize不会被调用。由于是系统自动调用，也不需要再调用[super initialize]，否则父类的initialize方法会被多次执行。</p><ul><li>父类的initialize方法会比子类先执行</li><li>当子类未实现initialize方法时，会调用父类的initialize方法。</li><li>当有多个Category都实现了initialize方法，会覆盖类中的方法，只执行一个（会执行Compile Sources列表中最后一个Category的initialize方法）</li></ul><h2 id="下面通过🌰来验证-1"><a href="#下面通过🌰来验证-1" class="headerlink" title="下面通过🌰来验证"></a>下面通过🌰来验证</h2><p>&emsp;&emsp;依旧使用上面创建的3个类：Animal、Cat和Dog。<br>我们在Animal类中实现+initialize方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下图所示：<br><img src="http://pic.cloverkim.com/749c46aagy1fwgtelwx4zj20fu02jaab.jpg" alt=""><br>由运行结果发现，Animal类的+initialie方法被调用了2次，这是因为在创建子类对象时，首先要创建父类对象，所以会调用一次父类的initialize方法，然后创建子类时，尽管该类没有实现initialize方法，但还是会调用父类的方法。虽然initialize方法对一个类而言会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求。正确使用initialize方法的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">    if (self == [Animal class]) &#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加上判断后，就不会因为子类而调用到自己的initialize方法了。</p><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p>&emsp;&emsp;initialize方法主要用来对一些不方便在编译期初始化的对象进行赋值。比如NSMutableArray这种类型的实例化依赖于Runtime的消息发送，所以无法再编译期初始化。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>load和initialize方法都会在实例化对象之前调用，以main函数为分水岭。load方法是在main函数之前调用，而initi方法是在main函数之后调用。这两个方法都会被自动调用，无需手动调用。</li><li>load和initialize方法都不用调用父类的方法，即使子类没有initialize方法也会调用父类的方法，而load方法则不会调用父类的load方法。</li><li>load方法通常用来进行Method Swizzle，initialize方法一般用于初始化全局变量或静态变量。</li><li>load和initialize方法内部都使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>悠然自得的隐居生活 —— 喜撰法师</title>
      <link href="//hege-08.html"/>
      <url>//hege-08.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>わが庵は&emsp;都のたつみ&emsp;しかぞ住む<br>世をうぢ山と&emsp;人はいふなり</p></blockquote><blockquote><p>我住皇都外，东南结草庵。<br>幽深人不解，反谓忧愁山。</p></blockquote><a id="more"></a><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>&emsp;&emsp;喜撰法师（生卒年不详）：平安初期歌人，六歌仙之一。只有这一首和歌能够确定是他的作品。据说他是「山城国」（今京都府东南部）人，出家后，先是在醍醐山修行，然后到宇治山上隐居。据传说他化为仙人，驾云而去。</p><h1 id="鉴赏"><a href="#鉴赏" class="headerlink" title="鉴赏"></a>鉴赏</h1><p>&emsp;&emsp;由于作者隐居在京都东南方的宇治山上，后人便将此山叫做喜撰岳。日文中，「宇治」与「憂し」（忧愁）发音相似，作者就巧妙地运用谐音的手法作成此歌，显示出自己超越于红尘的隐士风骨。人们谈起宇治山，就容易联想到忧愁这个字眼。以为这里终年愁云惨淡，哭风怨雨。其实宇治山幽深静谧，满山翠绿，正是理想的隐居之地。闲看行云，静听松风，真乃仙境也。<br>&emsp;&emsp;『源氏物语』中的「宇治十帖」是一个凄婉悲哀的爱情故事。当时读过它的人们一提起宇治，心中就会涌起一股无名的忧伤。今天宇治成了盛产有名的日本茶「宇治玉露」的茶乡。<br>&emsp;&emsp;此歌属于「隐者文学」。已故的广岛大学铃木修次教授说：“日本文学的真正传统主要在宫廷女官、法师、隐士和市民等人之中承袭。这些人都不大关心政治，从政治上来说多数是局外人。日本文学的核心是政治局外人的文学家的游戏精神所支撑的，这是日本文学引人注目的一个现象。”</p><p><img src="http://pic.cloverkim.com/宇治山.jpg" alt="" title="宇治山"></p><blockquote><p>远离皇都，<br>我结庐在东南。<br>宇治山别有洞天，<br>世人不知道这里的幽寂，<br>反说它愁云惨淡。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小仓百人一首 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 和歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>红颜易老的人生悲叹 —— 小野小町</title>
      <link href="//hege-09.html"/>
      <url>//hege-09.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>花の色は&emsp;移りにけりな&emsp;いたづらに<br>わが身世にふる&emsp;ながめせし間に</p></blockquote><blockquote><p>忧思逢苦雨，人世叹徒然。<br>春色无暇赏，奈何花已残。</p></blockquote><a id="more"></a><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>&emsp;&emsp;小野小町（生卒年不详）：平安初期有代表性的女歌人，六歌仙之一，「出羽国」（金秋田县）郡司小野良实（おののよしざね）之女，也有人说她是平安初期的汉诗人、歌人小野篁（第11首和歌作者）的孙女。据说她十分美貌，于是「······小町」便成了日语中美女的代名词。9世纪中叶，她曾在仁明天皇（にんみょうてんのう）、文德天皇（もんとくてんのう）两朝天皇宫中担任女官，一生传说很多。据说她晚年不遇，落魄流浪而死。她的作品洋溢着青春活力与燃烧的热情，『敕撰和歌集』中共收其作品62首。<br>&emsp;&emsp;相传，她殁于丹后半岛（今京都府大宫町）。那里的曹洞宗妙性寺中有她的塑像，寺院附近留有“小町冢”。据当地传说，古代“五十日村”的村民在旅途中遇见一位气质不凡的老年妇女，她自称是小野小町。当她听说村里火灾不断时，建议将村名改为“五十河村”，以河水镇住火灾（因为日语中的「日」与「火」同音）。村庄改名之后，火灾果然明显减少了。1995年，这里建起了“小町故里”的公园与博物馆。<br>&emsp;&emsp;在传说中，小野小町是一位专门为人治病、保佑平安分娩、擅长诵读佛经的老年妇女。妙性寺中的小町塑像，不是身着华丽的宫廷服装的女官，而是一位慈祥可亲的老尼。关于小野小町的传说，至今仍广为流传，据统计，全日本共有260余处流传着有关她的故事。<br>&emsp;&emsp;在京都、大阪、和歌山县等地保存下来的小野小町的塑像都不是美女，而是老妇人。这也正是日本民族“樱花易落，美女迟暮”的无常管的表现吧。</p><p><img src="http://pic.cloverkim.com/小野小町.jpg" alt="" title="小野小町"></p><h1 id="鉴赏"><a href="#鉴赏" class="headerlink" title="鉴赏"></a>鉴赏</h1><p>&emsp;&emsp;这首和歌既感伤樱花易谢，也喟然长叹自己青春难留，人生空幻。转眼之间，花褪残红，岁月蹉跎，年老色衰，怎么不叫人满腹愁肠。本歌中两次运用了和歌的「掛词」（谐音）技巧，「ふる」(降る·経る)，既写苦雨绵绵，又写人生蹉跎；「ながめ」（長雨·眺め），既写霪雨霏霏，又写茫然凝目。其中，「降る」是「長雨」的「緣語」（和歌技巧之一。由一个词让读者联想到另一个词而形成一种特殊的韵味）。另外，歌中的“人世”还有男女情爱的意思。<br>&emsp;&emsp;本歌语言简练，寓意丰富，历来受到高度评价。除被收入『古今和歌集』以外，还被选入『近代秀歌』、『詠歌大概』等歌集中。这首歌实际上概括了作者红颜薄命的一生。据传说，她死后，在原业平（第17首和歌作者）客宿于陆奥八十岛，夜半闻荒野上有咏歌声，其声音酷似小町。寻声而至，却只见草丛中一个骷髅，眼穴中已长出一株芒草来，在月光下摇曳…</p><blockquote><p>啊，樱花褪了残红，<br>人生恍然如梦。<br>岁月无情流逝，<br>凝视这满地落英，<br>更哪堪苦雨蒙蒙。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小仓百人一首 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 和歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>平静地旁观人世的悲欢离合 —— 蝉丸</title>
      <link href="//hege-10.html"/>
      <url>//hege-10.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>これやこの&emsp;行くも帰るも&emsp;別れては<br>知るも知らぬも&emsp;逢坂の関</p></blockquote><blockquote><p>远去与相送，离情此地同。<br>亲朋萍水客，逢坂关前逢。</p></blockquote><a id="more"></a><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>&emsp;&emsp;蝉丸（生卒年不详）：相传是居住在「逢坂関」附近的隐者，擅长和歌与琵琶。有人说他曾在宇多天皇（うだてんのう）的皇子敦实亲王（あつみしんのう）身边干过杂役，还有人说他是醍醐天皇（だいごてんのう）的第四皇子。其一生无从考证，充满了疑团。他晚年双目失明，成了琵琶法师，这一形象后来出现在「物语」、「谣曲」、「净琉璃」等作品中。<br>&emsp;&emsp;世阿弥（1363？- 1443。ぜあみ）的作品『蝉丸』中说，醍醐天皇的第四皇子蝉丸生来就是盲人，天皇感到十分生气，无情地让清贯（きよつら）将他带到荒山之中。清贯教导他说：“生为盲人是自己前世修行不够，是过去的孽障所致抛弃你是天皇希望你早日脱胎转世的慈悲之举。”蝉丸十分悲痛，怀抱琵琶，手执木杖，匍匐在地上哭泣不已。后来，他的姐姐怒发倒立，四处寻找他，最后凭借琵琶声在逢坂山找到了弟弟，姐弟二人相互诉说人生的不幸。此剧属于「谣曲」中的「狂女物」，比之更早的作品『今昔物语集』中，有博雅（ひろまさ）向蝉丸学习音乐，经过三年不断的努力，终于得到老师传授的秘曲『流泉』与『啄木』的故事。</p><h1 id="鉴赏"><a href="#鉴赏" class="headerlink" title="鉴赏"></a>鉴赏</h1><p>&emsp;&emsp;逢坂关位于「近江国」（今滋贺县）与「山城国」交界处的关隘，是从京都通往东海、东山、北陆等地的重要通道，这里自古商贾云集，旅客不绝。要踏上旅途的远行之人也好，送别亲朋好友之后返回京都的人也好，每天都在这里不断演出依依不舍的惜别场面。无论是久别的亲朋好友，还是素昧平生、萍水相逢的陌生人，都会在这里相逢。前者悲喜交集，后者无动于衷。作者以隐居世外的旁观者的眼光，冷静地目睹着人世间悲欢离合与偶然相逢的不可知的命运，在歌中流露出人世无常之感。逢坂关还是和歌中「逢う」（相逢）的「掛词」。『源氏物语』的第16卷「関屋」中，也有29岁的光源氏（ひかるげんじ）在参拜石山寺的路上，与12年前有过一夜情的「空蝉」在逢坂山偶然相逢，随后又马上分手的情节。空禅后来出家为尼，光源氏不禁感慨万千。<br>&emsp;&emsp;值得一提的是，日本的「闋所」（关口）与中国的“山海关”、“嘉峪关”、“玉门关”完全不同。岛国日本自古以来由于没有骑马民族的侵扰，没有长城，也没有中国式的敌楼、箭搂、烽火台等。日本古代的关口是木结构建筑，无法保留至今。在古代它是检查过往行人的关口，但也驻有军队，一有战事便可以变为军事要冲，成为保卫京师与领地的设施。到了中世，日本的关口主要成为领主收取税金与通行费的关口。江户时代，全国一共设置了50余处关口。<br>&emsp;&emsp;日本有名的关口还有「不破の関」（岐阜具）、「鈴鹿の関」（三重县）、「白河の関」（福岛县）、「箱根の関所」（神奈川县）等。到了「江户时代」，「东海道」上的「箱根の関所」成了拱卫江户时代的重要关口。经过这里要着重盘查武器与女人，即所谓的「人铁炮出女」。一是怕「大名」（地方藩主）将武器偷运到江户，而是怕作为人质而生活在江户的大名的正方妻子偷偷跑回自己丈夫的领地，使其能够举兵造反。</p><blockquote><p>远去的游子啊，<br>送行的亲人，<br>都感到别情难忍。<br>相识的人啊，陌生的人，<br>都相会在逢坂关的大门。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小仓百人一首 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 和歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - Swift数组去重</title>
      <link href="//iOS_filterDuplicates.html"/>
      <url>//iOS_filterDuplicates.html</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在开发过程中，也许会遇到需要对数组进行去重的相关处理。如果数组内只含有基础类型的数据时，你可以写两个for循环遍历，用下标取值做对比；当然也可以用集合Set（Swift），比较方便快捷，可以参照这篇文章：<a href="http://www.jianshu.com/p/dcae25a96f4c" target="_blank" rel="noopener">Swift 中超快捷去重方法(附集合Set的一点干货)</a>。<br>但如果需要对model数组进行去重，该怎么做呢？请往下看~<br><a id="more"></a></p><h1 id="Swift代码实现："><a href="#Swift代码实现：" class="headerlink" title="Swift代码实现："></a>Swift代码实现：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//: Playground - noun: a place where people can play</span><br><span class="line"></span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">extension Array &#123;</span><br><span class="line">    </span><br><span class="line">    // 去重</span><br><span class="line">    func filterDuplicates&lt;E: Equatable&gt;(_ filter: (Element) -&gt; E) -&gt; [Element] &#123;</span><br><span class="line">        var result = [Element]()</span><br><span class="line">        for value in self &#123;</span><br><span class="line">            let key = filter(value)</span><br><span class="line">            if !result.map(&#123;filter($0)&#125;).contains(key) &#123;</span><br><span class="line">                result.append(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DemoModel: CustomStringConvertible &#123;</span><br><span class="line">    </span><br><span class="line">    let name: String</span><br><span class="line"></span><br><span class="line">    init(_ name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var description: String &#123;</span><br><span class="line">        return name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arrays = [&quot;1&quot;, &quot;2&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;4&quot;]</span><br><span class="line">let filterArrays = arrays.filterDuplicates(&#123;$0&#125;)</span><br><span class="line">print(filterArrays)</span><br><span class="line"></span><br><span class="line">let modelArrays = [DemoModel(&quot;1&quot;), DemoModel(&quot;1&quot;), DemoModel(&quot;2&quot;), DemoModel(&quot;3&quot;)]</span><br><span class="line">let filterModels = modelArrays.filterDuplicates(&#123;$0.name&#125;)</span><br><span class="line">print(filterModels)</span><br></pre></td></tr></table></figure><h1 id="相关说明："><a href="#相关说明：" class="headerlink" title="相关说明："></a>相关说明：</h1><ul><li>上面的代码是一个playground，可以用Xcode创建一个playground，将以上代码粘贴到playground即可。playground用来写一些测试函数还是挺有用的。</li><li>filterDuplicates这个方法，这里直接写在Array的扩展里面，这样一个数组就可以随意调用这个方法了，相当的方便。</li><li>测试代码中，第一个是数组装的是String类型，可以直接用其值作为判断条件是否有重复值，是否需要去重。第二个是我们自定义的demoModel，有个name属性，那我们就可以用这个属性作为是否需要去重的判断，当然肯定不能直接根据一个类来判断。如果是开发中，model类肯定有很多的属性，如果要判断去重的话，需要一个不会有相同值的属性，比如iD什么的，来进行判断。</li><li><a href="https://developer.apple.com/reference/swift/customstringconvertible" target="_blank" rel="noopener">CustomStringConvertible</a>。是一个协议，实现这个协议，就可以用description来自定义print输出的内容。</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>日本和歌</title>
      <link href="//hege_introduce.html"/>
      <url>//hege_introduce.html</url>
      
        <content type="html"><![CDATA[<h1 id="初识和歌"><a href="#初识和歌" class="headerlink" title="初识和歌"></a>初识和歌</h1><p>&emsp;&emsp;相信大部分人是通过动漫 <a href="https://www.bilibili.com/bangumi/media/md616#detail" target="_blank" rel="noopener">《花牌情缘》</a> 才得知和歌，当然也可能是《名侦探柯南：唐红的恋歌》。刚开始看《花牌情缘》时，并没有对和歌产生多大的兴趣，随着剧情不断的推进，特别是当大江奏（小奏，歌牌社的一员，主角之一）出来时，我才发现，原来和歌也可以这么美。使我印象最深的几首：</p><blockquote><p>悠悠神代事，黯黯不曾闻。枫染龙田川，潺潺流水声。</p></blockquote><blockquote><p>伊吹艾草茂，无语苦相思。情笃心欲焚，问君知不知。</p></blockquote><blockquote><p>相思形色露，欲掩不从心。烦恼为谁故，偏招诘问人。</p></blockquote><blockquote><p>急流岩上碎，无奈两分离。早晚终相会，忧思情愈深。<br><a id="more"></a></p></blockquote><h1 id="和歌简介"><a href="#和歌简介" class="headerlink" title="和歌简介"></a>和歌简介</h1><p>&emsp;&emsp;和歌（わか waka）是日本的一种诗歌，由古代中国的乐府诗经过不断日本话发展而来。和歌包括长歌、短歌、片歌、连歌等。<br>&emsp;&emsp;随着时间的推移，作短歌的人愈来愈多，现已占绝大数。短歌有五句三十一个音节，是一种日本传统定型诗，格式为五-七-五-七-七的排列顺序。<br>&emsp;&emsp;日本最初的诗使用汉字写成，有用汉字的意，有的用汉字的音。在此基础上产生了具有日本特点的诗。因为日本叫大和民族，加之写了诗要吟唱，所以便称为和歌。<br>&emsp;&emsp;和歌是日本民族值得自豪的诗歌艺术，也是人类文化遗产中绚丽多彩的花朵。从朴素雄浑的《万叶集》、优美细腻的《古今和歌集》、梦幻浪漫的《新古今和歌集》，到今天浩如烟海、风格各异的现代短歌，构成了气象万千，五彩缤纷的和歌世界。</p><h1 id="和歌选集《小仓百人一首》"><a href="#和歌选集《小仓百人一首》" class="headerlink" title="和歌选集《小仓百人一首》"></a>和歌选集《小仓百人一首》</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;《小仓百人一首》是由藤原定家(1162 - 1241)于1235年选定的，这一年定家74岁。选歌的目的是为了装饰他的亲戚———豪族宇都宫入道莲生(1172 - 1259)，即赖纲新落成的“小仓山别墅”。<br>&emsp;&emsp;《小仓百人一首》中的100位作者每位只选其1首作品。其中男性作者79人，女性作者21人。从另外一个角度来看，天皇8人，僧侣13人，其余的作者都是贵族或者高官，而僧侣也都出身于贵族世家。从100位作者的构成来看，有两个特点：一是贵族高官多，二是女性多，特别是第二个特点，充分说明了日本文学史上被女性的空前活跃。这种现象在中国所有的古典汉诗选本中是从来没有过的。再从题材上来看，《恋歌》(情歌)最多，共43首，占全书的将近一半。其次是描写四季景色的作品，共32首，占三分之一，其中又以秋歌为多。<br>&emsp;&emsp;本来，贵族男女学习和歌的主要目的就是用于谈情说爱，男女相识、相思、离别，和歌都是必不可少的感情桥梁。另外，这也说明了选编者藤原定家对恋歌的重视。而这32首描写自然景色的作品，正好说明了和歌的另一大特色，即热爱自然，重视人与自然的交流与对话。</p><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p>&emsp;&emsp;别人推荐的最多的一本，莫过于刘德润《小仓百人一首:日本古典和歌赏析》了，这本是刘德润教授倾尽26年心血打造的一部日本古典和歌译作。书中100首和歌每首都有原歌、现代日语译文、词汇与语法、汉诗翻译、作者介绍、文学鉴赏、现代诗翻译。用书中的话说，让我们感受真正的日本古典和歌之美。<br><img src="http://pic.cloverkim.com/小仓百人一首.jpg" alt="" title="小仓百人一首"></p>]]></content>
      
      
      <categories>
          
          <category> 日本和歌 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 和歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - 删除连连支付libRsaCrypto.a中的base64.o</title>
      <link href="//iOS_delbase64.html"/>
      <url>//iOS_delbase64.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题的开始"><a href="#问题的开始" class="headerlink" title="问题的开始"></a>问题的开始</h1><p>&emsp;&emsp;之前项目需要集成连连支付，根据连连支付文档集成之后，发现编译报了如图1-1 所示的错误，即libRsaCrypto.a中的base64.o和其他库冲突了，在网上进行了搜索与一番尝试，比如在linking—&gt;other linker flags使用-force_load导入我们的libRsaCrypto.a，但还是无补于事。最后找到了一个比较简单粗暴的方法，既然libRsaCrypto.a中的base64.o和其他库冲突了，那就将其base64.o删除，前提是确定删除base64.o对原有的第三方库没有影响。<br><a id="more"></a><br><img src="http://pic.cloverkim.com/749c46aagy1fw2wubwxvij219g046768.jpg" alt="" title="1-1"></p><p> 附带介绍下－ObjC、－all_load、-force_load 3个参数的作用： </p><ul><li>-ObjC：加了这个参数后，链接器就会把静态库中所有的Objective-C类和分类都加载到最后的可执行文件中。</li><li>-all_load： 会让链接器把所有找到的目标文件都加载到可执行文件中，但是千万不要随便使用这个参数！假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到ld: duplicate symbol错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到-ObjC失效的情况下使用-force_load参数。</li><li>-force_load ：所做的事情跟-all_load其实是一样的，但是-force_load需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载。</li></ul><h1 id="开始删除libRsaCrypto-a中的base64-o"><a href="#开始删除libRsaCrypto-a中的base64-o" class="headerlink" title="开始删除libRsaCrypto.a中的base64.o"></a>开始删除libRsaCrypto.a中的base64.o</h1><h2 id="1、查看libRsaCrypto-a文件支持的cpu架构"><a href="#1、查看libRsaCrypto-a文件支持的cpu架构" class="headerlink" title="1、查看libRsaCrypto.a文件支持的cpu架构"></a>1、查看libRsaCrypto.a文件支持的cpu架构</h2><p>我们在终端中，先进入到.a文件所在的目录，然后输入相应的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -info libRsaCrypto.a</span><br></pre></td></tr></table></figure></p><p>输出结果如图2-1 所示：<br><img src="http://pic.cloverkim.com/749c46aagy1fw2wuc64t4j20uc03cdhm.jpg" alt="" title="2-1"></p><h2 id="2、根据上面的输出平台进行拆分-a文件"><a href="#2、根据上面的输出平台进行拆分-a文件" class="headerlink" title="2、根据上面的输出平台进行拆分.a文件"></a>2、根据上面的输出平台进行拆分.a文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lipo libRsaCrypto.a -thin armv7 -output 1/libRsaCrypto-armv7.a</span><br><span class="line">lipo libRsaCrypto.a -thin i386 -output 2/libRsaCrypto-i386.a </span><br><span class="line">lipo libRsaCrypto.a -thin x86_64 -output 3/libRsaCrypto-x86_64.a</span><br><span class="line">lipo libRsaCrypto.a -thin arm64 -output 4/libRsaCrypto-arm64.a</span><br></pre></td></tr></table></figure><p>这里需要注意的是：拆分后的.a文件在放在不同的文件夹下，这里我用当前目录下的文件夹1/2/3/4代替了。效果图如图2-2 所示：<br><img src="http://pic.cloverkim.com/749c46aagy1fw2wud4b2qj20my04ewer.jpg" alt="" title="2-2"></p><h2 id="3、解压每个拆分后的-a文件"><a href="#3、解压每个拆分后的-a文件" class="headerlink" title="3、解压每个拆分后的.a文件"></a>3、解压每个拆分后的.a文件</h2><p>注意在解压前，先进入拆分后.a对应的文件夹下，在解压的命令分别在不同的文件夹下执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ar -x libRsaCrypto-armv7.a</span><br><span class="line">ar -x libRsaCrypto-i386.a</span><br><span class="line">ar -x libRsaCrypto-x86_64.a</span><br><span class="line">ar -x libRsaCrypto-arm64.a</span><br></pre></td></tr></table></figure></p><p>解压完后，对应的文件效果如图2-3 所示：<br><img src="http://pic.cloverkim.com/749c46aagy1fw2wuc0afcj20bm0esab1.jpg" alt="" title="2-3"><br>解压后可以删除对应的.o文件，这里我们需要删除的是base64.o。注意：要在每个文件夹里把对应的文件全部删除。然后再将解压之前的.a文件进行删除，即libRsaCrypto-armv7.a、libRsaCrypto-i386.a、libRsaCrypto-x86_64.a、libRsaCrypto-arm64.a。这样做，是为了方便我们重新命名合并后的.a文件。</p><h2 id="4、合并解压后的-o文件"><a href="#4、合并解压后的-o文件" class="headerlink" title="4、合并解压后的.o文件"></a>4、合并解压后的.o文件</h2><p>分别进入对应的文件夹，对所有解压出来的.o文件进行合并。命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libtool -static -o libRsaCrypto-armv7.a *.o</span><br><span class="line">libtool -static -o libRsaCrypto-i386.a *.o</span><br><span class="line">libtool -static -o libRsaCrypto-x86_64.a *.o</span><br><span class="line">libtool -static -o libRsaCrypto-arm64.a *.o</span><br></pre></td></tr></table></figure></p><p>经过一番合并命令后，对应的文件夹会重新生成对应的.a文件。</p><h2 id="5、最后合并重新生成的-a文件"><a href="#5、最后合并重新生成的-a文件" class="headerlink" title="5、最后合并重新生成的.a文件"></a>5、最后合并重新生成的.a文件</h2><p>首先将每个文件夹下重新生成的.a文件拷贝到一个新的文件下。然后在终端键入合并命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -create -output libRsaCrypto.a libRsaCrypto-armv7.a libRsaCrypto-i386.a libRsaCrypto-x86_64.a libRsaCrypto-arm64.a</span><br></pre></td></tr></table></figure></p><p>到这一步，我们已经将libRsaCrypto.a里的base64.o进行了删除，并且重新合并生成了新的libRsaCrypto.a。<br>最后的最后，将重新合并生成的libRsaCrypto.a重新导入我们的项目中，尽情的 command + R 吧。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>当我们集成其他第三方库也遇到类似的冲突问题时，也可以用此方法，不过需要确认第三方库的.a文件并不依赖我们将要删除的.o文件！！！</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 第三方库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP协议详解</title>
      <link href="//http-protocol.html"/>
      <url>//http-protocol.html</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本–HTTP 1.1。<a id="more"></a><br>&emsp;&emsp;HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示（如文本先于图形）等。<br>&emsp;&emsp;HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型，而且HTTP是一个无状态的协议。</p><h1 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h1><ul><li>简单快速：客户向服务器请求服务时，只需传达请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户端与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户端的请求，并收到客户端的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大；另一方面，在服务器不需要先前信息时，它的应答就很快。</li><li>支持<a href="https://www.cnblogs.com/jingmin/p/6493216.html" target="_blank" rel="noopener">B/S及C/S模式</a></li></ul><h1 id="HTTP协议请求消息结构"><a href="#HTTP协议请求消息结构" class="headerlink" title="HTTP协议请求消息结构"></a>HTTP协议请求消息结构</h1><p>&emsp;&emsp;客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。<br><img src="http://pic.cloverkim.com/HTTP请求消息体结构.jpg" alt="" title="HTTP请求消息体结构"></p><p>&emsp;&emsp;HTTP消息体主要包含以下实质内容（空格和换行也必不可少）：</p><ul><li>请求方法</li><li>URL：统一资源定位符</li><li>HTTP请求头部</li><li>HTTP请求体</li></ul><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>&emsp;&emsp;HTTP包含了多种不同的请求方式，每一种请求方式用在不同的场景。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">GET</td><td style="text-align:center">请求指定的页面信息，并返回实体主体</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">HEAD</td><td style="text-align:center">类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">POST</td><td style="text-align:center">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的修改</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PUT</td><td style="text-align:center">从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">DELETE</td><td style="text-align:center">请求服务器删除指定的页面</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">CONNECT</td><td style="text-align:center">HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">OPTIONS</td><td style="text-align:center">允许客户端查看服务器的性能</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">TRACE</td><td style="text-align:center">回显服务器收到的请求，主要用于测试或诊断。</td></tr></tbody></table><h2 id="URL——统一资源定位符"><a href="#URL——统一资源定位符" class="headerlink" title="URL——统一资源定位符"></a>URL——统一资源定位符</h2><p>&emsp;&emsp;URL由三部分组成：资源类型、存放资源的主机域名、资源文件名。<br>&emsp;&emsp;URL的一般语法格式为（带方括号[]的为可选项）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protocol :// hostname[:port] / path / [;parameters][?query]#fragment</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;举个🌰：<a href="https://baijiahao.baidu.com/s?id=1603848351636567407&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1603848351636567407&amp;wfr=spider&amp;for=pc</a></p><ul><li>protocol：https</li><li>hostname：baijiahao.baidu.com</li><li>parameters：id=1603848351636567407&amp;wfr=spider&amp;for=pc （使用&amp;分割参数）</li></ul><p>&emsp;&emsp;总结如下图所示：<br><img src="http://pic.cloverkim.com/解析图.jpg" alt="" title="解析图"></p><h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><p>&emsp;&emsp;请求头中主要包含本次请求的附加信息，其中常用的字段如：</p><ul><li>Accept：指定客户端能够接收的内容类型</li><li>Accept-Encoding：指定浏览器可以支持的web服务器返回内容压缩编码类型</li><li>Accept-Language：浏览器可接受的语言</li><li>Content-Length：请求的内容的长度，如：Content-Lenght：348</li><li>Content-Type：请求的与实体对应的MIME信息，常用的类型如下：<ul><li>text/html：HTML格式</li><li>text/plain：纯文本格式</li><li>text/xml：XML格式</li><li>image/gif：gif图片格式</li><li>image/jpeg：jpg图片格式</li><li>image/png：png图片格式</li><li>application/xhtml+xml：XHTML格式</li><li>application/xml：XML数据格式</li><li>application/json：JSON数据格式</li><li>application/pdf：pdf格式</li><li>application/msword：word文档格式</li><li>application/octet-stream：二进制流数据</li></ul></li><li>Date请求发送的日期和时间</li><li>更多的请求头字段参考：<a href="http://tools.jb51.net/table/http_header" target="_blank" rel="noopener">HTTP响应头和请求头信息对照表</a></li></ul><h2 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h2><p>&emsp;&emsp;在整个报文中，请求头之后，隔一行空格，以下部分就是HTTP的请求体了。请求体是我们发送请求的时候需要传给接收端的内容。其格式需要和请求头中的<code>Content-Type</code>对应，不然会导致接受无法识别。</p><h1 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h1><p>&emsp;&emsp;HTTP的响应同样分为：响应行、响应头和响应体。和请求报文有点类似。</p><h2 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h2><p>&emsp;&emsp;响应行中包含了HTTP的版本和本次请求的状态，请求状态的对应值见下文或见<a href="https://blog.csdn.net/ddhsea/article/details/79405996" target="_blank" rel="noopener">HTTP响应码大全</a></p><h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><p>&emsp;&emsp;响应头用于描述服务器的基本信息、数据的描述，这些信息将告知客户端如何处理响应头中的内容。</p><ul><li>Allow 服务器支持哪些请求方法（如GET、POST等）。</li><li>Content-Encoding 文档的编码（Encode）方法。只有在解码之后才能得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即<code>request.getHeader(&quot;Accept-Encoding&quot;)</code>）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</li><li>Content-Lenght 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想利用持久连接的优势，可以把输出文档写入ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过<code>byteArrayStream.writeTo(response.getOutputStream())</code>发送内容。</li><li>Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。更多的请求头字段参考：<a href="http://tools.jb51.net/table/http_header" target="_blank" rel="noopener">HTTP响应头和请求头信息对照表</a></li></ul><h2 id="响应实体"><a href="#响应实体" class="headerlink" title="响应实体"></a>响应实体</h2><p>&emsp;&emsp;响应实体中包含的就是客户端从服务器中获取的数据了。数据的格式和长度都会在响应体中描述。</p><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p>&emsp;&emsp;HTTP的状态码由三位数字组成，第一个数字定义了响应的类别，共有5种类别：</p><ul><li>1xx：指示信息 — 表示请求已接收，继续处理</li><li>2xx：成功 — 表示请求已被成功接收、理解、接受</li><li>3xx：重定向 — 要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误 — 请求有语法错误或请求无法实现</li><li>5xx：服务器端错误 — 服务器未能实现合法的请求</li></ul><h2 id="常见的状态码："><a href="#常见的状态码：" class="headerlink" title="常见的状态码："></a>常见的状态码：</h2><ul><li>200 OK：客户端请求成功</li><li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized：请求未经授权，这个状态代码必须和<code>WWW-Authenticate</code>报头域一起使用</li><li>403 Forbidden：服务器收到请求，但是拒绝提供服务</li><li>404 Not Found：请求资源不存在，不如：输入了错误的URL</li><li>500 Internal Server Error：服务器发生不可预期的错误</li><li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</li><li>更多状态码见：<a href="https://blog.csdn.net/ddhsea/article/details/79405996" target="_blank" rel="noopener">HTTP响应码大全</a></li></ul><h1 id="GET-请求和POST-请求的区别"><a href="#GET-请求和POST-请求的区别" class="headerlink" title="GET 请求和POST 请求的区别"></a>GET 请求和POST 请求的区别</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>GET请求：请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分隔URL和传输数据，多个参数用&amp;进行连接；如果数据是英文字母/数组，原样发送，如果是空格，则转换为+，如果是中文/其他字符，则直接把字符串用base64进行加密。</li><li>POST请求：把提交的数据放置在是HTTP包的包体中。因此，GET请求的数据会在地址栏中显示出来；而POST请求，地址栏不会改变。</li></ul><h2 id="实际开发中传输大小存在的限制"><a href="#实际开发中传输大小存在的限制" class="headerlink" title="实际开发中传输大小存在的限制"></a>实际开发中传输大小存在的限制</h2><ul><li>GET：特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节（2K + 35）。对于其他浏览器，如FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。因此对于GET请求时，传输数据就会受到URL长度的限制。</li><li>POST：由于不是通过URL传值，理论上数据不受限制。但实际各个web服务器会规定对POST请求数据大小进行限制，Apache、IIS6都有各自的配置。</li></ul><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>&emsp;&emsp;POST的安全性要比GET的安全性高。比如：GET提交数据，用户名和密码将以明文的形式出现在URL上，因为①登录页面有可能被浏览器缓存；②其他人查看浏览器的历史记录；除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/acf4efd9ebce" target="_blank" rel="noopener">简书 - 他头上长犄角 - http协议详解</a></li><li><a href="https://www.cnblogs.com/wangning528/p/6388464.html" target="_blank" rel="noopener">博客园 - 不必、放弃 - http协议详解(超详细)</a></li><li><a href="https://www.jianshu.com/p/dac7b8bdb682" target="_blank" rel="noopener">简书 - BennyLoo - TCP/IP协议栈 —— IP、TCP、UDP、HTTP协议详解</a></li><li><a href="http://tools.jb51.net/table/http_header" target="_blank" rel="noopener">HTTP响应头和请求头信息对照表</a></li><li><a href="http://tools.jb51.net/table/http_status_code" target="_blank" rel="noopener">HTTP状态码对照表</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CocoaPods安装教程</title>
      <link href="//install_cocoapods.html"/>
      <url>//install_cocoapods.html</url>
      
        <content type="html"><![CDATA[<h1 id="CocoaPods介绍"><a href="#CocoaPods介绍" class="headerlink" title="CocoaPods介绍"></a>CocoaPods介绍</h1><p>&emsp;&emsp;我们在iOS开发中不可避免的要使用第三方开源库，而CocoaPods的作用就是使我们方便管理应用中的第三方开源库。CocoaPods的项目源码在<a href="https://github.com/CocoaPods/Specs" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs</a>上管理。<br><a id="more"></a></p><h1 id="为什么要使用CocoaPods"><a href="#为什么要使用CocoaPods" class="headerlink" title="为什么要使用CocoaPods"></a>为什么要使用CocoaPods</h1><p>&emsp;&emsp;在使用CocoaPods之前，我们需要把用到的第三方开源库的源代码复制到项目中，而这些开源库通常需要依赖系统的一些framework，我们需要手动的将这些framework逐一的添加到项目依赖中，同时我们也要管理这些依赖包的更新。这些操作虽然简单但毫无技术含量而且浪费时间。在使用CocoaPods之后，我们只需要把用到的第三方开源库放到一个名为podfile的文件中，然后执行pod install，CocoaPods会自动将这些第三方开源库的源码下载下来，并且为我们的项目配置好相应的系统依赖和编译参数。</p><h1 id="CocoaPods的安装"><a href="#CocoaPods的安装" class="headerlink" title="CocoaPods的安装"></a>CocoaPods的安装</h1><h2 id="替换ruby源"><a href="#替换ruby源" class="headerlink" title="替换ruby源"></a>替换ruby源</h2><p>CocoaPods是基于ruby ecosystem的，需要ruby环境，使用ruby的gem命令。如果有VPN，则无需替换原本的ruby源。默认的ruby源为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://rubygems.org/</span><br></pre></td></tr></table></figure></p><p>接下来替换为墙内可以访问的ruby-china的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1.移除掉原有的源</span><br><span class="line">gem sources --remove https://rubygems.org/</span><br><span class="line">// 2.淘宝的源已经不更新维护，现在使用ruby-china的源</span><br><span class="line">gem source -a https://gems.ruby-china.com/</span><br><span class="line">// 3.验证是否替换成功</span><br><span class="line">gem sources -l</span><br></pre></td></tr></table></figure></p><h2 id="更新gem版本"><a href="#更新gem版本" class="headerlink" title="更新gem版本"></a>更新gem版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem update --system</span><br></pre></td></tr></table></figure><p>更新完毕后，可以通过以下命令查看gem版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem -v</span><br></pre></td></tr></table></figure></p><h2 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h2><p>使用以下安装命令，安装最新版本的CocoaPods<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install -n /usr/local/bin cocoapods</span><br></pre></td></tr></table></figure></p><p>安装成功如下图所示：<br><img src="http://pic.cloverkim.com/749c46aagy1fw37mrk9l9j20i005njsj.jpg" alt=""><br>安装成功之后，可以使用命令pod –version查看是否安装成功，如果成功会显示pod的版本号信息。</p><h2 id="更新Podspec索引文件"><a href="#更新Podspec索引文件" class="headerlink" title="更新Podspec索引文件"></a>更新Podspec索引文件</h2><p>pod安装成功之后，第一个操作就是执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod setup</span><br></pre></td></tr></table></figure></p><p>pod setup的作用：将所有第三方的Podspec索引文件更新到本地的~/.cocoapods/repos目录下<br>第一次执行pod setup命令时，github的Podspec索引文件比较大，所以第一次更新会比较慢，需要耐心等耐完成…</p><ul><li>如果没有执行过pod setup，用户根目录下~找不到.cocoapods/repos目录，没有创建这个目录。</li><li>如果执行了pod setup，并且命令没有执行成功，那么会创建~/.cocoapods/repos目录，但该目录为空。</li><li>如果执行了pod setup，并且命令执行成功，说明已经把github上的Podspec文件更新到本地，那么会创建~/.cocoapods/repos目录，并且repos目录里会有一个master目录，这个master目录保存的就是github上所有第三方开源库的Podspec索引文件。<br>最后pod setup成功时，如下图所示：<br><img src="http://pic.cloverkim.com/749c46aagy1fw38vsef5sj20hw0afwgl.jpg" alt=""></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/jiankeufo/article/details/79362660" target="_blank" rel="noopener">https://blog.csdn.net/jiankeufo/article/details/79362660</a></li><li><a href="https://blog.csdn.net/sinat_30898863/article/details/51348057" target="_blank" rel="noopener">https://blog.csdn.net/sinat_30898863/article/details/51348057</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Mac </tag>
            
            <tag> CocoaPods </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法学习 - 插入排序</title>
      <link href="//insert_sort.html"/>
      <url>//insert_sort.html</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&emsp;&emsp;把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，知道所有的记录插入完为止，得到一个新的有序序列。</p><p>算法思路：</p><ol><li>设置监视哨r[0]，将待插入记录的值赋值给r[0]</li><li>设置开始查找的位置j</li><li>在数组中进行搜索，搜索中将j个记录后移，直到r[0]的值大于或等于r[j]的值为止。</li><li>将r[0]插入到r[j+1]的位置上。<a id="more"></a><img src="http://pic.cloverkim.com/749c46aagy1fw0m1eh8vjj20dw06xaaz.jpg" alt="" title="插入排序"> </li></ol><h1 id="Swift-实现"><a href="#Swift-实现" class="headerlink" title="Swift 实现"></a>Swift 实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func insert_sort(_ array: inout [Int]) &#123;</span><br><span class="line">    for i in 0..&lt;array.count &#123;</span><br><span class="line">        let key = array[i]</span><br><span class="line">        var j = i - 1</span><br><span class="line">        while j &gt;= 0 &#123;</span><br><span class="line">            if array[j] &gt; key &#123;</span><br><span class="line">                array[j + 1] = array[j]</span><br><span class="line">                array[j] = key</span><br><span class="line">            &#125;</span><br><span class="line">            j -= 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arrays: [Int] = [3, 6, 4, 2, 9, 8, 5]</span><br><span class="line">insert_sort(&amp;arrays)</span><br></pre></td></tr></table></figure><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><ul><li>在插入某个元素之前需要先确定该元素在有序数组中的位置，当数据量比较大的时候，这是一个很耗时的过程，可以采用二分查找法改进，称为“二分插入排序”。</li><li>另外一种是在二分插入排序的基础上进一步改进的排序，称为2-路插入排序。其目的是减少排序过程中移动记录的次数，但为此需要n个记录的辅助空间。</li></ul><h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><p>&emsp;&emsp;最好的情况是，序列已经是升序排列，在这种情况下，需要进行比较操作需n-1次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)/2。平均来说插入排序算法的时间复杂度为O(n^2 )。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 使用Jenkins持续集成</title>
      <link href="//ios-jenkins.html"/>
      <url>//ios-jenkins.html</url>
      
        <content type="html"><![CDATA[<h1 id="Jenkins-概述"><a href="#Jenkins-概述" class="headerlink" title="Jenkins 概述"></a>Jenkins 概述</h1><h2 id="Jenkins是什么？"><a href="#Jenkins是什么？" class="headerlink" title="Jenkins是什么？"></a>Jenkins是什么？</h2><p>&emsp;&emsp;<a href="https://jenkins.io/zh/" target="_blank" rel="noopener">Jenkins</a> 是一款流行的开源持续集成（Continuous Integration，简称CI）工具，广泛用于项目开发，具有自动化构建、测试和部署等功能。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle，当然也可以通过插件的方式安装Xcode构建工具。<br>&emsp;&emsp;CI是一种开发实践。实践应该包含3个基本模块，一个可以自动构建的过程，自动编译代码，可以自动分发，部署和测试。一个代码仓库，SVN或者Git。最后一个是一个持续集成的服务器。通过持续集成，可以让我们通过自动化等手段高频率地去获取产品反馈并响应反馈的过程。<a id="more"></a></p><p><img src="http://pic.cloverkim.com/Jenkins思维导图.png" alt="" title="Jenkins思维导图"></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>缩减开发周期，快速迭代版本<br>&emsp;&emsp;每个版本开始都会估算好开发周期，但是总会因为各种事情而延期。这其中包括了一些客观因素。由于产品线增多，迭代速度越来越快，给测试带来的压力也越来越大。如果测试都在开发完全开发完成之后再来测试，那就会影响很长一段时间。这时候由于集成晚就会严重拖慢项目节奏。如果能尽早的持续集成，尽快进入上图的12步骤的迭代环中，就可以尽早的暴露出问题，提早解决，尽量在规定时间内完成任务。</p></li><li><p>自动化流水线操作带来的高效<br>&emsp;&emsp;其实打包对于开发人员来说是一件很耗时，而且没有很大技术含量的工作。如果开发人员一多，相互改的代码冲突的几率就越大，加上没有产线管理机制，代码仓库的代码质量很难保证。团队里面会花一些时间来解决冲突，解决完了冲突还需要自己手动打包。这个时候如果证书又不对，又要耽误好长时间。这些时间其实可以用持续集成来节约起来的。一天两天看着不多，但是按照年的单位来计算，可以节约很多时间！</p></li><li><p>随时可部署<br>&emsp;&emsp;有了持续集成以后，我们可以以天为单位来打包，这种高频率的集成带来的最大的优点就是可以随时部署上线。这样就不会导致快要上线，到处是漏洞，到处是bug，手忙脚乱弄完以后还不能部署，严重影响上线时间。</p></li><li><p>极大程度避免低级错误</p></li></ul><h1 id="Jenkins-安装"><a href="#Jenkins-安装" class="headerlink" title="Jenkins 安装"></a>Jenkins 安装</h1><p>&emsp;&emsp;在安装Jenkins之前，要保证Mac已经安装好了Java环境，因为Jenkins的运行需要依赖于Java环境。</p><h2 id="pkg镜像安装"><a href="#pkg镜像安装" class="headerlink" title="pkg镜像安装"></a>pkg镜像安装</h2><p>&emsp;&emsp;pkg镜像包<a href="https://jenkins.io/zh/download/" target="_blank" rel="noopener">下载地址</a>，下载完安装，直接安装，一路下一步即可，比较简单。</p><h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><p>&emsp;&emsp;如果有不了解Homebrew的同学，可以先了解一下（<a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">Homebrew官网</a>）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 安装命令</span><br><span class="line">$ brew install jenkins</span><br><span class="line">/// 启动Jenkins</span><br><span class="line">$ jenkins</span><br></pre></td></tr></table></figure></p><h2 id="war包方式安装（推荐）"><a href="#war包方式安装（推荐）" class="headerlink" title="war包方式安装（推荐）"></a>war包方式安装（推荐）</h2><p>&emsp;&emsp;推荐使用war包的方式进行安装，可以指定端口号，方便端口号的管理使用。<a href="http://updates.jenkins-ci.org/download/war/" target="_blank" rel="noopener">war包下载地址</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用命令</span><br><span class="line">$ java -jar /Documents/jenkins.war –httpPort=8080</span><br></pre></td></tr></table></figure></p><h1 id="Jenkins配置"><a href="#Jenkins配置" class="headerlink" title="Jenkins配置"></a>Jenkins配置</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li><p>Unlock Jenkins<br>&emsp;&emsp;首次启动Jenkins，会要求对Jenkins进行解锁操作，在下图中显示的路径<code>Users/Shared/Jenkins/Home/secrets/initialAdminPassword</code>中存放着解锁需要的密码。我们可以直接在终端中使用<code>cat</code>命令就可获取到密码，直接粘贴，continue。<br>  <img src="http://pic.cloverkim.com/unlockjenkins.png" alt="" title="Unlock Jenkins"></p></li><li><p>Customize Jenkins<br>&emsp;&emsp;接下来是对Jenkins进行定制，有安装推荐的插件以及选择插件进行安装，这里选择安装的推荐插件即可。<br><img src="http://pic.cloverkim.com/customize-jenkins.png" alt="" title="Customize Jenkins"><br><img src="http://pic.cloverkim.com/plug-install.png" alt="" title="插件安装安装"></p></li><li><p>Create First Admin User<br>&emsp;&emsp;最后一步为，创建一个管理员用户。根据自己的信息新建一个用户即可。<br><img src="http://pic.cloverkim.com/create-admin.png" alt="" title="新建Admin用户"></p></li></ul><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><h3 id="常用插件介绍"><a href="#常用插件介绍" class="headerlink" title="常用插件介绍"></a>常用插件介绍</h3><ul><li>Xcode integration（该插件为构建者提供了构建xcode项目，调用agvtool和打包.ipa文件的工具）</li><li>GIT plugin</li><li>GitLab Plugin</li><li>GitLab Hook Plugin</li><li>Keychains and Provisioning Profiles Management（证书管理插件）</li><li>Branch API Plugin（多分支管理插件）</li><li>Build Name and Description Setter（构建名称和构建完成描述设置插件）</li><li>Build With Parameters（多参数构建设置）</li><li>description setter plugin（构建完成日志描述）</li><li>Dingding[钉钉] Plugin（钉钉通知推送插件）</li><li>fir-plugin（上传到fir.im必备插件）</li><li>Localization: Chinese (Simplified)（中文本地化插件）</li><li>Project Description Setter</li><li>Role-based Authorization Strategy（用户权限管理）</li><li>Version Number Plug-In（允许构件时修改项目版本号）</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>搜索安装<br>&emsp;&emsp;从Manage Jenkins - Manage Plugins，进入插件管理页面，在可选插件tab以及右上角的过滤中，搜索需要安装的插件，勾选对应的插件，然后直接点击下方的安装，等待安装完毕以及Jenkins重启完毕即可。<br><img src="http://pic.cloverkim.com/20200116155027.png" alt="" title="插件安装"></p></li><li><p>本地上传<br>&emsp;&emsp;依然是在插件管理页面， 在高级tab页中，在页面下方的上传插件进行上传下载的.hpi插件文件。剩下步骤同搜索安装。<br><img src="http://pic.cloverkim.com/20200116155447.png" alt="" title="本地上传"></p></li></ul><p>&emsp;&emsp;以下相关教程，均在以上插件已安装完成的条件下进行。</p><h2 id="keychain和证书上传配置"><a href="#keychain和证书上传配置" class="headerlink" title="keychain和证书上传配置"></a>keychain和证书上传配置</h2><p>&emsp;&emsp;要出现管理证书入口，要先安装证书管理插件（Keychains and Provisioning Profiles Management），然后从Manage Jenkins - Keychains and Provisioning Profiles Management入口中，进入证书管理页面，先配置Keychains。对于login.keychain文件，在/Users/管理员用户名/Library/keychains/ 目录下，但是由于系统的关系，当前的keychains名称为login.keychain-db，这里我们需要复制一份到另外一个目录下，将其修改为login.keychain即可继续上传。证书的代码签名身份，在“钥匙串”App的“我的证书”里面能获取到。<br><img src="http://pic.cloverkim.com/20200116162055.png" alt="" title="添加keychains"><br>&emsp;&emsp;接下来上传所需要的证书。在/Users/管理员用户名/Library/MobileDevice/Provisioning Profiles目录下，找到打包需要的证书，这里我只用到了ADHoc的证书，并将其复制到一个指定的目录中，这里我复制到了桌面的MobileDevice目录下。证书的上传同上一步keychain的上传。<br><img src="http://pic.cloverkim.com/20200116162936.png" alt="" title="上传证书"></p><p>&emsp;&emsp;如果是从开发者官网下载的证书，这里分享一个用终端的方式，获取证书对应的UUID，<a href="https://my.oschina.net/ioslighter/blog/494342" target="_blank" rel="noopener">命令行获取mobileprovision文件的UUID</a><br><img src="http://pic.cloverkim.com/20200116164456.png" alt="" title="获取证书UUID"></p><h1 id="创建项目、配置"><a href="#创建项目、配置" class="headerlink" title="创建项目、配置"></a>创建项目、配置</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>&emsp;&emsp;从首页的左侧菜单新建item中，进入项目新建页面，创建步骤，如下图所示。<br><img src="http://pic.cloverkim.com/20200116191327.png" alt="" title="创建步骤"></p><h2 id="General配置"><a href="#General配置" class="headerlink" title="General配置"></a>General配置</h2><p><img src="http://pic.cloverkim.com/20200116194838.png" alt="" title="General"><br>&emsp;&emsp;如上图所示，下列我们针对常用3项进行详细说明，分别为项目描述、抛弃旧的构建任务以及多参数构建配置。</p><ol><li><p>描述 - 填写项目的具体描述</p></li><li><p>抛弃旧的构建任务<br> &emsp;&emsp;分别有以下丢弃策略，这里我们一般用前面2种策略，保持构建的天数或者构建的最大个数。</p><ul><li>保持构建的天数</li><li>保持构建的最大个数</li><li>发布包保留天数</li><li>发布包最大保留#个构建</li></ul></li><li><p>This project is parameterized（多参数构建配置）<br>&emsp;&emsp;针对多参数构建，这里只对以下常用的配置进行说明，配置完成的结果如下图所示：</p><ul><li>Boolean Parameter（布尔值参数类型，比如用于是否为Jenkins打包，一些参数控制等）</li><li>Choice Parameter（选择参数，比如用户打包环境的选择）</li><li>Git Parameter（Git参数，用于Branch/Tag/Revision/Pull Request选择构建）</li><li>String Parameter（字符串类型参数，比如用于版本号以及build版本号的使用等）<br><img src="http://pic.cloverkim.com/20200116201036.png" alt="" title="多参数配置示例"><br><img src="http://pic.cloverkim.com/20200117094515.png" alt="" title="使用示例"></li></ul></li></ol><h2 id="源代码管理"><a href="#源代码管理" class="headerlink" title="源代码管理"></a>源代码管理</h2><p>&emsp;&emsp;因为基本是是用Git来管理代码，因此这里只介绍Git的方式。一般公司会搭建属于自己的gitlab仓库，这里的仓库URL就要到自己公司的代码仓库进行查看，凭据的用户名和密码就是自己登陆gitlab的用户名和密码。这里特别说明下，指定分支，不要用默认以及写死，这里要用到上面配置的多参数管理中的Git Parameter，用<code>$</code>来引用定义的name，比如<code>$BRANCH</code>，在构建时，选择对应的分支就会拉取对应的分支代码。<br><img src="http://pic.cloverkim.com/20200117100456.png" alt="" title="源代码管理"></p><h2 id="构建触发器"><a href="#构建触发器" class="headerlink" title="构建触发器"></a>构建触发器</h2><p>&emsp;&emsp;构建触发器主要是设置自动化测试的配置，触发器可自定义的地方很多，可以根据自己实际的项目进行配置，这里不做多说明和研究了。主要讲下下面的定时构建和轮询SCM。</p><ul><li>定时构建：不管是SVN或者Git中代码是否有提交，均执行定时化的构建任务。</li><li>轮询SCM：只要SVN或者Git中代码有更新，则执行构建任务，日程表的填写内容有个参数，从左到右的参数含义如下：<ul><li>分钟minute，取值0~59</li><li>小时hour，取值0~23</li><li>天day，取值1~31</li><li>月month，取值1~12</li><li>星期week，取值0~7（0和7都是表示星期日）</li></ul></li></ul><p>&emsp;&emsp;以上5个参数可选择性设定，不写死的参数用<code>*</code>代替参数之间用空格隔开，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;0 21 * * *&quot;表示每晚21点0分自动化构建一次</span><br><span class="line">&quot;0 * * * *&quot;表示每个小时的第0分钟执行一次构建</span><br><span class="line">&quot;H/5 * * * *&quot;每隔5分钟构建一次</span><br><span class="line">&quot;H H/2 * * *&quot;每两小时构建一次</span><br><span class="line">&quot;H H 30 * *&quot;每月30号构建一次</span><br><span class="line">&quot;H(0-29)/10 * * * *&quot;每个小时的前半个小时内的每10分钟</span><br><span class="line">&quot;0 8-17/2 * * 1-5&quot;周一到周五，8点~17点，两小时构建一次</span><br><span class="line">&quot;H H 1,15 1-11 *&quot;每月1号、15号各构建一次，除12月等</span><br></pre></td></tr></table></figure></p><p><img src="http://pic.cloverkim.com/20200117103025.png" alt="" title="构建触发器"></p><h2 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h2><p>&emsp;&emsp;在构建环境中，有很多配置项。但这里只针对以下几项常用项进行说明<code>Keychains and Code Signing Identities</code>、<code>Mobile Provisioning Profiles</code>、<code>Set jenkins user build variables</code>。</p><ul><li><p>Keychains and Code Signing Identities：keychains和签名身份，这里用的是之前在证书管理页面中进行配置的，这我们选择项目所对应的keychains和签名身份即可，示例是下图所示：<br><img src="http://pic.cloverkim.com/20200117105500.png" alt=""></p></li><li><p>Mobile Provisioning Profiles：证书文件，这里用到的也是在证书管理页面上传配置的，这里只需要选择对应的证书名称，其余项不需要手动配置，示例如下图所示：<br><img src="http://pic.cloverkim.com/20200117105704.png" alt=""></p></li><li><p>Set jenkins user build variables：设置jenkins用户构建变量，这个选项是需要安装“user build vars plugin”插件的，该选项的说明如下：<br><img src="http://pic.cloverkim.com/20200117110002.png" alt="" title="Set jenkins user build variables"></p></li></ul><h2 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h2><h3 id="使用脚本构建"><a href="#使用脚本构建" class="headerlink" title="使用脚本构建"></a>使用脚本构建</h3><h4 id="自动化打包命令xcodebuild-xcrun介绍"><a href="#自动化打包命令xcodebuild-xcrun介绍" class="headerlink" title="自动化打包命令xcodebuild + xcrun介绍"></a>自动化打包命令xcodebuild + xcrun介绍</h4><p>&emsp;&emsp;Xcode为开发者提供了一套构建打包的命令，为xcodebuild何xcrun命令。xcodebuild把指定的项目打包成.app文件，xcrun将制定的.app文件转换成对应的.ipa文件。</p><ul><li>xcodebuild - 相关文档如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">xcodebuild – build Xcode projects and workspaces</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">1. xcodebuild [-project name.xcodeproj] [[-target targetname] … | -alltargets] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …]</span><br><span class="line"></span><br><span class="line">2. xcodebuild [-project name.xcodeproj] -scheme schemename [[-destination destinationspecifier] …] [-destination-timeout value] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …]</span><br><span class="line"></span><br><span class="line">3. xcodebuild -workspace name.xcworkspace -scheme schemename [[-destination destinationspecifier] …] [-destination-timeout value] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …]</span><br><span class="line"></span><br><span class="line">4. xcodebuild -version [-sdk [sdkfullpath | sdkname]] [infoitem]</span><br><span class="line"></span><br><span class="line">5. xcodebuild -showsdks</span><br><span class="line"></span><br><span class="line">6. xcodebuild -showBuildSettings [-project name.xcodeproj | [-workspace name.xcworkspace -scheme schemename]]</span><br><span class="line"></span><br><span class="line">7. xcodebuild -list [-project name.xcodeproj | -workspace name.xcworkspace]</span><br><span class="line"></span><br><span class="line">8. xcodebuild -exportArchive -archivePath xcarchivepath -exportPath destinationpath -exportOptionsPlist path</span><br><span class="line"></span><br><span class="line">9. xcodebuild -exportLocalizations -project name.xcodeproj -localizationPath path [[-exportLanguage language] …]</span><br><span class="line"></span><br><span class="line">10. xcodebuild -importLocalizations -project name.xcodeproj -localizationPath path</span><br></pre></td></tr></table></figure><p>上面所罗列的10个命令中，最主要的是前3个，接下来说明一下参数：</p><ol><li><code>-project -workspace</code>：这两个对应的为项目的名字，如果有多个工程，在没有指定的情况下，则默认为第一个工程。</li><li><code>-target</code>：打包对应的targets，如果没有指定，则默认为第一个。</li><li><code>-configuration</code>：如果没有修改这个配置，默认为Debug和Release两种方式，没有指定则默认为Release方式。</li><li><code>-buildsetting=value ...</code>：使用此命令修改工程的配置。</li><li><code>-scheme</code>：指定打包的scheme。</li></ol><ul><li>xcrun<br>&emsp;&emsp;使用参数不多，使用方法也很简单，xcrun -sdk iphoneos -v PackageApplication + 上述一些参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">PackageApplication [-s signature] application [-o output_directory] [-verbose] [-plugin plugin] || -man || -help</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line">[-s signature]: certificate name to resign application before packaging</span><br><span class="line">[-o output_directory]: specify output filename</span><br><span class="line">[-plugin plugin]: specify an optional plugin</span><br><span class="line">-help: brief help message</span><br><span class="line">-man: full documentation</span><br><span class="line">-v[erbose]: provide details during operation</span><br></pre></td></tr></table></figure><ul><li>完整的构建脚本示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">## !/bin/sh</span><br><span class="line">## 项目名</span><br><span class="line">TARGET_NAME=Your target name</span><br><span class="line">## Scheme名</span><br><span class="line">SCHEME=Your scheme name</span><br><span class="line">##=======================</span><br><span class="line">## 编译类型</span><br><span class="line">BUILD_TYPE=$&#123;BUILD_TYPE&#125;</span><br><span class="line">## 当前目录</span><br><span class="line">SORCEPATH=$&#123;WORKSPACE&#125;</span><br><span class="line">## workspace名</span><br><span class="line">SPACE=$&#123;WORKSPACE&#125;/$&#123;TARGET_NAME&#125;.xcodeproj</span><br><span class="line">##xcarchive文件的存放路径</span><br><span class="line">ARCHIVEPATH=$SORCEPATH/build/$SCHEME.xcarchive</span><br><span class="line">## ipa文件的存放路径</span><br><span class="line">EXPORTPATH=$SORCEPATH/build/$SCHEME</span><br><span class="line">## ExportOptions.plist文件的存放路径，该文件要存放在这个路径下内容如下</span><br><span class="line">EXPORTOPTIONSPLIST=$SORCEPATH/build/ExportOptions.plist</span><br><span class="line">## 导出后的ipa路径</span><br><span class="line">EXPORTPATHIPA=$SORCEPATH/build/$SCHEME/$SCHEME.ipa</span><br><span class="line"></span><br><span class="line">echo -e &quot;============First Build Clean============&quot;</span><br><span class="line">## 清理缓存</span><br><span class="line">## 如果工程使用的是cocoapods，则&apos;-project %s.xcodeproj&apos;替换为&apos;-workspace %s.xcworkspace&apos;</span><br><span class="line">xcodebuild clean -project $SPACE -scheme $&#123;SCHEME&#125; -configuration $&#123;BUILD_TYPE&#125;</span><br><span class="line">echo -e &quot;============Build Clean============&quot;</span><br><span class="line">## 输出关键信息</span><br><span class="line">echo -e &quot;  TARGET_NAME    : $&#123;TARGET_NAME&#125;&quot;</span><br><span class="line">echo -e &quot;  BUILD_TYPE    : $&#123;BUILD_TYPE&#125;&quot;</span><br><span class="line">echo -e &quot;  SORCEPATH    : $&#123;SORCEPATH&#125;&quot;</span><br><span class="line">echo -e &quot;  ARCHIVEPATH    : $&#123;ARCHIVEPATH&#125;&quot;</span><br><span class="line">echo -e &quot;  EXPORTPATH    : $&#123;EXPORTPATH&#125;&quot;</span><br><span class="line">echo -e &quot;  EXPORTOPTIONSPLIST    : $&#123;EXPORTOPTIONSPLIST&#125;&quot;</span><br><span class="line">echo -e &quot;============Build Archive============&quot;</span><br><span class="line"></span><br><span class="line">## 导出archive包</span><br><span class="line">xcodebuild archive -project $&#123;SPACE&#125; -scheme $&#123;SCHEME&#125; -archivePath $ARCHIVEPATH</span><br><span class="line">echo -e &quot;============Build Archive Success============&quot;</span><br><span class="line"></span><br><span class="line">echo -e &quot;============Export IPA============&quot;</span><br><span class="line">## 导出IPA包</span><br><span class="line">xcodebuild -exportArchive -archivePath $ARCHIVEPATH -exportPath $&#123;EXPORTPATH&#125; -exportOptionsPlist $&#123;EXPORTOPTIONSPLIST&#125;</span><br><span class="line">echo -e &quot;============Export IPA SUCCESS============&quot;</span><br><span class="line"></span><br><span class="line">## 编译完成时间 20181030_0931</span><br><span class="line">BUILD_DATE=&quot;$(date +&apos;%Y%m%d_%H%M&apos;)&quot;</span><br><span class="line"></span><br><span class="line">## info.plist路径</span><br><span class="line">PROJECT_INFOPLIST_PATH=&quot;$&#123;SORCEPATH&#125;/$&#123;TARGET_NAME&#125;/Info.plist&quot;</span><br><span class="line">## 取版本号</span><br><span class="line">BUNDLESHORTVERSION=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;$&#123;PROJECT_INFOPLIST_PATH&#125;&quot;)</span><br><span class="line">## 取build值</span><br><span class="line">VERSION=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;$&#123;PROJECT_INFOPLIST_PATH&#125;&quot;)</span><br><span class="line">## ipa更名规则  项目名V版本_年月日_时分</span><br><span class="line">IPANAME=&quot;$&#123;TARGET_NAME&#125;V$&#123;BUNDLESHORTVERSION&#125;_$&#123;BUILD_DATE&#125;.ipa&quot;</span><br><span class="line">## 更名后ipa路径</span><br><span class="line">EXPORTPATHNEWIPA=$EXPORTPATH/$IPANAME</span><br><span class="line"></span><br><span class="line">echo -e &quot;============Export end :$&#123;BUILD_DATE&#125;============&quot;</span><br><span class="line">echo -e &quot;============IPA Old Name: $&#123;EXPORTPATHIPA&#125;============&quot;</span><br><span class="line">echo -e &quot;============IPA New Name: $&#123;EXPORTPATHNEWIPA&#125;============&quot;</span><br><span class="line"></span><br><span class="line">## IPA更名</span><br><span class="line">cp $EXPORTPATHIPA $EXPORTPATHNEWIPA</span><br><span class="line">echo -e &quot;============Create New Name Success============&quot;</span><br><span class="line">## 删除老IPA</span><br><span class="line">rm $EXPORTPATHIPA</span><br><span class="line">echo -e &quot;============Delete Old Name Success============&quot;</span><br></pre></td></tr></table></figure><h3 id="使用xcode插件构建"><a href="#使用xcode插件构建" class="headerlink" title="使用xcode插件构建"></a>使用xcode插件构建</h3><h4 id="General-build-settings（常规配置）"><a href="#General-build-settings（常规配置）" class="headerlink" title="General build settings（常规配置）"></a>General build settings（常规配置）</h4><p>常规的配置见下图所示，其他选项保持默认即可。<br><img src="http://pic.cloverkim.com/20200117175423.png" alt=""><br><img src="http://pic.cloverkim.com/20200117180315.png" alt=""></p><h4 id="Code-signing-amp-OS-X-keychain-options（keychain和签名证书管理）"><a href="#Code-signing-amp-OS-X-keychain-options（keychain和签名证书管理）" class="headerlink" title="Code signing &amp; OS X keychain options（keychain和签名证书管理）"></a>Code signing &amp; OS X keychain options（keychain和签名证书管理）</h4><p><img src="http://pic.cloverkim.com/20200117181507.png" alt=""></p><h4 id="Advanced-Xcode-build-options（构建高级选项）"><a href="#Advanced-Xcode-build-options（构建高级选项）" class="headerlink" title="Advanced Xcode build options（构建高级选项）"></a>Advanced Xcode build options（构建高级选项）</h4><p>&emsp;&emsp;构建的高级选项，主要设置支持cocoaPods的项目，需要配置workspace和项目目录以及项目文件，示例如下图所示：<br><img src="http://pic.cloverkim.com/20200117111050.png" alt="" title="构建高级选项"></p><h4 id="Versioning（构建版本管理）"><a href="#Versioning（构建版本管理）" class="headerlink" title="Versioning（构建版本管理）"></a>Versioning（构建版本管理）</h4><p>&emsp;&emsp;这里的版本控制，主要是为了在打包构建的时候，能手动输入版本号进行控制，从而更好的输出不同版本号的包进行测试，如下图所示，其中VERSION_NAME和BUILD_VERSION是在General中配置的多参数打包的String 参数，名称要一一对应。<br><img src="http://pic.cloverkim.com/20200117110536.png" alt="" title="版本控制"></p><h2 id="构建后的操作"><a href="#构建后的操作" class="headerlink" title="构建后的操作"></a>构建后的操作</h2><ul><li><p>输出构建完成信息 - Archive artifacts<br>&emsp;&emsp;增加一个构建后的操作步骤：Archive artifacts，<code>build/${BUILD_TYPE}-iphoneos/*.ipa</code>，这里用到的目录需要跟“General build settings”步骤中的Output directory输出目录进行对应，不然会匹配不到相对应的内容，如果需要输出所有构建结果，不用后面的通配符即可。如下图所示，虽然有报错，但是根据错误内容，是没任何问题的，保存即可。<br><img src="http://pic.cloverkim.com/20200117112049.png" alt="" title="Archive artifacts"></p></li><li><p>上传到fir.im/蒲公英</p><ul><li><p>fir.im，项目的配置如下图所示：<br><img src="http://pic.cloverkim.com/20200117114521.png" alt="" title="fir.im配置"></p></li><li><p>蒲公英：因为公司用到的是fir.im，所以暂时没有蒲公英的账号以及配置过程，详细的可以参考蒲公英官网的配置文档：<a href="https://www.pgyer.com/doc/view/jenkins_plugin" target="_blank" rel="noopener">使用 Jenkins 插件上传应用到蒲公英</a></p></li></ul></li><li><p>钉钉消息通知<br>&emsp;&emsp;配置钉钉消息通知，这里需要安装<code>Dingding[钉钉] Plugin</code>和<code>Dingding JSON Pusher Plugin</code>插件。示例如下图所示：<br><img src="http://pic.cloverkim.com/20200117113608.png" alt="" title="钉钉消息通知"><br>&emsp;&emsp;关于钉钉access token的字段，这里分享<a href="https://ding-doc.dingtalk.com/doc#/serverapi2/qf2nxq" target="_blank" rel="noopener">如何创建一个钉钉机器人</a>，添加完成后，将Webhook链接里的额access_token复制到Jenkins里即可。</p></li></ul><h1 id="用户权限管理"><a href="#用户权限管理" class="headerlink" title="用户权限管理"></a>用户权限管理</h1><p>&emsp;&emsp;Jenkins默认的权限管理并没有用户组的概念，但在实际工作中经常需要针对不同的用户组赋予不同的权限，通常需要第三方插件（<code>Role-based Authorization Strategy</code>）的支持来解决这个问题。</p><h2 id="设置授权策略"><a href="#设置授权策略" class="headerlink" title="设置授权策略"></a>设置授权策略</h2><p>&emsp;&emsp;安装完<code>Role-based Authorization Strategy</code>插件之后，进入<code>系统管理 - Configure Global Security</code>，授权策略会多出一个<code>Role-Based Strategy</code>选项，选择此项，其他设置如下图所示：<br><img src="http://pic.cloverkim.com/20200117193736.png" alt="" title="Configure Global Security"></p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>&emsp;&esmp;从<code>系统管理 - 管理用户 - 新建用户</code>中，创建用户，这里新建3个测试用户：<br><img src="http://pic.cloverkim.com/20200117194347.png" alt="" title="新建用户"></p><h2 id="管理和分配角色"><a href="#管理和分配角色" class="headerlink" title="管理和分配角色"></a>管理和分配角色</h2><p>&emsp;&emsp;当启用了角色授权策略后，默认只有admin用户拥有系统配置和项目的所有权限，其他用户需要添加角色和权限才可以，不然会没有任何权限。从<code>系统管理 - Manage and Assign Roles</code>进入管理和分配角色页面。</p><h3 id="Manager-Roles-管理角色"><a href="#Manager-Roles-管理角色" class="headerlink" title="Manager Roles 管理角色"></a>Manager Roles 管理角色</h3><p>&emsp;&emsp;对角色进行增加删除、权限设置，这里可以创建全局角色和项目角色，并分配不同的权限。</p><h4 id="全局角色、项目角色"><a href="#全局角色、项目角色" class="headerlink" title="全局角色、项目角色"></a>全局角色、项目角色</h4><ul><li><p>全局角色：默认情况下，全局角色中只有一个admin角色，拥有所有权限。通过<code>Role to add</code>添加自定义的全局角色，并通过矩阵选择的方式添加权限。这里添加两个全局角色，如下图所示，其中，global_test角色拥有读取Jenkins配置的权限、项目的增删改查等所有权限。others角色只有读取Jenkins配置的权限。<br><img src="http://pic.cloverkim.com/20200117195942.png" alt="" title="新增全局角色"></p></li><li><p>项目角色：配置项目角色的步骤跟全局角色类似，但是要设置pattern，用于匹配指定类型的项目，支持正则表达式。在这里，创建了如图所示的两个项目角色。<br>其中，web角色使用<code>web.*</code>匹配以web开头的项目，sample角色使用<code>sample.*</code>匹配以sample开头的项目。<br><img src="http://pic.cloverkim.com/20200117200215.png" alt="" title="新增项目角色"></p></li></ul><h4 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h4><ul><li>两者都需要通过<code>Role to add</code>添加角色。</li><li>两者的角色都是通过勾选对应的全选矩阵来设置不同的角色权限。</li><li>全局角色既可以设置管理Jenkins的配置，也可以设置管理项目，项目角色只能设置管理项目，没有管理Jenkins的权限配置。</li><li>添加项目角色时，要通过pattern设置角色可以匹配的项目名称，pattern支持正则表达式。<ul><li>如<code>Roger-.*</code>表示所有以<code>Roger-</code>开头的项目，区分大小写。</li><li><code>(?i)roger-.*</code>表示以<code>roger-</code>开头的项目，不区分大小写。</li><li><code>ABC|ABC.*</code>表示<code>ABC</code>或者以<code>ABC</code>开头的项目。</li><li><code>abc|bcd|efg</code>表示直接匹配多个项目。</li></ul></li></ul><h4 id="各种权限说明"><a href="#各种权限说明" class="headerlink" title="各种权限说明"></a>各种权限说明</h4><p>&emsp;&emsp;权限说明如下表所示，这里对部分不常用的权限进行了缩减。</p><table><thead><tr><th style="text-align:center">Overall</th><th style="text-align:center"></th><th style="text-align:center">Credentials（凭据）</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">Job（任务）</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center">View（视图）</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">Administer</td><td style="text-align:center">Read</td><td style="text-align:center">Create</td><td style="text-align:center">Delete</td><td style="text-align:center">ManageDomains</td><td style="text-align:center">Update</td><td style="text-align:center">View</td><td style="text-align:center">Build</td><td style="text-align:center">Cancel</td><td style="text-align:center">Configure</td><td style="text-align:center">Create</td><td style="text-align:center">Delete</td><td style="text-align:center">Discover</td><td style="text-align:center">Move</td><td style="text-align:center">Read</td><td style="text-align:center">Workspace</td><td style="text-align:center">Configure</td><td style="text-align:center">Create</td><td style="text-align:center">Delete</td><td style="text-align:center">Read</td></tr><tr><td style="text-align:center">管理员</td><td style="text-align:center">可读</td><td style="text-align:center">新增</td><td style="text-align:center">删除</td><td style="text-align:center">管理域</td><td style="text-align:center">更新</td><td style="text-align:center">查看</td><td style="text-align:center">构建</td><td style="text-align:center">取消</td><td style="text-align:center">配置</td><td style="text-align:center">创建</td><td style="text-align:center">删除</td><td style="text-align:center">重定向</td><td style="text-align:center">移动</td><td style="text-align:center">可读</td><td style="text-align:center">查看工作区</td><td style="text-align:center">配置</td><td style="text-align:center">创建</td><td style="text-align:center">删除</td><td style="text-align:center">可读</td></tr></tbody></table><p>&emsp;&emsp;其中有一些比较特别的权限：</p><ul><li>最大的权限是Overall的Administer，拥有该权限可以对Jenkins进行任何操作。</li><li>最基本的权限是Overall的Read，用户必须赋予可读的权限。</li><li>给用户赋予权限时，Overall的Read和Job的Read权限要同时选中，不然该用户无权限访问该Job。</li><li>其他都是一些基本的权限，根据实际情况进行选择。</li></ul><h3 id="Assign-Roles-分配角色（对已经创建的角色分配具体的用户）"><a href="#Assign-Roles-分配角色（对已经创建的角色分配具体的用户）" class="headerlink" title="Assign Roles 分配角色（对已经创建的角色分配具体的用户）"></a>Assign Roles 分配角色（对已经创建的角色分配具体的用户）</h3><p>&emsp;&emsp;回到<code>Manage and Assign Roles</code>，进入<code>Assign roles</code>，在这里给全局角色和项目角色分配用户。如下图所示：这里分别对test1用户设置了admin的全局角色权限，对test2用户设置了global_test的全局角色权限，对test3用户设置了sample的项目角色权限。现在角色和用户已经配置完毕，可以使用不同的用户进行登录，查看不同的设置结果。<br>&emsp;&emsp;这里需要特别注意的地方，添加用户的时候，必须是之前已经创建好的用户。<br><img src="http://pic.cloverkim.com/20200117203108.png" alt="" title="分配全局角色"><br><img src="http://pic.cloverkim.com/20200117203128.png" alt="" title="分配项目角色"></p><h1 id="完整的持续集成流程"><a href="#完整的持续集成流程" class="headerlink" title="完整的持续集成流程"></a>完整的持续集成流程</h1><p>&emsp;&emsp;经过上面的持续集成，完整持续集成的流程如下图所示：<br><img src="http://pic.cloverkim.com/20200117203554.png" alt="" title="完整持续集成"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/41ecb06ae95f/" target="_blank" rel="noopener">简书 - 一缕殇流化隐半边冰霜 - 手把手教你利用Jenkins持续集成iOS项目</a></li><li><a href="https://juejin.im/post/5dde3ecde51d45771465b5aa?utm_source=gold_browser_extension" target="_blank" rel="noopener">掘金 - 72行代码 - iOS 使用Jenkins持续集成(简称CI)</a></li><li><a href="https://blog.csdn.net/lijing742180/article/details/86552396" target="_blank" rel="noopener">CSDN - 媛测 - jenkins 用户权限管理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> 持续集成 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - Face ID &amp; Touch ID</title>
      <link href="//ios_faceid-touchid.html"/>
      <url>//ios_faceid-touchid.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;Touch ID指纹识别是iPhone 5s开始增加的一项重大功能，在实际的用途有：快捷登录、指纹支付等。Face ID面容识别是iPhone X开始增加的，与Touch ID类似，都是属于生物验证的范畴。在我们的App使用Face ID或Touch ID时，所使用的方法都是同样的，不得不感谢一下苹果对开发者的照顾。需要注意的是Touch ID需要iOS 8以上，Face ID需要iOS 11以上。<br><a id="more"></a></p><h1 id="Face-ID-amp-Touch-ID-API介绍"><a href="#Face-ID-amp-Touch-ID-API介绍" class="headerlink" title="Face ID &amp; Touch ID API介绍"></a>Face ID &amp; Touch ID API介绍</h1><p>官方API文档：<a href="https://developer.apple.com/documentation/localauthentication" target="_blank" rel="noopener">https://developer.apple.com/documentation/localauthentication</a></p><h2 id="两个主要方法："><a href="#两个主要方法：" class="headerlink" title="两个主要方法："></a>两个主要方法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func canEvaluatePolicy(_ policy: LAPolicy, error: NSErrorPointer) -&gt; Bool</span><br></pre></td></tr></table></figure><ol><li>作用：判断设备是否支持Touch ID / Face ID。</li><li>参数：</li></ol><ul><li>LAPolicy：验证方式，后面会介绍；</li><li>NSErrorPointer：这个参数不能传nil，我们需要用到此方法的error值进行下一步的判断。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func evaluatePolicy(_ policy: LAPolicy, localizedReason: String, reply: @escaping (Bool, Error?) -&gt; Void)</span><br></pre></td></tr></table></figure><ol><li>作用：调用系统授权，弹出Touch ID指纹识别框 / Face ID面容识别框。</li><li>参数：</li></ol><ul><li>LAPolicy：鉴定方式；</li><li>localizedReason：我们应用程序需要验证指纹/面容的原因，具体地方如下图所示。官方强调，这个参数为必须有值，且不能为空。不然App将会闪退，并提示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localizedReason parameter is mandatory and the call will throw NSInvalidArgumentException if nil or empty string is specified.</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://pic.cloverkim.com/749c46aagy1fx7mizkbgij20bd07pt9w.jpg" alt="" title="Touch ID"></p><p><img src="http://pic.cloverkim.com/749c46aagy1fx7miznpcsj209108ngm2.jpg" alt="" title="Face ID"></p><ul><li>reply：验证回调，包含是否验证通过的Bool值和错误信息。 我们在拿到验证结果后，进行判断并进行下一步的处理操作，成功跳转或者错误提示等。</li></ul><h2 id="LAPolicy-验证方式（两种）"><a href="#LAPolicy-验证方式（两种）" class="headerlink" title="LAPolicy 验证方式（两种）"></a>LAPolicy 验证方式（两种）</h2><ol><li><p>生物识别：.deviceOwnerAuthenticationWithBiometrics<br>&emsp;&emsp;Touch ID：首先弹出指纹识别的弹窗，当第一次指纹验证失败时，弹框会变成两个按钮：其中一个是“取消”，另一个按钮可以自定义标题和点击事件，自定义标题的变量为：localizedFallbackTitle；自定义点击事件，需要在错误回调中，拿到错误码为：kLAErrorUserFallback时，进行我们的点击事件即可。当3次指纹验证失败时，验证弹框会消失，此时还可以继续呼出验证弹框进行验证，若接下来的两次指纹识别都验证错误的话，Touch ID会锁住。<br>&emsp;&emsp;Face ID：当设备支持Face ID时，会调用Face ID的验证弹框，需要注意的是，面容识别是错误一次时，需要点击“再次尝试面容ID”按钮，才能继续验证，若第2次再次错误时，会弹出自定义标题按钮，和Touch ID的相同。5次识别错误后，Face ID也会被锁住。</p></li><li><p>生物识别 + 密码认证：.deviceOwnerAuthentication<br>&emsp;&emsp;Touch ID：如果3次识别错误后，则会弹出系统密码输入验证页面，需要输入设备的密码来解锁。如果此时取消，还有2次调用指纹识别进行验证，如果都失败的话，接下来每次调用识别，都是用系统密码进行验证。<br>&emsp;&emsp;Face ID：当连续5次验证错误，即5次需要输入密码时，Face ID会被锁住，无法使用，需要进行系统密码验证过后来能继续使用。</p></li></ol><h2 id="iOS-11-新增的属性LABiometryType"><a href="#iOS-11-新增的属性LABiometryType" class="headerlink" title="iOS 11 新增的属性LABiometryType"></a>iOS 11 新增的属性LABiometryType</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public enum LABiometryType : Int &#123;</span><br><span class="line"></span><br><span class="line">    /// 此设备不支持生物识别.</span><br><span class="line">    @available(iOS 11.2, *)</span><br><span class="line">    case none</span><br><span class="line"></span><br><span class="line">    /// The device does not support biometry.</span><br><span class="line">    @available(iOS, introduced: 11.0, deprecated: 11.2, renamed: &quot;LABiometryType.none&quot;)</span><br><span class="line">    public static var LABiometryNone: LABiometryType &#123; get &#125;</span><br><span class="line"></span><br><span class="line">    /// 此设备支持 Touch ID.</span><br><span class="line">    case touchID</span><br><span class="line"></span><br><span class="line">    /// 此设备支持 Face ID.</span><br><span class="line">    case faceID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该属性是用于判断当前设备支持的验证类型，我们可以拿到该属性判断支持Touch ID还是Face ID，从而自定义提示文字或者是localizedReason的文字。<br>&emsp;对于LABiometryType，苹果给出的一段注释需要特别注意：只有当调用了canEvaluatePolicy方法，返回是true并且没有错误的情况下才会设置该值，错误是指之前所说的NSErrorPointer，因此canEvaluatePolicy的第二个error参数不要设置为nil。在调用canEvaluatePolicy方法之前，或者调用后有error的情况下，该属性均无任何意义的值。<br>&emsp;因为是iOS 11新增的，因此在使用时，需要先判断当前的系统。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#available(iOS 11.0, *)</span><br></pre></td></tr></table></figure></p><h2 id="LAError"><a href="#LAError" class="headerlink" title="LAError"></a>LAError</h2><p>&emsp;&emsp;该错误是在canEvaluatePolicy方法失败时返回的一个错误，即传值进去的error，所有错误和相关说明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, LAError)</span><br><span class="line">&#123;</span><br><span class="line">    /// 身份验证不成功，因为用户无法提供有效的凭据</span><br><span class="line">    LAErrorAuthenticationFailed = kLAErrorAuthenticationFailed,</span><br><span class="line">    </span><br><span class="line">    /// 身份验证被用户取消 (e.g. 点击了取消按钮).</span><br><span class="line">    LAErrorUserCancel = kLAErrorUserCancel,</span><br><span class="line">    </span><br><span class="line">    /// 身份验证被取消了，因为用户点击了返回按钮 (输入密码).</span><br><span class="line">    LAErrorUserFallback = kLAErrorUserFallback,</span><br><span class="line">    </span><br><span class="line">    /// 身份验证被系统取消了 (e.g. 另外一个应用到了前台/当前应用退到了后台).</span><br><span class="line">    LAErrorSystemCancel = kLAErrorSystemCancel,</span><br><span class="line">    </span><br><span class="line">    /// 验证无法启动，因为设备没有设置密码.</span><br><span class="line">    LAErrorPasscodeNotSet = kLAErrorPasscodeNotSet,</span><br><span class="line"></span><br><span class="line">    /// 身份验证无法启动，因为Touch ID在该设备不可用.</span><br><span class="line">    LAErrorTouchIDNotAvailable NS_ENUM_DEPRECATED(10_10, 10_13, 8_0, 11_0, &quot;use LAErrorBiometryNotAvailable&quot;) = kLAErrorTouchIDNotAvailable,</span><br><span class="line"></span><br><span class="line">    /// 身份验证无法启动，因为Touch ID没有录入指纹.</span><br><span class="line">    LAErrorTouchIDNotEnrolled NS_ENUM_DEPRECATED(10_10, 10_13, 8_0, 11_0, &quot;use LAErrorBiometryNotEnrolled&quot;) = kLAErrorTouchIDNotEnrolled,</span><br><span class="line"></span><br><span class="line">    /// 身份验证不成功，因为有太多失败的Touch ID尝试</span><br><span class="line">    /// Touch ID现在是锁着的，解锁Touch ID必须使用密码, e.g. 调用</span><br><span class="line">    /// LAPolicyDeviceOwnerAuthenticationWithBiometrics 的时候，输入密码是必要条件.</span><br><span class="line">    LAErrorTouchIDLockout NS_ENUM_DEPRECATED(10_11, 10_13, 9_0, 11_0, &quot;use LAErrorBiometryLockout&quot;)</span><br><span class="line">        __WATCHOS_DEPRECATED(3.0, 4.0, &quot;use LAErrorBiometryLockout&quot;) __TVOS_DEPRECATED(10.0, 11.0, &quot;use LAErrorBiometryLockout&quot;) = kLAErrorTouchIDLockout,</span><br><span class="line"></span><br><span class="line">    /// 应用程序取消了身份验证 (e.g. 在进行身份验证时，调用了invalidate).</span><br><span class="line">    LAErrorAppCancel NS_ENUM_AVAILABLE(10_11, 9_0) = kLAErrorAppCancel,</span><br><span class="line"></span><br><span class="line">    /// LAContext 传递给这个调用时，已经失效.</span><br><span class="line">    LAErrorInvalidContext NS_ENUM_AVAILABLE(10_11, 9_0) = kLAErrorInvalidContext,</span><br><span class="line"></span><br><span class="line">    /// 身份验证无法启动，因为生物识别在当前设备上不可用.</span><br><span class="line">    LAErrorBiometryNotAvailable NS_ENUM_AVAILABLE(10_13, 11_0) __WATCHOS_AVAILABLE(4.0) __TVOS_AVAILABLE(11.0) = kLAErrorBiometryNotAvailable,</span><br><span class="line"></span><br><span class="line">    /// 身份验证无法启动，因为生物识别没有录入信息.</span><br><span class="line">    LAErrorBiometryNotEnrolled NS_ENUM_AVAILABLE(10_13, 11_0) __WATCHOS_AVAILABLE(4.0) __TVOS_AVAILABLE(11.0) = kLAErrorBiometryNotEnrolled,</span><br><span class="line"></span><br><span class="line">    /// 身份验证不成功，因为太多次的验证失败并且生物识别验证处理锁定状态，必须输入密码才能解锁.</span><br><span class="line">    LAErrorBiometryLockout NS_ENUM_AVAILABLE(10_13, 11_0) __WATCHOS_AVAILABLE(4.0) __TVOS_AVAILABLE(11.0) = kLAErrorBiometryLockout,</span><br><span class="line">    </span><br><span class="line">    /// 身份验证失败, 因为需要显示的UI界面使用了interactionNotAllowed属性</span><br><span class="line">    LAErrorNotInteractive API_AVAILABLE(macos(10.10), ios(8.0), watchos(3.0), tvos(10.0)) = kLAErrorNotInteractive,</span><br><span class="line">&#125; NS_ENUM_AVAILABLE(10_10, 8_0) __WATCHOS_AVAILABLE(3.0) __TVOS_AVAILABLE(10.0);</span><br></pre></td></tr></table></figure></p><h1 id="集成Face-ID-amp-Touch-ID"><a href="#集成Face-ID-amp-Touch-ID" class="headerlink" title="集成Face ID &amp; Touch ID"></a>集成Face ID &amp; Touch ID</h1><ul><li><p>导入对应的头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import LocalAuthentication</span><br></pre></td></tr></table></figure></li><li><p>使用canEvaluatePolicy方法判断当前的设备是否支持Face ID / Touch ID，若返回true且error不为空时，调用evaluatePolicy方法进行验证，系统会根据支持Face ID还是Touch ID，分别显示不同的验证方式和对话框。</p></li><li>验证结果会在evaluatePolicy的回调中，我们拿到对应的回调结果进行相应的处理即可。</li><li><p>如果是支持Face ID，需要在plist文件中，添加NSFaceIDUsageDescription。虽然不添加，也不会导致闪退或者其他问题，但是苹果在API文档中，还是标明了需要添加该key。</p><blockquote><p>Applications should also supply NSFaceIDUsageDescription key in the<br>Info.plist. This key identifies a string value that contains a<br>message to be displayed to users when the app is trying to use Face<br>ID for the first time. Users can choose to allow or deny the use of<br>Face ID by the app before the first use or later in Face ID privacy<br>settings. When the use of Face ID is denied, evaluations will fail<br>with LAErrorBiometryNotAvailable.</p></blockquote></li><li><p>简单的demo部分代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class LocalAuthenticationService: NSObject &#123;</span><br><span class="line">    </span><br><span class="line">    /// 进行Face ID / Touch ID验证</span><br><span class="line">    class func verifyAuthentication(with type: BiometricsType, success: @escaping () -&gt; Void) &#123;</span><br><span class="line">        guard type != .none else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        let context = LAContext()</span><br><span class="line">        context.evaluatePolicy(.deviceOwnerAuthentication, localizedReason: type == .touchID ? &quot;通过Home键验证已有手机指纹&quot; : &quot;面容ID&quot;) &#123; (isSuccess, error) in</span><br><span class="line">            if isSuccess &#123;</span><br><span class="line">                success()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 判断是否支持Face ID / Touch ID</span><br><span class="line">    class func justSupportBiometricsType() -&gt; BiometricsType &#123;</span><br><span class="line">        let context = LAContext()</span><br><span class="line">        let error: NSErrorPointer = nil</span><br><span class="line">        if context.canEvaluatePolicy(.deviceOwnerAuthentication, error: error) &#123;</span><br><span class="line">            guard error == nil else &#123;</span><br><span class="line">                return .none</span><br><span class="line">            &#125;</span><br><span class="line">            if #available(iOS 11.0, *) &#123;</span><br><span class="line">                return context.biometryType == .faceID ? .faceID : .touchID</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return .touchID</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return .none</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>github链接：<a href="https://github.com/CloverKim/UnlockDemo" target="_blank" rel="noopener">UnlockDemo</a></p><h2 id="运行效果图"><a href="#运行效果图" class="headerlink" title="运行效果图"></a>运行效果图</h2><p><img src="http://pic.cloverkim.com/749c46aagy1fx7k6vlb9yg20op0dwe81.gif" alt="" title="Touch ID"></p></li></ul><p><img src="http://pic.cloverkim.com/749c46aagy1fx7k1sjb6ag20op0dwb29.gif" alt="" title="Face ID"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/zuoqianheng/article/details/80594389" target="_blank" rel="noopener">csdn - mengkeer - iOS FaceID &amp; TouchID</a></li><li><a href="https://www.jianshu.com/p/277ab9d45115" target="_blank" rel="noopener">简书 - zuoqianheng- iOS集成FaceID或TouchID</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初夏的浪漫，白与绿的对比 —— 持统天皇</title>
      <link href="//hege-02.html"/>
      <url>//hege-02.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>春過ぎて  夏来にけらし  白妙の<br>衣ほすてふ  天の香久山</p></blockquote><blockquote><p>春尽夏已到，翠微香久山。<br>满眼白光耀，闻说晒衣衫。</p></blockquote><a id="more"></a><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>&emsp;&emsp;持统天皇（645-702）：第41代天皇，在位12年。天智天皇的第二皇女，天武天皇的皇后，喜爱文艺与旅游。686年9月9日，天武天皇逝世后，她当机立断逮捕了“企图谋反”的大津皇子（おおつのみこ）。10月2日，大津皇子被处决。其实，她是大津皇子的姨妈，杀害大津皇子的目的是为了让自己的儿子草壁皇子（くさかべのみこ）登上皇位。可惜，草壁皇子还未即位，便于689年28岁时夭折了。于是她只好亲自掌权，人称持统天皇。她即位后，迁都藤原京，努力推行新政，制定「大宝律令」，巩固了中央集权制。她在位11年后，将皇位传给了孙子、草壁皇子的儿子文武天皇（686-702。もんむてんのう）。在文学史上，她以哀悼天武天皇的挽歌而闻名。据历史记载，她即位后，曾多次离开奈良藤原京行幸吉野离宫，也许她频繁旅行的目的是为了忘掉骨肉相残的悲痛回忆。<br>&emsp;&emsp;她主张葬礼从简，是天皇火葬的第一人。文武天皇4年（700年），僧人道照（どうしょう）留下遗言，嘱咐后人将自己火化。「天下の火葬、之より始まれり。」（天下的火葬由此开始。「統日本紀」）两年后的大宝2年（702年）12月7日、持统天皇去世，下令将自己火葬于飞鸟地方的山岗之上。<br>&emsp;&emsp;『万葉集』共收其作品6首。<br><img src="http://pic.cloverkim.com/持统天皇.jpg" alt="" title="持统天皇"></p><h1 id="鉴赏"><a href="#鉴赏" class="headerlink" title="鉴赏"></a>鉴赏</h1><p>&emsp;&emsp;香久山，也称香具山，位于大和平原，是大和三山之一，海拔152米。传说是天上落下的神圣之山，所以又称天之香久山。据古代传说，每当春夏之交，甘寿明神便用这里的神水浸湿白布衣衫，然后在阳光下晒干，以辨明人心的真伪。转眼已到了晚春季节，使人分明感到有些夏天的暑热了，青翠的香久山上，点点白光耀眼，如同开着一片片洁白的水晶花，就像是古代传中到处晒起的白衣衫。<br>&emsp;&emsp;这种景象，女皇从奈良县橿原市的藤原宫中曾多次眺望过。而且，她每次前往吉野离宫时，都要经过香久山。因此，这首和歌不是描写眼前的情景，而是在春夏交替的季节，以女性对季节变迁的敏锐感觉，回想起古代传说而创作出来的。万叶时代的和歌多注重写实，而持统天皇的这首和歌在表现手法上独具特色。这周想象中的风景画，以嫩绿与洁白的色彩相对比，形成后世日本画的基本色调。「小仓百人一首」的编者藤原定家有意将受人尊崇的天智天皇、持统天皇父女的作品放在卷首，使人感到男女二重唱的情趣。<br>&emsp;&emsp;「白妙の」是万叶时代的「枕词」（和歌术语，修辞法之一，放在特定的词语前面起修饰和调整语调的作用，多为五音），它常和“衣、袖、袂、雪”等词连用。『万葉集』卷1中的原歌，“晒衣衫”是对眼前景物的状态描写，而500年后的『新古今和歌集』和『小仓百人一首』中的这首和歌，变成了传闻，这一点值得注意。<br>&emsp;&emsp;『万葉集』中常用的「枕词」有20多个，使用次数最多的前三位是「あしひきの」或「あしびきの」（使用111次，常与「山」连用，见第三首和歌）、「ぬばたまの」（使用80次、常与「黑」或「夜」连用）、「しろたへの」（使用61次）。冠有「枕词」的词语称为「被枕词」，「枕词」与「被枕词」并用，构成了和歌中特殊的修辞技巧。</p><blockquote><p>晚春悄然逝去，<br>仿佛已是夏天。<br>听说那神秀的香久山上，<br>今年又是白光耀眼，<br>就像晾起了洁白的衣衫。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小仓百人一首 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 和歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git原理简介和常用命令</title>
      <link href="//git-principle.html"/>
      <url>//git-principle.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在我们日常的开发工作中，对代码的管理一般会用到Git，当然也有使用SVN。对于刚接触Git或者仅仅是使用<code>git pull</code>、<code>git push</code>等几个常用命令的人来说，对Git还是挺陌生的，不理解其原理和如何具体使用。本文会对Git的原理以及常用命令进行介绍，希望对刚接触Git的开发者有一定的帮助。<a id="more"></a><br><img src="http://pic.cloverkim.com/749c46aagy1fxy91cj41qj208c05iwf8.jpg" alt="" title="Git"></p><h1 id="Git基础和原理"><a href="#Git基础和原理" class="headerlink" title="Git基础和原理"></a>Git基础和原理</h1><h2 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h2><p>&emsp;&emsp;Git和其他版本控制系统（包括SVN和近似工具）的主要差别在于Git对待数据的方法。概念上来区分，其他大部分系统以文件变更列表的方式存储信息。这类系统（CVS、Subversion、Perforce、Bazaar等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。Git不按照以上方式对待或保存数据。反之，Git更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在Git中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git对待数据更像是一个快照流。如下图所示。这是Git与几乎所有其它版本控制系统的重要区别。<br><img src="http://pic.cloverkim.com/749c46aagy1fxwutjhlfrj20m808hwgu.jpg" alt=""></p><h2 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h2><p>&emsp;&emsp;在Git中的绝大多数操作只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。如果你习惯于所有操作都有网络延时开销的集中式版本控制系统，Git在这方面会让你感到速度之神赐给了Git超凡的能量。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。<br>&emsp;&emsp;举个🌰，要浏览项目的历史，Git不需要外连到服务器去获取历史，然后再显示出来，它只需要直接从本地数据库中读取。你能立即看到项目历史。如果想查看当前版本与一个月前的版本之间引入的修改，Git会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p><h2 id="Git-保证完整性"><a href="#Git-保证完整性" class="headerlink" title="Git 保证完整性"></a>Git 保证完整性</h2><p>&emsp;&emsp;Git中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。这个功能构建在Git底层，是构成Git哲学不可或缺的部分。若你在传送过程中丢失信息或损坏文件，Git就能发现。</p><h2 id="Git一般只添加数据"><a href="#Git一般只添加数据" class="headerlink" title="Git一般只添加数据"></a>Git一般只添加数据</h2><p>&emsp;&emsp;你执行的Git操作，几乎只往Git数据库中增加数据。很难让Git执行任何不可逆的操作，或者让它以任何形式清除数据。同别的VCS一样，未提交更新时有可能丢失或弄乱修改的内容，但是一旦你提交快照到Git中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。</p><h1 id="Git-的工作流程"><a href="#Git-的工作流程" class="headerlink" title="Git 的工作流程"></a>Git 的工作流程</h1><h2 id="先来了解4个专有名词"><a href="#先来了解4个专有名词" class="headerlink" title="先来了解4个专有名词"></a>先来了解4个专有名词</h2><ul><li><p>Workspace（工作区）：<br>&emsp;&emsp;我们平时进行开发改动的地方，是我们当前看到的，也是最新的。平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发，在开发过程中就是对工作区的操作。</p></li><li><p>Index / Stage（暂存区）：<br>&emsp;&emsp;.git目录下的index文件，暂存区会记录<code>git add</code>添加文件的相关信息（文件名、大小、timestamp…），不保存文件实体，通过id指向每个文件实体。可以使用<code>git status</code>查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。<br>&emsp;&emsp;当我们完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过 <code>git add</code>命令先提交到暂存区，被git管理。</p></li><li><p>Local Repository（本地仓库）：<br>&emsp;&emsp;保存了对象被提交过的各个版本，比起工作区和暂存区的内容，它要更旧一些。<code>git commit</code>后同步index（暂存区）的目录树到本地仓库，方便从下一步通过<code>git push</code>同步本地仓库与远程仓库。</p></li><li><p>Remote Repository（远程仓库）：<br>&emsp;&emsp;远程仓库是指托管在一些Git代码托管平台上的你的项目的版本库，比如<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>、<a href="https://about.gitlab.com/" target="_blank" rel="noopener">GitLab</a>、<a href="https://gitee.com/" target="_blank" rel="noopener">码云</a>、<a href="https://coding.net/" target="_blank" rel="noopener">码市</a>等等。远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是远程仓库的内容是最旧的。</p></li></ul><p>&emsp;&emsp;四个区域之间的关系如下图所示：<br><img src="http://pic.cloverkim.com/749c46aagy1fxx2bz7s91j20p20ivdhh.jpg" alt=""></p><h1 id="常用的Git命令详解"><a href="#常用的Git命令详解" class="headerlink" title="常用的Git命令详解"></a>常用的Git命令详解</h1><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>&emsp;&emsp;HEAD，它始终指向当前所处分支的最新的提交点，所处的分支发生了变化，或者产生了新的提交点，HEAD就会跟着改变。<br><img src="http://pic.cloverkim.com/749c46aagy1fxx4b6zt44j20f40ah0tc.jpg" alt="" title="HEAD"></p><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>&emsp;&emsp;<code>git add</code>主要实现将工作区修改的内容提交到暂存区，交由git管理。相关命令如下表所示：</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">git add .</td><td style="text-align:center">添加当前目录的所有文件到暂存区</td></tr><tr><td style="text-align:center">git add [dir]</td><td style="text-align:center">添加指定目录到暂存区，包括子目录</td></tr><tr><td style="text-align:center">git add [file]</td><td style="text-align:center">添加指定文件到暂存区</td></tr></tbody></table><p><img src="http://pic.cloverkim.com/749c46aagy1fxx4ana2tij20cr06s0t0.jpg" alt="" title="git add"></p><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>&emsp;&emsp;<code>git commit</code>主要实现将暂存区的内容提交到本地仓库，并使得当前分支的HEAD向后移动一个提交点。相关命令如下表所示：</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">git commit -m [message]</td><td style="text-align:center">提交暂存区到本地仓库，message代表说明信息</td></tr><tr><td style="text-align:center">git commit [file] -m [message]</td><td style="text-align:center">提交暂存区的指定文件到本地仓库</td></tr><tr><td style="text-align:center">git commit —amend -m [message]</td><td style="text-align:center">使用一次新的commit，代替上一次提交</td></tr></tbody></table><p><img src="http://pic.cloverkim.com/749c46aagy1fxx4anfmlzj20f009x0t9.jpg" alt="" title="git commit"></p><h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p>&emsp;&emsp;在我们的代码仓库中，有一条主分支Master，我们可以从主分支当中，创建出许多分支以开发其他功能，创建子分支的好处是每个分支互不影响，大家只需要在自己的分支上继续开发，正常工作。待开发完毕后，再将自己的子分支合并到主分支或者其他分支即可，这样，即安全又不影响他人的工作。<br>&emsp;&emsp;关于分支，主要有展示分支、切换分支、创建分支、删除分支操作。相关命令如下表所示：</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">git branch</td><td style="text-align:center">列出本地所有分支</td></tr><tr><td style="text-align:center">git branch -f</td><td style="text-align:center">列出远程所有分支</td></tr><tr><td style="text-align:center">git branch -a</td><td style="text-align:center">列出所有本地和远程的分支</td></tr><tr><td style="text-align:center">git branch [branch -name]</td><td style="text-align:center">新建一个分支，但依然停留在当前分支</td></tr><tr><td style="text-align:center">git branch —track [branch][remote-branch]</td><td style="text-align:center">新建一个分支，与指定的远程分支建立追踪关系</td></tr><tr><td style="text-align:center">git checkout -b [branch-name]</td><td style="text-align:center">新建一个分支，并切换到该分支</td></tr><tr><td style="text-align:center">git checkout [branch-name]</td><td style="text-align:center">切换到指定分支，并更新工作区</td></tr><tr><td style="text-align:center">git branch -d [branch-name]</td><td style="text-align:center">删除指定分支</td></tr><tr><td style="text-align:center">git push origin —delete [branch-name]</td><td style="text-align:center">删除远程分支</td></tr></tbody></table><p><img src="http://pic.cloverkim.com/749c46aagy1fxx6t7cb2bj20ot0bnmy9.jpg" alt="" title="git branch"></p><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>&emsp;&emsp;<code>git merge</code>命令的作用是把不同的分支合并起来。在实际的开发中，我们会从master主分支中创建出一个新的分支，然后进行需求或功能的开发，最后开发完成后需要合并子分支到主分支master中，这就需要用到<code>git merge</code>命令。</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">git merge [branch]</td><td style="text-align:center">合并指定分支到当前分支</td></tr></tbody></table><p><img src="http://pic.cloverkim.com/749c46aagy1fxx76z1kc8j20l206sgm4.jpg" alt="" title="git branch"></p><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p>&emsp;&emsp;rebase又称为衍合，是合并的另外一种选择。在开始阶段，我们在新的分支上，执行<code>git rebase dev</code>，那么新分支上的commit都在master分支上重演一遍，最后checkout切换回到新的分支。这一点与merge命令是一样的，合并前后所处的分支并没有改变。<br><img src="http://pic.cloverkim.com/749c46aagy1fxx7s107mvj20sd064dg5.jpg" alt="" title="git rebase dev"></p><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>&emsp;&emsp;<code>git reset</code>命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来从历史仓库中复制文件到索引，而不动工作目录。如果不给选项，那么当前分支指向到那个提交。如果用–hard参数，那么工作目录也更新，如果用–soft参数，那么都不变。使用 <code>git reset HEAD ~3</code> 命令的说明如下图所示：<br><img src="http://pic.cloverkim.com/749c46aagy1fxy00bvqa4j20mk0c9wfo.jpg" alt="" title="git reset HEAD~3"></p><p>&emsp;&emsp;如果没有给出提交的版本号，那么默认用HEAD。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用–hard参数，工作目录也一样。<br><img src="http://pic.cloverkim.com/749c46aagy1fxy00byt7bj20o50c43zh.jpg" alt="" title="git reset"></p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">git reset —soft [commit]</td><td style="text-align:center">只改变提交点，暂存区和工作目录的内容都不改变</td></tr><tr><td style="text-align:center">git reset —mixed [commit]</td><td style="text-align:center">改变提交点，同时改变暂存区的内容</td></tr><tr><td style="text-align:center">git reset —hard [commit]</td><td style="text-align:center">暂存区、工作区的内容都会被修改到与提交点完全一致的状态</td></tr><tr><td style="text-align:center">git reset —hard HEAD</td><td style="text-align:center">让工作区回到上次提交时的状态</td></tr></tbody></table><h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p>&emsp;&emsp; revert 是用一个新的提交来消除一个历史提交所做的任何修改，revert之后，我们本地的代码会回滚到指定的历史版本。举个🌰，其结果如下图所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -am &apos;update readme&apos;</span><br><span class="line">git revert 15df9b6</span><br></pre></td></tr></table></figure></p><p><img src="http://pic.cloverkim.com/749c46aagy1fxy16i1trqj20ez06nt90.jpg" alt="" title="git revert"></p><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>&emsp;&emsp;将本地仓库分支上传到远程仓库分支，实现同步。相关命令如下：</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">git push [remote] [branch]</td><td style="text-align:center">上传本地指定分支到远程仓库</td></tr><tr><td style="text-align:center">git push [remote] —force</td><td style="text-align:center">强行推送当前分支到远程仓库，即使有冲突</td></tr><tr><td style="text-align:center">git push [remote] —all</td><td style="text-align:center">推送所有分支到远程仓库</td></tr></tbody></table><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p>&emsp;&emsp;<code>git fetch</code>是从远程仓库中获取最新版本到本地仓库中，但不会自动合并本地的版本，也就说，我们可以查看更新情况，然后再决定是否进行合并。在fetch命令中，有一个重要的概念：<strong>FETCH_HEAD</strong>：某个branch在服务器上的最新状态，每一个执行过fetch操作，都会存在一个FETCH_HEAD列表，这个列表保存在<strong>.git</strong>目录的<strong>FETCH_HEAD</strong>文件中，其中每一行对应于远程服务器的每一个分支。当前分支指向的FETCH_HEAD，就是文件第一行对应的那个分支。</p><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>&emsp;&emsp;<code>git pull</code>是从远程仓库中获取最新版本并自动合并到本地的仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin next</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上面命令表示，取回<strong>origin/next</strong>分支的更新，再与当前分支进行合并。实质上，等同于，先做<code>git fetch</code>，再执行<code>git merge</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git merge origin/next</span><br></pre></td></tr></table></figure></p><h1 id="一些命令的区别"><a href="#一些命令的区别" class="headerlink" title="一些命令的区别"></a>一些命令的区别</h1><h2 id="merge-和-rebase"><a href="#merge-和-rebase" class="headerlink" title="merge 和 rebase"></a>merge 和 rebase</h2><p>&emsp;&emsp;举个🌰说明：现在我们有这样两个分支，test和master，其提交记录如下图所示：<br><img src="http://pic.cloverkim.com/749c46aagy1fxy73k6ut8j20ca04z74f.jpg" alt=""><br>&emsp;&emsp;在master分支上执行<code>git merge test</code>命令后，会得到如下图所示的结果：<br><img src="http://pic.cloverkim.com/749c46aagy1fxy73k8nxxj20fp04s74h.jpg" alt=""><br>&emsp;&emsp;如果在master分支上执行<code>git rebase test</code>命令，则会得到如下图所示的结果：<br><img src="http://pic.cloverkim.com/749c46aagy1fxy73kcohsj20hc03mt8t.jpg" alt=""><br>&emsp;&emsp;由上面的🌰可以看出，merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的提交记录。<br>&emsp;&emsp;如果我们想要一个干净的，没有merge commit的线性历史树，那么应该选择<code>git rebase</code>，如果想保留完整的历史记录，并且想要避免重写commit history的风险，应该选择使用<code>git merge</code>。</p><h2 id="reset-和-revert"><a href="#reset-和-revert" class="headerlink" title="reset 和 revert"></a>reset 和 revert</h2><ul><li>revert 是用一次新的commit来回滚之前的commit，而 reset 是直接删除指定的commit。</li><li>在回滚这一操作上看，效果差不多。但在日后继续merge以前的老版本时有区别。因为<code>git revert</code>是用一次逆向的commit“中和”之前的提交，因此日后合并老的分支时，导致这部分改变不会再次出现，减少冲突。但是<code>git reset</code>是直接把某个commit在某个分支上删除，因而和老的分支再次merge时，这些被回滚的commit应该还会被引入，产生很多冲突。</li><li><code>git reset</code>是把HEAD向后移动了一下，而<code>git revert</code>是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</li></ul><h2 id="fetch-和-pull"><a href="#fetch-和-pull" class="headerlink" title="fetch 和 pull"></a>fetch 和 pull</h2><p>&emsp;&emsp;<code>git fetch</code>和<code>git pull</code>共同点都是从远程的分支获取最新的版本到本地，但fetch命令不会自动将更新合并到本地的分支，而pull命令会自动合并到本地的分支。在实际的使用中，<code>git fetch</code>要更安全一些，因为获取到最新的更新后，我们可以查看更新情况，然后再决定是否合并。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://git-scm.com/docs" target="_blank" rel="noopener">git官网</a></li><li><a href="https://www.yiibai.com/git" target="_blank" rel="noopener">易百教程 - Maxsu - Git教程</a></li><li><a href="https://juejin.im/post/599e14875188251240632702" target="_blank" rel="noopener">掘金 - Ruheng - 一篇文章，教你学会Git</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的官方网站 - 廖雪峰 - Git教程</a></li><li><a href="https://blog.csdn.net/hudashi/article/details/7664457" target="_blank" rel="noopener">CSDN - hudashi - git fetch 和 git pull的区别</a></li><li><a href="https://www.cnblogs.com/yelbosh/p/7471979.html" target="_blank" rel="noopener">博客园 - Yelbosh - Git的原理简介和常用命令</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git使用前配置</title>
      <link href="//git-config.html"/>
      <url>//git-config.html</url>
      
        <content type="html"><![CDATA[<h1 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h1><p>&emsp;&emsp;在安装完Git时候，第一件事就是设置我们的用户名称和邮箱地址，因为每一次Git的提交都会使用这些信息，并且它会写入到每一次的提交当中，不可更改。如果是应用于多人协助开发的话，用户名和邮箱地址要按照公司部门的规范来进行设置。<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;cloverkim&quot;</span><br><span class="line">$ git config --global user.email &quot;jiang.shunjin@icloud.com&quot;</span><br></pre></td></tr></table></figure></p><h1 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h1><p>1、首先查看本地是否存在SSH-Key，打开终端，输入命令<code>ls ~/.ssh</code>，如果结果如下图所示，则说明本地已经存在SSH Key，则跳过创建的步骤，直接到第3步。<br><img src="http://pic.cloverkim.com/749c46aagy1fy1tkaqhwmj206g02x74b.jpg" alt=""><br>2、如果本地没有生成过SSH Key，则需要生成，相关命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C&quot;you_email&quot;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;your_email：填写自己的邮箱地址，在终端输入命令后，根据提示直接敲回车即可，生成成功后如下图所示：<br><img src="http://pic.cloverkim.com/749c46aagy1fy1txneeedj20fi095mya.jpg" alt=""></p><p>3、然后在终端执行命令<code>cat ~/.ssh/id_rsa.pub</code>，将我们的ssh key进行复制，然后打开代码托管平台的设置界面，这里以<a href="https://gitee.com/" target="_blank" rel="noopener">码云</a>为例。点击安全设置的SSH公钥选项，根据情况添加标题、将刚刚复制的ssh key粘贴到③处，然后点击确定即可，这就在码云上配置好了我们的ssh key。<br><img src="http://pic.cloverkim.com/749c46aagy1fy1u5qayc7j20uh0iqn0j.jpg" alt="" title="码云"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Mac </tag>
            
            <tag> 实践 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>田野上秋夜的冷露与寂静 —— 天智天皇</title>
      <link href="//hege-01.html"/>
      <url>//hege-01.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>秋来田野上， 且宿陋茅庵。<br>夜半湿衣袖， 滴滴冷露沾。</p></blockquote><a id="more"></a><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>&emsp;&emsp;天智天皇（626 - 671）：第38代天皇，在位4年。即位前称中大兄皇子(なかのおおえのみこ)，天性聪慧。公元645年(大化元年)消天以苏我氏(そがし)父子为代表的豪族政权，实行「大化の改新」。<br>&emsp;&emsp;他在母亲齐明天皇(さいめいてんのう)去世后，由大和飞鸟迁都近江，在琵琶湖畔营造大津宮，制定近江令，整理户籍，统一税收等。他效仿我国唐代的政治制度，推动改革，莫定了中央集权制国家的基础。天智天皇死后,他的儿子大友皇子(おおとものみこ)与天智天皇的弟弟大海人皇子(おおあまのみこ)争夺皇位，爆发了「壬申の乱」，大津宮化为灰烬，大友皇子死于非命。后来大海人皇子即位，号天武天皇(てんむてんのう)。<br>&emsp;&emsp;天智天皇今存和歌五首，『日本書紀』中有一首，『万葉集』中有四首。<br><img src="http://pic.cloverkim.com/天智天皇.jpg" alt="" title="天智天皇"> </p><h1 id="鉴赏"><a href="#鉴赏" class="headerlink" title="鉴赏"></a>鉴赏</h1><p>&emsp;&emsp;从公元前3世纪弥生时代起，水稻的栽培由九州推广到日本全国。<br>&emsp;&emsp;秋天的田野一片金黄，收割水稻的季节即将来临。田边搭起了看守庄稼的茅草庵。为的是防止野猪和也野鹿等动物毁坏庄稼。那粗陋的棚顶怎能挡住黎明前降下的露水呢？你看，天降破晓，露水从草庵顶上的缝隙中滴下来，我的衣衫已被冷露浸透。<br>&emsp;&emsp;据说，此歌是天智天皇为体恤农民的辛苦所作。当时的天皇已经明确地认识到，农业是立国之本。又有人认为，当时天皇作这一类“悯农诗”与咒术有关，有祈祷五谷丰登之意。另外，还有人将此歌解释为“闺怨之歌”，认为歌中的露水暗喻泪水。因为日语中的「秋」与「厭」同音，所以是遭厌倦而被抛弃的妇人的哀歌。还有一个理由就是藤原定家十分重视「恋歌」，『小仓百人一首』中「恋歌」占43首，将近半数，恐怕他不会选一首单纯的体恤农家辛苦的歌来作卷首之篇。也有学者认为，从这首歌的风格来看，它不是万叶时代的作品，而是平安初期的和歌，因此，这个作品不是天皇的“御制歌”。<br>&emsp;&emsp;关于日本的水稻，一种说法是由中国经朝鲜半岛传入的，另一种说法是由南方、中国的台湾经琉球传入日本的。早在奈良时代就有「早稲」、「晚稲」、「粳」、「糯」之分，到了平安时代又培育出了「中稲」。</p><blockquote><p>金黄的原野已是深秋，<br>茅草棚何等粗陋。<br>拂晓前，<br>露冷风凉，<br>一滴滴沾湿了我的衣袖。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小仓百人一首 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 和歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>银装素裹的美丽的富士山 —— 山部赤人</title>
      <link href="//hege-04.html"/>
      <url>//hege-04.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>田子の浦に&emsp;うち出でて見れば&emsp;白妙の<br>富士の高嶺に&emsp;雪は降りつつ</p></blockquote><blockquote><p>我到田子浦，远瞻富士山。<br>纷纷扬大雪，纨素罩峰颠。</p></blockquote><a id="more"></a><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>&emsp;&emsp;山部赤人（生卒年不详）：奈良时代的歌人，与柿本人麻吕齐名被称为歌圣。其作品格调工整，意境清澄。纪贯之在『古今和歌集』的序文中说：“难将人麻吕置于赤人之上，亦难将赤人置于人麻吕之下。”山部赤人一生官职卑微，其作品除伴驾应召之作以外，尤以歌咏大自然的和歌而闻名。<br>&emsp;&emsp;『万枼集』收入其长歌、短歌达数十首。</p><h1 id="鉴赏"><a href="#鉴赏" class="headerlink" title="鉴赏"></a>鉴赏</h1><p>&emsp;&emsp;田子浦，位于现在静冈县富士市，海岸风光优美，天气晴好之日，可以远眺富士山的雄姿。富士山位于山梨、静冈两县之间，是一座海拔3776米的休眠火山，为日本第一高峰。十多万年前，它曾是一座活动频繁的活火山，不停地喷烟吐火，引起地震、森林火灾等自然灾害。在远古人的眼里，它具有无穷的神秘力量，很早就成为原始部落的图腾标记，受到狂热而虔诚的崇拜。富士山顶终年积雪，呈美丽的圆锥形，自古以为被日本民族视为神圣之物，人称灵峰富士，成为日本的象征。千百年来，它一直是和歌、俳句、日本画等艺术的讴歌对象。<br>&emsp;&emsp;作者多少次往来于田子浦之上，遥望着湛湛蓝天之下银装素裹的富士山。是那纨素般洁白的积雪，给人一种新鲜的感动。它安详静穆，银光闪闪，犹如一位沉睡的美女。这些激发出作者心中滚滚的诗潮，来讴歌这壮美的景色。那山巅之上，想来正是大雪纷纷扬扬吧。<br>&emsp;&emsp;原作是万叶时代的作品（『万枼集』（卷3-318））：</p><blockquote><p>田子の浦ゆ&emsp;うち出でて見れば&emsp;真白にそ<br>富士の高嶺に&emsp;雪は降りける</p></blockquote><p>&emsp;&emsp;经过田子浦辽阔的海岸，远远望见富士山顶上的积雪，作者心中涌起一种纯朴的感动。而『小仓百人一首』中的作品在用词上与原歌有三处不同：</p><ol><li>「田子の浦ゆ」变成了「田子の浦に」，表示经过场所的格助词发生了变化。</li><li>「真白にそ」变成了「白妙の」，更具有新古今集时代的特色。</li><li>结尾「雪は降りける」（过去式）变成了「雪は降りつつ」（现在进行时）。望见遥远的富士山上正在下雪，从距离上来看，这是不可能的。所以人们普遍认为，此歌没有原作好。对「うち出でて」一词的普遍解释是来到宽阔的地方。最近，日本的三重大学的广冈义隆（ひろおかよしたか）教授指出，「うち出でて」的意思是下决心划船来到田子浦宽阔的海面上，即「思い切って船で海に漕ぎ出して」，为的是更好的仰望富士山。因为当时的火山富士山喷出的岩浆使得这一代的海岸崎岖不平，难于行走，要瞻仰富士山的雄姿，最好是下决心到海上去看。</li></ol><blockquote><p>我来到田子浦海岸，<br>遥远那富士，<br>屹立在天边。<br>那高岭上大雪纷飞。<br>你看她披着洁白的衣衫。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小仓百人一首 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 和歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秋天里华丽而静寂的美感 —— 猿丸大夫</title>
      <link href="//hege-05.html"/>
      <url>//hege-05.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>奥山に&emsp;紅葉踏み分け&emsp;鳴く鹿の<br>声聞く時ぞ&emsp;秋は悲しき</p></blockquote><blockquote><p>有鹿踏红叶，深山独自游。<br>呦呦鸣不止，此刻最悲秋。</p></blockquote><a id="more"></a><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>&emsp;&emsp;猿丸大夫（生卒年不详）：中古三十六歌仙之一。大约生活在八九世纪，他到底是大和时代元明天皇时的歌人，还是生活在平安时代，历来有争论。『猿丸大夫集』中的和歌几乎全是无名氏的作品，所以有人说，猿丸只是传说中的人物，其实并不存在。平安中期由藤原公任（ふじわらのきんとう）编辑的和歌集『三十六人撰』中，收入猿丸的三首作品，此歌便是其中的一首。</p><h1 id="鉴赏"><a href="#鉴赏" class="headerlink" title="鉴赏"></a>鉴赏</h1><p>&emsp;&emsp;萧萧落木，满地红叶。万簌俱寂中只听见一只求偶的雄鹿沙沙的足音，隐隐还传来它哀愁孤独的低鸣，更为歌中增添了冷冷清清，寻寻觅觅的秋山寂寥之感。这种色彩鲜明的格调中包含着淡淡的哀愁，又有几分朦胧的神秘意境，在『古今和歌集』中很常见。藤原定家对这首和歌的评价很高，红叶满山，晚秋鹿鸣，如怨如慕，独自悲秋。这非常合乎日本民族倾向于感伤的审美意识。<br>&emsp;&emsp;在『古今和歌集』时代，「红枼」主要指「萩の黄葉」，到了『新古今和歌集』时代才开始指「楓の紅葉」。这首和歌具有先驱的预言性，预示了一种更加华美的歌风即将到来。</p><p><img src="http://pic.cloverkim.com/749c46aagy1fyh4vu17nbj208w08vtci.jpg" alt="" title="呦呦鹿鸣"></p><blockquote><p>鹿儿踏着红叶，<br>在深山古老的梦中漫游，<br>呦呦鸣叫，四处求偶。<br>听见这凄凉的哀韵，<br>秋光啊，更令人悲愁。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小仓百人一首 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 和歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>传说与幻想的冬夜之歌 —— 大伴家持</title>
      <link href="//hege-06.html"/>
      <url>//hege-06.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>鵲の&emsp;渡せる橋に&emsp;おく霜の<br>白きを見れば&emsp;夜ぞ更けにける</p></blockquote><blockquote><p>渺渺天河阔，皎皎鹊翅长。<br>夜阑一片白，已是满桥霜。</p></blockquote><a id="more"></a><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>&emsp;&emsp;大伴家持（718？-785）：『万枼集』编撰的中心人物，万叶后期的代表歌人，三十六歌仙之一。父亲大伴旅人（おおとものたびと）是大伴氏的族长，姑母是大伴坂上郎女（おおとものさかのうえのいらつめ），他们都是杰出的歌人。他的歌风优雅纤细、感伤孤独，是典型的万叶晚期的风格。<br>&emsp;&emsp;725年，7岁的加持随父亲离开奈良，远赴九州。身边有父亲旅人、姑母坂上郎女、山上忆良（やまのうえのおくら）等一批杰出的歌人，以至于当时歌坛的中心也从首都移到了九州。他在和歌艺术与不断传来的大陆文化的熏陶下成长起来。从中年起，加持担任过地方长官，以及兵部少辅。758年，大伴家族在政治权利的斗争中失利，40岁的加持只好远离京城，担任了「因幡守」（今鸟取县东部的地方长官），在这里他吟出了『万枼集』的压卷之歌，为万叶时代合上了帷幕。</p><blockquote><p>新しき&emsp;年の初めの&emsp;初春の<br>今日降る雪の&emsp;いやしけ吉事<br>汉译：新年飞雪迎春来，今岁诸事应吉祥。</p></blockquote><p>&emsp;&emsp;『万枼集』收入加持的作品400余首，占『万枼集』和歌的十分之一。</p><h1 id="鉴赏"><a href="#鉴赏" class="headerlink" title="鉴赏"></a>鉴赏</h1><p>&emsp;&emsp;中国牛郎织女的传说，从古代起便在日本广为流传。中国古书上说：“乌鹊填河，成桥以渡织女”。（《淮南子》）那闪烁的银河上，一年一度搭起鹊桥，让隔着盈盈一水、泪眼相望的牛郎织女夫妻团聚。千百年来，中日两国的长辈在星空下对孩子们谈到这浪漫的故事，总会激起孩子们无边的遐想与同情。<br>&emsp;&emsp;大伴家持年轻时曾任守卫皇宫南门的卫队长，冬夜里燃起篝火，仰望星河，他不禁想到那天上的鹊桥也该是铺满寒霜了吧。由夏夜的星空与童年的记忆联想到严冬的寒霜，使本诗开拓出新的意境来。江户时代的学者贺茂真渊（かものまぶち）认为，鹊桥不是指天上的桥，而是比喻皇宫中的台阶。因此，这首歌描写的不是神话故事，而是作者冬夜执剑守卫皇宫时的切实感受。<br>&emsp;&emsp;在『万枼集』中，有不少关于七夕的作品，但没有一首有关鹊翅搭桥的内容，而是牛郎划船渡过银河去见织女。中国的牛郎织女传说传到日本后，由于岛国地理环境的影响，牛郎变成了渔民。因此，这首鹊翅搭桥的和歌很可能是后人的作品。</p><blockquote><p>连接宽阔天河的鹊桥，<br>在这冬夜星空里，<br>闪着冷光。<br>阵阵寒气逼人，<br>想来桥上已铺满了白霜。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小仓百人一首 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 和歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秋夜独眠的寂寞 —— 柿本人麻呂</title>
      <link href="//hege-03.html"/>
      <url>//hege-03.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>あしびきの  山鳥の尾の  しだり尾の<br>長長し夜を  ひとりかも寝む</p></blockquote><blockquote><p>野雉深山里，尾垂与地连。<br>漫漫秋夜冷，只恐又独眠。</p></blockquote><a id="more"></a><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>&emsp;&emsp;柿本人麻呂（生卒年不详，梅原猛先生考证的生卒年为646-708年）：持统天皇及文武天皇时的宫廷歌人，官位始终很低。柿本氏为万叶时代最杰出的多产歌人之一，作品格调雄浑抒情，被誉为歌圣。他的一生当中，留下了许多疑团，生平事迹多不可考。梅原猛（うめはらたけし）教授在其著作『水底の歌』（新潮社，1978年）中提出了崭新的学说：他虽然深得持统天皇的信任，却因怀念高市皇子（たけちのみこ）而获罪，被流放处死。<br>&emsp;&emsp;日本文学史上有三位伟大的诗人：柿本人麻呂、西行法师（1118 - 1190。さいぎょうほうし）、松尾芭蕉（1644 - 1694。まつおばしょう）。『万枼集』、『古今和歌集』等歌集中共收入柿本人麻呂的作品300余首。</p><h1 id="鉴赏"><a href="#鉴赏" class="headerlink" title="鉴赏"></a>鉴赏</h1><p>&emsp;&emsp;本歌由野雉长长的翎尾起兴，再引出漫漫无尽的长夜来，写一个女子在秋夜里怅然独卧的失望情怀。她苦苦等待着自己的恋人前来相会，望眼欲穿。秋夜已深，恐怕今夜不能相见了，真令人沮丧，只好独自叹息，难以入睡。<br>&emsp;&emsp;歌中出色地运用了「枕词」和「序词」技巧。「序词」可以说是「枕词」的古老形式，也是一种和歌技巧。它由五个以上假名组成，有时甚至多达十几个假名，用比喻和双关语引出后面的有关词语。比起「枕词」来，「序词」更加自由，能够表现更加复杂的内容。它后面与之呼应的词语不像「枕词」那样固定，因而更富于创造性。「序词」分为两种：因词义而前后呼应的「有心の序」和发音相同而前后呼应的「无心の序」。而本歌中的「山鳥の尾の  しだり尾の」就是「長長し」的「序词」。<br>&emsp;&emsp;野雉是日本的国鸟，雄鸟有美丽的翎尾。相传此鸟在夜里雌雄隔山分别栖息，常有雄鸟徘徊于峰谷之间，以求配偶。作者由野雉这种鸟类的习性，联想到自己的孤单凄苦，故此歌读来韵味悠长。<br>&emsp;&emsp;野雉于1947年被「日本鸟学会」指定为国鸟。其理由是：一、雉是日本原产的鸟类。二、雉在日本的童话和诗歌中反复出现，具有亲和力。三、雉是勇气与母爱的象征。<br>&emsp;&emsp;在『万枼集』中本歌属于作者不明的作品。也有人认为，本歌是后人的作品。</p><blockquote><p>深山密林，<br>孤零零的野雉，<br>垂着秋夜般长长的翎尾。<br>独栖枝头，<br>怎能安睡？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小仓百人一首 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 和歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>遣唐使的望乡之思 —— 阿倍仲麻吕</title>
      <link href="//hege-07.html"/>
      <url>//hege-07.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>天の原&emsp;ふりさけ見れば&emsp;春日なる<br>三笠の山に&emsp;出でし月かも</p></blockquote><blockquote><p>长空极目处，万里一婵娟。<br>故国春日野，月初三笠山。</p></blockquote><a id="more"></a><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>&emsp;&emsp;阿倍仲麻吕（698？- 770）：奈良时代的学者，灵龟2年（716年），他18岁时作为第8次遣唐使中的遣唐留学生来到中国，中文名字为晁横。他曾在唐玄宗时代担任官职，实际上成了中日两国交流的常驻使节。他与李白（701 - 762）、王维（701 - 761）等中国诗人年龄相近，有亲密的交往。公元753年，他曾乘船回国，结果遇风暴，漂流至越南。他只好又回到长安，后来客死唐土。</p><p><img src="http://pic.cloverkim.com/阿倍仲麻吕.jpg" alt="" title="阿倍仲麻吕"></p><h1 id="鉴赏"><a href="#鉴赏" class="headerlink" title="鉴赏"></a>鉴赏</h1><p>&emsp;&emsp;这首和歌是他于天平胜宝5年（753年），打算随第10次遣唐使藤原清河回国时，出发前在明州（宁波）的送别宴会上见月有感而作的。遥望长空，月明在天，那是昔日从奈良春日野的三笠山头升起的明月啊。他仿佛觉得，少年时代见过的三笠山上冉冉升起的皓月，已经飞过茫茫东海，前来迎接他这位日夜思归的游子了。王维、包佶等中国诗人也出席了这次宴会。日本是仲麻吕只生活过18年的故乡，却常令他梦绕魂牵。辽阔的东海之上，弥漫着月光一样的无边无际的乡愁。这首诗景观宏大，感情深沉。千百年来，人们争相传诵。后人认为，仲麻吕的望乡之歌是一首与日月争辉的伟大作品，它表达了失去归国机会的留学生的深厚的故国之思，后来被收入『古今和歌集』的「羁旅歌」之中。<br>&emsp;&emsp;当李白听到他归国途中遇难的消息时，十分悲痛，写下了《哭晁卿衡》：</p><blockquote><p>日本晁卿辞帝都，征帆一片回蓬壶。<br>明月不归沉碧海，白云愁色满苍梧。</p></blockquote><p>&emsp;&emsp;李白将他比喻成死于湖南苍梧山麓的太古圣君舜。从李白诗中的“明月不归”一句可以推测仲麻吕的望乡之歌在李白等中国诗人中已经广为流传。另外，遣唐使们出发之前都要到三笠山麓举行祭祀仪式，三笠山变成了遣唐使和留学生们心目中的神圣的故国的象征。<br>&emsp;&emsp;顺便提一下，就在这一次遣唐使归国时，鉴真和尚乘坐的另一条船历尽艰难，终于到达了日本。他在日本普及佛教，为圣武天皇（しょうむてんのう）及皇后、皇太子等400余人受了戒，在奈良建起了「堂招提寺」。大殿屋顶上的一个建筑装饰物「鴟尾」，相传是鉴真和尚特意从中国带去的。</p><blockquote><p>仰望夜空茫茫，<br>这皎洁的明月啊，<br>你来自故乡，<br>那日思夜想的春日野，<br>那日思夜想的三笠山上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小仓百人一首 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 和歌 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一道有趣的算法题：10元最多可喝多少瓶啤酒？</title>
      <link href="//beer_problem.html"/>
      <url>//beer_problem.html</url>
      
        <content type="html"><![CDATA[<h1 id="请听题"><a href="#请听题" class="headerlink" title="请听题"></a>请听题</h1><blockquote><p>每瓶啤酒2元，2个空酒瓶或4个瓶盖可换1瓶啤酒。10元最多可喝多少瓶啤酒？</p></blockquote><h1 id="网上的解答"><a href="#网上的解答" class="headerlink" title="网上的解答"></a>网上的解答</h1><p>关于答案：网上有非常多的解答。包括：</p><ul><li>一步步进行推算</li><li>设一瓶酒里的酒价值x，酒瓶价值y，瓶盖价值z，列等式进行计算</li><li>跟老板赊账或者借酒瓶或者瓶盖计算</li><li>…等等<a id="more"></a>以下是网上给的实际演算过程：<br>1、用10元，先买回来5瓶酒，喝完后剩5个瓶子和5个盖子；（喝5瓶）<br>2、拿4个瓶子，4个盖子换回3瓶酒，喝完后剩下4个瓶子和4个盖子；（喝3瓶）<br>3、拿4个瓶子，4个盖子换回3瓶酒，喝完后剩下3个瓶子和三个盖子；（喝3瓶）<br>4、拿2个瓶子换1瓶酒，喝完后剩下2个瓶子，4个盖子；（喝1瓶）<br>5、拿2个瓶子，4个盖子换2瓶酒，喝完后剩下2个瓶子，2个盖子；（喝2瓶）<br>6、拿2个瓶子换1瓶酒，喝完后剩1个瓶子，3个盖子。（喝1瓶）<br>一共能够喝15瓶啤酒，但是还剩余1个瓶子和3个瓶盖。</li></ul><h1 id="采用递归算法实现-Swift"><a href="#采用递归算法实现-Swift" class="headerlink" title="采用递归算法实现 - Swift"></a>采用递归算法实现 - Swift</h1><p>作为一名程序猿，用笔一步步计算太麻烦了，知道原理，那就写个递归算法计算一波。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var drinkTotal = 5          // 总共喝的啤酒的数量,初始化为5，即购买的5瓶</span><br><span class="line">var leftBottle = 0          // 剩余空瓶的数量</span><br><span class="line">var leftCover = 0           // 剩余瓶盖的数量</span><br><span class="line"></span><br><span class="line">func convert(_ bottle: Int, _ cover: Int) -&gt; Int &#123;</span><br><span class="line">    if bottle &gt;= 2 || cover &gt;= 4 &#123;</span><br><span class="line">        leftBottle = (bottle / 2) + (bottle % 2) + (cover / 4)</span><br><span class="line">        leftCover = (cover / 4) + (cover % 4) + (bottle / 2)</span><br><span class="line">        return (bottle / 2) + (cover / 4) + convert(leftBottle, leftCover)</span><br><span class="line">    &#125;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drinkTotal += convert(5, 5)</span><br><span class="line">print(&quot;\n总共喝了\(drinkTotal)瓶啤酒，还剩下\(leftBottle)个空瓶，\(leftCover)个空盖&quot;)</span><br></pre></td></tr></table></figure></p><p>下面的写法更加通俗易懂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/// 啤酒信息类</span><br><span class="line">class TurnBeerInfo &#123;</span><br><span class="line">    var bottleTotal = 0       // 空瓶的数量</span><br><span class="line">    var coverTotal = 0        // 瓶盖的数量</span><br><span class="line">    var drinkTotal = 0        // 已喝啤酒的数量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 购买啤酒</span><br><span class="line">func buyBeer(_ money: Int, _ turnBeerInfo: TurnBeerInfo) &#123;</span><br><span class="line">    let beerTotal = money / 2</span><br><span class="line">    turnBeerInfo.bottleTotal = beerTotal</span><br><span class="line">    turnBeerInfo.coverTotal = beerTotal</span><br><span class="line">    turnBeerInfo.drinkTotal = beerTotal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 兑换啤酒</span><br><span class="line">func convert(_ turnBeerInfo: TurnBeerInfo, _ i: Int) &#123;</span><br><span class="line">    // 用空瓶兑换啤酒的数量</span><br><span class="line">    let bottleTurnNum = turnBeerInfo.bottleTotal / 2</span><br><span class="line">    // 计算空瓶兑换后的瓶盖数量</span><br><span class="line">    turnBeerInfo.coverTotal += bottleTurnNum</span><br><span class="line">    </span><br><span class="line">    // 用瓶盖兑换啤酒的数量</span><br><span class="line">    let coverTurnNum = turnBeerInfo.coverTotal / 4</span><br><span class="line">    // 重新计算瓶盖兑换后的瓶盖数量</span><br><span class="line">    turnBeerInfo.coverTotal = turnBeerInfo.coverTotal % 4 + coverTurnNum</span><br><span class="line">    // 重新计算瓶盖兑换后的空瓶数量</span><br><span class="line">    turnBeerInfo.bottleTotal = turnBeerInfo.bottleTotal % 2 + bottleTurnNum + coverTurnNum</span><br><span class="line">    // 计算总共喝了几瓶</span><br><span class="line">    turnBeerInfo.drinkTotal = turnBeerInfo.drinkTotal + coverTurnNum + bottleTurnNum</span><br><span class="line">    </span><br><span class="line">    print(&quot;这是第\(i)次兑换，目前已喝了\(turnBeerInfo.drinkTotal)瓶啤酒，还剩下\(turnBeerInfo.bottleTotal)个空瓶，\(turnBeerInfo.coverTotal)个瓶盖&quot;)</span><br><span class="line"></span><br><span class="line">    // 满足条件，继续计算</span><br><span class="line">    if turnBeerInfo.bottleTotal &gt;= 2 || turnBeerInfo.coverTotal &gt;= 4 &#123;</span><br><span class="line">        let j = i + 1</span><br><span class="line">        convert(turnBeerInfo, j)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let turnBeerInfo = TurnBeerInfo()</span><br><span class="line">let totalMoney = 10</span><br><span class="line">buyBeer(totalMoney, turnBeerInfo)</span><br><span class="line">convert(turnBeerInfo, 1)</span><br><span class="line">print(&quot;\n总共喝了\(turnBeerInfo.drinkTotal)瓶啤酒，还剩下\(turnBeerInfo.bottleTotal)个空瓶，\(turnBeerInfo.coverTotal)个空盖&quot;)</span><br></pre></td></tr></table></figure></p><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="http://pic.cloverkim.com/749c46aagy1fwbncmbf1qj20aj03874o.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - Block用法和实现原理</title>
      <link href="//block-principle.html"/>
      <url>//block-principle.html</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;《Objective-C高级编程》是一本有趣又难懂的书，全书就讲了引用计数、Block、GCD三个概念，有趣是因为讲原理、实现的部分是其他iOS专业书籍里少有的。然而每个章节不读个三五遍还是比较难理解贯通。本文针对其中的Block部分做些简单的笔记记录，讲述Block的用法和部分实现原理，详细解说从原书中寻。<a id="more"></a></p><h1 id="Block概要"><a href="#Block概要" class="headerlink" title="Block概要"></a>Block概要</h1><ul><li>Block：带有自动变量的匿名函数。</li><li>匿名函数：没有函数名的函数，一对{}包裹的内容是匿名函数的作用域。</li><li>自动变量：栈上声明的一个变量不是静态变量和全局变量，是不可以在这个栈内声明的匿名函数中使用的，但在Block中却可以。</li></ul><p>&emsp;&emsp;虽然使用Block不用声明类，但是Block提供了类似Objective-C的类一样可以通过成员变量来保存作用域外变量值的方法，那些在Block的一对{}里使用到但却是在{}作用域以外声明的变量，就是Block截获的自动变量。</p><h1 id="Block常规概念"><a href="#Block常规概念" class="headerlink" title="Block常规概念"></a>Block常规概念</h1><h2 id="Block语法"><a href="#Block语法" class="headerlink" title="Block语法"></a>Block语法</h2><p>Block表达式语法：</p><blockquote><p>^ 返回值类型(参数列表){表达式}</p></blockquote><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ int (int count) &#123;</span><br><span class="line">    return count + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中，可省略部分有：</p><ul><li>返回值类型，例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ (int count) &#123;</span><br><span class="line">    return count + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>参数列表为空，则可省略，例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^ &#123;</span><br><span class="line">    NSLog(@&quot;No Parameter&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即最简模式语法为：</p><blockquote><p>^ {表达式}</p></blockquote><h2 id="Block类型变量"><a href="#Block类型变量" class="headerlink" title="Block类型变量"></a>Block类型变量</h2><p>声明Block类型变量语法：</p><blockquote><p>返回值类型(^ 变量名)(参数列表) = Block表达式</p></blockquote><p>例如，如下声明了一个变量名为blk的Block：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int (^blk)(int) = ^(int count) &#123;</span><br><span class="line">    return count + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>当Block类型变量作为函数的参数时，写作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)func:(int (^)(int))blk &#123;</span><br><span class="line">    NSLog(@&quot;Param:%@&quot;, blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>借助typedef，可简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^blk_k)(int);</span><br><span class="line"></span><br><span class="line">- (void)func:(blk_k)blk &#123;</span><br><span class="line">    NSLog(@&quot;Param:%@&quot;, blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Block类型变量作返回值时，写作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (int (^)(int))funcR &#123;</span><br><span class="line">    return ^(int count) &#123;</span><br><span class="line">        return count ++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>借助typedef，可简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^blk_k)(int);</span><br><span class="line"></span><br><span class="line">- (blk_k)funcR &#123;</span><br><span class="line">    return ^(int count) &#123;</span><br><span class="line">        return count ++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="截获自动变量值"><a href="#截获自动变量值" class="headerlink" title="截获自动变量值"></a>截获自动变量值</h2><p>Block表达式可截获所使用的自动变量的值。<br>截获：保存自动变量的瞬间值。<br>因为是“瞬间值”，所以声明Block之后，即便在Block外修改自动变量的值，也不会对Block内截获的自动变量值产生影响。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;In block, i = %d&quot;, i);</span><br><span class="line">&#125;;</span><br><span class="line">i = 20;                 // Block外修改变量i，也不影响Block内的自动变量</span><br><span class="line">blk();                  // i修改为20后才执行，打印: In block, i = 10</span><br><span class="line">NSLog(@&quot;i = %d&quot;, i);    // 打印：i = 20</span><br></pre></td></tr></table></figure></p><h2 id="block说明符号"><a href="#block说明符号" class="headerlink" title="__block说明符号"></a>__block说明符号</h2><p>&emsp;&emsp;自动变量截获的值为Block声明时刻的瞬间值，保存后就不能改写该值，如需对自动变量进行重新赋值，需要在变量声明前附加<code>__block</code>说明符，这时该变量称为<code>__block</code>变量。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block int i = 10;         // i为__block变量，可在block中重新赋值</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;In block, i = %d&quot;, i);</span><br><span class="line">&#125;;</span><br><span class="line">i = 20;</span><br><span class="line">blk();                      // 打印: In block, i = 20</span><br><span class="line">NSLog(@&quot;i = %d&quot;, i);        // 打印：i = 20</span><br></pre></td></tr></table></figure></p><h2 id="自动变量值为一个对象情况"><a href="#自动变量值为一个对象情况" class="headerlink" title="自动变量值为一个对象情况"></a>自动变量值为一个对象情况</h2><p>&emsp;&emsp;当自动变量为一个类的对象，且没有使用<code>__block</code>修饰时，虽然不可以在Block内对该变量进行重新赋值，但可以修改该对象的属性。<br>&emsp;&emsp;如果该对象是一个Mutable的对象，例如NSMutableArray，则还可以在Block内对NSMutableArray进行元素的增删，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array = [[NSMutableArray alloc] initWithObjects:@&quot;1&quot;, @&quot;2&quot;,nil ];</span><br><span class="line">NSLog(@&quot;Array Count:%ld&quot;, array.count);     // 打印Array Count:2</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    [array removeObjectAtIndex:0];          // Ok</span><br><span class="line">    //array = [NSNSMutableArray new];       // 没有__block修饰，编译失败！</span><br><span class="line">&#125;;</span><br><span class="line">blk();</span><br><span class="line">NSLog(@&quot;Array Count:%ld&quot;, array.count);     // 打印Array Count:1</span><br></pre></td></tr></table></figure></p><h1 id="Block实现原理"><a href="#Block实现原理" class="headerlink" title="Block实现原理"></a>Block实现原理</h1><h2 id="使用Clang"><a href="#使用Clang" class="headerlink" title="使用Clang"></a>使用Clang</h2><p>&emsp;&emsp;Block实际上是作为极普通的C语言源码来处理的：含有Block语法的源码首先被转换成C语言编译器能处理的源码，再作为普通的C源代码进行编译。<br>&emsp;&emsp;使用LLVM编译器的clang命令可将含有Block的Objective-C代码转换成C++的源代码，以探查其具体实现方式：<code>clang -rewrite-objc 源码文件名</code>。<br>&emap;&emsp;祝：如果使用该命令报错：<code>’UIKit/UIKit.h’ file not found</code>，可参考<a href="https://www.jianshu.com/p/43a09727eb2c" target="_blank" rel="noopener">Objective-C编译成C++代码报错</a>解决。</p><h2 id="Block结构"><a href="#Block结构" class="headerlink" title="Block结构"></a>Block结构</h2><p>使用Block的时候，编译器对Block语言进行了怎样的转换？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int count = 10;</span><br><span class="line">    void (^ blk)() = ^()&#123;</span><br><span class="line">        NSLog(@&quot;In Block:%d&quot;, count);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示的最简单的Block使用代码，经clang转换后，可得到以下几个部分（有代码删减和注释添加）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(</span><br><span class="line">    struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    int count = __cself-&gt;count; // bound by copy</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_64_vf2p_jz52yz7x4xtcx55yv0r0000gn_T_main_d2f8d2_mi_0, </span><br><span class="line">    count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个函数的实现，对应Block中{}内的内容，这些内容被当做了C语言函数来处理，函数参数中的__cself相当于Objective-C中的self。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc; // 描述Block大小、版本等信息</span><br><span class="line">  int count;</span><br><span class="line">  // 构造函数函数</span><br><span class="line">  __main_block_impl_0(void *fp,</span><br><span class="line">          struct __main_block_desc_0 *desc,</span><br><span class="line">          int _count,</span><br><span class="line">          int flags=0) : count(_count) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock; // 在函数栈上声明，则为_NSConcreteStackBlock</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>__main_block_impl_0</code>即为main()函数栈上的Block结构体，其中的__block_imp结构体声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;        // 指明对象的Class</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>__block_imp结构体，即为Block的结构体，可理解为Block的类结构。<br>再看下main()函数翻译的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int count = 10;</span><br><span class="line">    void (* blk)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, count));</span><br><span class="line">    </span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>去除掉复杂的类型转化，可简写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    int count = 10;</span><br><span class="line">    sturct __main_block_impl_0 *blk = &amp;__main_block_impl_0(__main_block_func_0,         // 函数指针</span><br><span class="line">                                                           &amp;__main_block_desc_0_DATA));                      // Block大小、版本等信息</span><br><span class="line">    </span><br><span class="line">    (*blk-&gt;FuncPtr)(blk);                         // 调用FuncPtr指向的函数，并将blk自己作为参数传入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由此看出，Block也是Objective-C中的对象。<br>Block有三种类（即__block_impl的isa指针指向的值，isa说明参考<a href="https://www.jianshu.com/p/41735c66dccb" target="_blank" rel="noopener">Objective-C isa 指针 与 runtime 机制</a>），根据Block对象创建时所处数据区不同而进行区别：</p><ul><li>_NSConcreteStackBlock：在栈上创建的Block对象</li><li>_NSConcreteMallocBlock：在堆上创建的Block对象</li><li>_NSConcreteGlobalBlock：全局数据区的Block对象</li></ul><h2 id="如何截获自动变量"><a href="#如何截获自动变量" class="headerlink" title="如何截获自动变量"></a>如何截获自动变量</h2><p>&emsp;&emsp;上部分介绍了Block的结构，和作为匿名函数的调用机制，那自动变量截获是发生在什么时候呢？<br>&emsp;&emsp;观察上节代码中<code>__main_block_impl_0</code>结构体（main栈上Block的结构体）的构造函数可以看到，栈上的变量count以参数的形式传入到了这个构造函数中，此处即为变量的自动截获。<br>&emsp;&emsp;因此可以这样理解：<code>__block_impl</code>结构体已经可以代表Block类了，但在栈上又声明了<code>__main_block_impl_0</code>结构体，对<code>__block_impl</code>进行封装后才来表示栈上的Block类，就是为了获取Block中使用到的栈上声明的变量（栈上没在Block中使用的变量不会被捕获），变量被保存在Block的结构体实例中。<br>&emsp;&emsp;所以再blk()执行之前，栈上简单数据类型的count无论发生什么变化，都不会影响到Block以参数形式传入而捕获的值。但这个变量是指向对象的指针时，是可以修改这个对象的属性的，只是不能为变量重新赋值。</p><h2 id="Block的存储域"><a href="#Block的存储域" class="headerlink" title="Block的存储域"></a>Block的存储域</h2><p>&emsp;&emsp;上文已提到，根据Block创建的位置不同，Block有三种类型，创建的Block对象分别会存储到栈、堆、全局数据区域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;Global Block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    blk();</span><br><span class="line">    NSLog(@&quot;%@&quot;,[blk class]);           // 打印：__NSGlobalBlock__</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;像上面代码块中的全局blk自然是存储在全局数据区，但注意在函数栈上创建的blk，如果没有截获自动变量，Block的结构实例还是会被设置在程序的全局数据区，而非栈上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    void (^blk)(void) = ^&#123;              // 没有截获自动变量的Block</span><br><span class="line">        NSLog(@&quot;Stack Block&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    NSLog(@&quot;%@&quot;,[blk class]);           // 打印:__NSGlobalBlock__</span><br><span class="line">    </span><br><span class="line">    int i = 1;</span><br><span class="line">    void (^captureBlk)(void) = ^&#123;       // 截获自动变量i的Block</span><br><span class="line">        NSLog(@&quot;Capture:%d&quot;, i);</span><br><span class="line">    &#125;;</span><br><span class="line">    captureBlk();</span><br><span class="line">    NSLog(@&quot;%@&quot;,[captureBlk class]);    // 打印：__NSMallocBlock__</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以看到截获了自动变量的Block打印的类是NSGlobalBlock，表示存储在全局数据区。但为什么捕获自动变量的Block打印的类却是设置在堆上的NSMallocBlock，而非栈上的NSStackBlock？这个问题稍后解释。</p><h2 id="Block复制"><a href="#Block复制" class="headerlink" title="Block复制"></a>Block复制</h2><p>&emsp;&emsp;配置在栈上的Block，如果其所属的栈作用域结束，该Block就会被废弃，对于超出Block作用域仍需使用Block的情况，Block提供了将Block从栈上复制到堆上的方法来解决这种问题，即便Block栈作用域已结束，但被拷贝到堆上的Block还可以继续存在。<br>&emsp;&emsp;复制到堆上的Block，将_NSConcreteMallocBlock类对象写入Block结构体实例的成员变量isa：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impl.isa = &amp;_NSConcreteMallocBlock;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在ARC有效时，大多数情况下编译器会进行判断，自动生成将Block从栈上复制到堆上的代码，以下几种情况栈上的Block会自动复制到堆上：</p><ul><li>调用Block的copy方法</li><li>将Block作为函数返回值时</li><li>将Block赋值给__strong修改的变量时</li><li>向Cocoa框架含有usingBlock的方法或者GCD的API传递Block参数时</li></ul><p>&emsp;&emsp;其他时候向方法的参数中传递Block时，需要手动调用copy方法复制Block。上一节的栈上截获了自动变量i的Block之所以在栈上创建，确实NSMallocBlock类，就是因为这个Block对象赋值给了<code>__strong</code>修饰的变量captureBlk（<code>__strong</code>是ARC下对象的默认修饰符）。<br>&emsp;&emsp;因为上面四条规则，在ARC下其实很少见到_NSConcreteStackBlock类的Block，大多数情况编译器都保证了Block是在堆上创建的，如下代码所示，仅最后一行代码直接使用一个不赋值给变量的Block，它的类才是NSStackBlock：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int count = 0;</span><br><span class="line">    blk_t blk = ^()&#123;</span><br><span class="line">        NSLog(@&quot;In Stack:%d&quot;, count);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;blk&apos;s Class:%@&quot;, [blk class]);                                      // 打印：blk&apos;s Class:__NSMallocBlock__</span><br><span class="line">    NSLog(@&quot;Global Block:%@&quot;, [^&#123;NSLog(@&quot;Global Block&quot;);&#125; class]);              // 打印：Global Block:__NSGlobalBlock__</span><br><span class="line">    NSLog(@&quot;Copy Block:%@&quot;, [[^&#123;NSLog(@&quot;Copy Block:%d&quot;,count);&#125; copy] class]);  // 打印：Copy Block:__NSMallocBlock__</span><br><span class="line">    NSLog(@&quot;Stack Block:%@&quot;, [^&#123;NSLog(@&quot;Stack Block:%d&quot;,count);&#125; class]);       // 打印：Stack Block:__NSStackBlock__</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;关于ARC下和MRC下Block自动copy的区别，查看<a href="https://www.zybuluo.com/MicroCai/note/49713" target="_blank" rel="noopener">Block 小测验</a>里的几道题目就能区分了。<br>&emsp;&emsp;另外，原书存在ARC和MRC混合讲解、区分不明的情况，比如书中几个使用栈上对象导致crash的例子是MRC条件下才会发生的，但书中没做特殊说明。</p><h2 id="使用-block发生了什么"><a href="#使用-block发生了什么" class="headerlink" title="使用__block发生了什么"></a>使用__block发生了什么</h2><p>&emsp;&emsp;Block捕获的自动变量添加<code>__block</code>说明符，就可在Block内读和写该变量，也可以在原来的栈上读写该变量。<br>&emsp;&emsp;自动变量的捕获保证了栈上的自动变量被销毁后，Block内仍可使用该变量。<code>__block</code>保证了栈上和Block内（通常在堆上）可以访问和修改“同一个变量”，<code>__block</code>是如何实现这一功能的？<br>&emsp;&emsp;<code>__block</code>发挥作用的原理：将栈上用<code>__block</code>修饰的自动变量封装成一个结构体，让其在堆上创建，以方便从栈上或堆上访问和修改同一份数据。<br>验证过程：<br>现在对刚才的代码段，加上<code>__block</code>说明符，并在block内外读写变量count。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    __block int count = 10;</span><br><span class="line">    void (^ blk)() = ^()&#123;</span><br><span class="line">        count = 20;</span><br><span class="line">        NSLog(@&quot;In Block:%d&quot;, count);       // 打印：In Block:20</span><br><span class="line">    &#125;;</span><br><span class="line">    count ++;</span><br><span class="line">    NSLog(@&quot;Out Block:%d&quot;, count);          // 打印：Out Block:11</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将上面的代码段clang，发现Block的结构体<code>__main_block_impl_0</code>结构如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_count_0 *count;     // by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_count_0 *_count, int flags=0) : count(_count-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最大的变化就是count变量不再是int类型了，count变成了一个指向<code>__Block_byref_count_0</code>结构体的指针，<code>__Block_byref_count_0</code>结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_count_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_count_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>它保存了int count变量，还有一个指向<code>__Block_byref_count_0</code>实例的指针<code>__forwarding</code>，通过下面两段代码<code>__forwarding</code>指针的用法可以知道，该指针其实指向的是对象自身：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Block的执行函数</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_count_0 *count = __cself-&gt;count;    // bound by ref</span><br><span class="line"></span><br><span class="line">        (count-&gt;__forwarding-&gt;count) = 20;          // 对应count = 20;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_64_vf2p_jz52yz7x4xtcx55yv0r0000gn_T_main_fafeeb_mi_0, </span><br><span class="line">        (count-&gt;__forwarding-&gt;count));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// main函数</span><br><span class="line">int main() &#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_count_0 count = &#123;(void*)0,</span><br><span class="line">    (__Block_byref_count_0 *)&amp;count, </span><br><span class="line">    0, </span><br><span class="line">    sizeof(__Block_byref_count_0), </span><br><span class="line">    10&#125;;</span><br><span class="line">    </span><br><span class="line">    void (* blk)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, </span><br><span class="line">    &amp;__main_block_desc_0_DATA, </span><br><span class="line">    (__Block_byref_count_0 *)&amp;count, </span><br><span class="line">    570425344));</span><br><span class="line">    </span><br><span class="line">    (count.__forwarding-&gt;count) ++;         // 对应count ++;</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_64_vf2p_jz52yz7x4xtcx55yv0r0000gn_T_main_fafeeb_mi_1, </span><br><span class="line">    (count.__forwarding-&gt;count));</span><br><span class="line">    </span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要通过<code>__forwarding</code>指针完成对count变量的读写修改？<br>为了保证无论是在栈上还是在堆上，都能通过<code>__forwarding</code>指针找到堆上创建的count这个<code>__main_block_func_0</code>结构体，以完成对count-&gt;count（第一个count是<code>__main_block_func_0</code>对象，第二个count是int类型变量）的访问和修改。示意图如下：<br><img src="http://pic.cloverkim.com/006tNc79gy1g03s2zred9j30xc0o1408.jpg" alt=""></p><h2 id="Block的循环引用"><a href="#Block的循环引用" class="headerlink" title="Block的循环引用"></a>Block的循环引用</h2><p>&emsp;&emsp;Block的循环引用原理和解决方法大家都比较熟悉，此处将结合上文的介绍，介绍一种不常用的解决Block循环引用的方法和一种借助Block参数该问题的方法。<br>&emsp;&emsp;Block循环引用的原因：一个对象A有Block类型的属性，从而持有这个Block，如果Block的代码块中使用到这个对象A，或者仅仅是用到A对象的属性，会使Block也持有A对象，导致两者互相持有，不能在作用域结束后正常释放。<br>&emsp;&emsp;解决原理：对象A照常持有Block，但Block不能强引用持有对象A以打破循环。</p><h3 id="第一种解决方法"><a href="#第一种解决方法" class="headerlink" title="第一种解决方法"></a>第一种解决方法</h3><p>&emsp;&emsp;对Block内部使用的对象A使用<code>__weak</code>进行修饰，Block对对象A弱引用打破循环。有以下三种常用形式：</p><ul><li><p>使用__weak ClassName</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block XXViewController *weakSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,weakSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用__weak typeof(self)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,weakSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Reactive Cocoa中的@weakify和@strongify</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,self);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  其原理参考（<a href="https://www.jianshu.com/p/3d6c4416db5e" target="_blank" rel="noopener">@weakify, @strongify</a>），已经简便实现参考（<a href="https://blog.csdn.net/u014773226/article/details/54617716" target="_blank" rel="noopener">@weak - @strong 宏的实现</a>）。</p></li></ul><h3 id="第二种解决方法"><a href="#第二种解决方法" class="headerlink" title="第二种解决方法"></a>第二种解决方法</h3><p>&emsp;&emsp;对Block内要使用的对象A使用<code>__block</code>进行修饰，并在代码块内，使用完<code>__block</code>变量后将其设为nil，并且该block必须至少执行一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block XXController *blkSelf = self;</span><br><span class="line">self.blk = ^&#123;</span><br><span class="line">    NSLog(@&quot;In Block : %@&quot;,blkSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注意上述代码仍存在内存泄漏，因为：</p><ul><li>XXController对象持有Block对象blk</li><li>blk对象持有<code>__block</code>变量blkSelf</li><li><p><code>__block</code>变量blkSelf持有XXController对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block XXController *blkSelf = self;</span><br><span class="line">    self.blk = ^&#123;</span><br><span class="line">        NSLog(@&quot;In Block : %@&quot;,blkSelf);</span><br><span class="line">        blkSelf = nil;      // 不能省略</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    self.blk();             // 该block必须执行一次，否则还是内存泄露</span><br></pre></td></tr></table></figure></li></ul><p>在block代码块内，使用完<code>__block</code>变量后将其设为nil，并且该block必须至少执行一次后，不存在内存泄漏，因为此时：</p><ul><li>XXController对象持有Block对象blk</li><li>blk对象持有<code>__block</code>变量blkSelf（类型为编译器创建的结构体）</li><li><code>__block</code>变量blkSelf在执行blk()之后被设置为nil（<code>__block</code>变量结构体的<code>__forwarding</code>指针指向了nil），不再持有XXController对象，打破循环。</li></ul><p>&emsp;&emsp;第二种使用<code>__block</code>打破循环的方法，优点是：</p><ul><li>可通过<code>__bloc</code>k变量动态控制持有XXController对象的时间，运行时决定是否将nil或其他变量赋值给<code>__block</code>变量</li><li>不能使用<code>__wea</code>k的系统中，使用<code>__unsafe)unretaines</code>来代替<code>__weak</code>打破循环可能由野指针问题，使用<code>__block</code>则可避免该问题。</li></ul><p>&emsp;&emsp;其缺点也明显：</p><ul><li>必须手动保证<code>__block</code>变量最后设置为nil</li><li>block必须执行一次，否则<code>__block</code>不为nil循环引用仍存在</li></ul><p>&emsp;&emsp;因此，还是避免使用第二种不常用方式，直接使用<code>__weak</code>打破Block循环引用。</p><h3 id="第三种解决方法"><a href="#第三种解决方法" class="headerlink" title="第三种解决方法"></a>第三种解决方法</h3><p>&emsp;&emsp;将在Block内要使用到的对象（一般为self），以Block参数的形式传入，Block就不会捕获该对象，而将其作为参数使用，其生命周期系统的栈自动管理，不造成内存泄漏。<br>即使用原来<code>__weak</code>的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">    self.blk = ^&#123;</span><br><span class="line">        __strong typeof(self) strongSelf = weakSelf;</span><br><span class="line">        NSLog(@&quot;Use Property:%@&quot;, strongSelf.name);</span><br><span class="line">        //……</span><br><span class="line">    &#125;;</span><br><span class="line">    self.blk();</span><br></pre></td></tr></table></figure></p><p>改为Block传参写法后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.blk = ^(UIViewController *vc) &#123;</span><br><span class="line">        NSLog(@&quot;Use Property:%@&quot;, vc.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    self.blk(self);</span><br></pre></td></tr></table></figure></p><p>优点:</p><ul><li>简化了两行代码，更优雅</li><li>更明确的API设计：告诉API使用者，该方法多的Block直接使用传进来的参数对象，不会造成循环引用，不用调用者再使用weak避免循环引用。</li></ul><p>该种用法的详细思路，和clang后的数据结构，可参考（<a href="https://github.com/ChenYilong/iOSBlog/blob/master/Tips/Heap-Stack%20Dance/Heap-Stack%20Dance.md" target="_blank" rel="noopener">Heap-Stack Dance</a>）</p><h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p>&emsp;&emsp;本文转自<a href="https://www.jianshu.com/p/d28a5633b963" target="_blank" rel="noopener">简书 - kamous - iOS Block用法和实现原理</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 基础 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法学习 - 冒泡排序</title>
      <link href="//bubble_sort.html"/>
      <url>//bubble_sort.html</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>比较相邻的元素，如果第一个比第二个大，就交换他们两个。</li><li>对每一组相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<a id="more"></a></li><li>针对所有的元素重复以后的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到满意任何一对数字需要比较，则序列最终有序。<br><img src="http://pic.cloverkim.com/749c46aagy1fvrm3x9pj5j20iu08xq4b.jpg" alt="" title="步骤图"></li></ol><h2 id="Swift实现"><a href="#Swift实现" class="headerlink" title="Swift实现"></a>Swift实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func bubble_sort(_ array: inout [Int]) &#123;</span><br><span class="line">    for i in 0..&lt;array.count - 1 &#123;</span><br><span class="line">        for j in 0..&lt;array.count - i - 1 &#123;</span><br><span class="line">            if array[j] &gt; array[j + 1] &#123;</span><br><span class="line">                array.swapAt(j, j + 1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arrays: [Int] = [3, 6, 4, 2, 9, 8, 5]</span><br><span class="line">bubble_sort(&amp;arrays)</span><br></pre></td></tr></table></figure><h3 id="代码优化："><a href="#代码优化：" class="headerlink" title="代码优化："></a>代码优化：</h3><p>在某些情况下，循环还未终止，整个数组已经排好序，此时应及时终止循环。（冒泡每次都会比较相邻两个数并交换次数不对的组，若一次循环后，都没进行交换，则判断为已完成排序）</p><h3 id="优化代码实现："><a href="#优化代码实现：" class="headerlink" title="优化代码实现："></a>优化代码实现：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func bubble_sort(_ array: inout [Int]) &#123;</span><br><span class="line">    var isChanged = false</span><br><span class="line">    for i in 0..&lt;array.count - 1 &#123;</span><br><span class="line">        isChanged = false</span><br><span class="line">        for j in 0..&lt;array.count - i - 1 &#123;</span><br><span class="line">            if array[j] &gt; array[j + 1] &#123;</span><br><span class="line">                array.swapAt(j, j + 1)</span><br><span class="line">                isChanged = true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!isChanged) &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li>冒泡排序的时间复杂度为O(n^2)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - __weak和__block的理解</title>
      <link href="//block-weak-difference.html"/>
      <url>//block-weak-difference.html</url>
      
        <content type="html"><![CDATA[<h1 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h1><p>&emsp;&emsp;在block里可以访问局部变量，但不能修改局部变量。这是因为当局部变量在block中使用时，实际上使用的变量是在block中复制的数据，所以在block中修改的变量并不能修改block外面的变量值。这里要注意的是可变数组或者字典在block中添加或删除数据时，并不用<code>__block</code>修饰，因为在block里使用这些数组时，数组的指针并没有发生变化，仅仅是内存的内容发生了变化。<a id="more"></a><br>关于__block在MRC和ARC模式下的区别：</p><ul><li><code>__block</code>在MRC下有两个作用：<ul><li>允许在block内访问和修改局部变量</li><li>禁止block对所引用的对象进行隐式strong操作</li></ul></li><li><code>__block</code>在ARC下的作用：<ul><li>允许在block内访问和修改局部变量</li></ul></li></ul><h1 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h1><p>&emsp;&emsp;在block中，block会对其对象强引用，对于self也会形成强引用，而self本身对于block也是强引用，这样就会造成循环引用的问题，这时候就需要用<code>__weak</code>打破循环，使对象弱引用。或者在block执行完后，将block置为nil也可以打破循环引用，但是该方法会使block只会执行一次，要是再次使用的话，就要重新赋值。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul><li><code>__block</code>不管是ARC还是MRC下都能使用，可以修饰对象，还可以修饰基本数据类型。</li><li><code>__weak</code>只能在ARC下使用，只能修饰对象，不能修饰基本数据类型。</li><li><code>__block</code>对象可以在block中被重新赋值，<code>__weak</code>不可以。</li><li><code>__block</code>对象在ARC下可能会导致循环引用，非ARC下会避免循环引用；<code>__weak</code>只能在ARC下使用，可以避免循环引用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - Category和Extension的区别</title>
      <link href="//category-extension-difference.html"/>
      <url>//category-extension-difference.html</url>
      
        <content type="html"><![CDATA[<h1 id="区别一"><a href="#区别一" class="headerlink" title="区别一"></a>区别一</h1><ul><li>Category<ul><li>专门用来给类添加新的方法</li><li>不能给类添加成员属性（其实是可以通过runtime给分类添加属性）</li><li>分类中用<code>@property</code>定义变量，只会生成变量的getter、setter方法的声明，不能生成方法实现和带下划线的成员变量。<a id="more"></a></li></ul></li><li>Extension<ul><li>可以说是特殊的分类，也称作匿名分类</li><li>可以给类添加成员属性，但是是私有变量</li><li>可以给类添加方法，也是私有方法</li></ul></li></ul><h1 id="区别二"><a href="#区别二" class="headerlink" title="区别二"></a>区别二</h1><p>&emsp;&emsp;虽然有人说Extension是一个特殊的Category，也有人将Extension成为匿名分类，但是两者的区别很大。</p><ul><li><p>Category</p><ul><li>是运行期决定的</li><li>类扩展可以添加实例变量，分类不能添加实例变量（原因：因为在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局，这对编译性语言是灾难性的。）</li></ul></li><li><p>Extension</p><ul><li>在编译器决定，是类的一部分，在编译器和头文件的<code>@interface</code>和实现文件里的<code>@implement</code>一起形成了一个完整的类。</li><li>伴随着类的产生而产生，也随着类的消失而消失。</li><li>Extension一般用来隐藏类的私有消息，必须有一个类的源码才能添加一个类的Extension，所以对于系统的一个类，比如NSString，就无法添加类扩展。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SDWebImage源码解析（三）</title>
      <link href="//SDWebImage-source-code-analysis-3.html"/>
      <url>//SDWebImage-source-code-analysis-3.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;在上一篇文章<a href="http://cloverkim.com/SDWebImage-source-code-analysis-2.html">SDWebImage源码解析（二）</a>中，主要详细分析了SDWebImage的UIView+WebCache、UIWebImageManager两个核心类。在本文中，将会继续分析SDWebImage的SDImageCache、SDWebImageDownloader和SDWebImageDownloaderOperation核心类。<a id="more"></a></p><h1 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h1><h2 id="核心类分析"><a href="#核心类分析" class="headerlink" title="核心类分析"></a>核心类分析</h2><h3 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h3><p>&emsp;&emsp;SDImageCache是SDWebImage的缓存中心，分为三部分组成：memory内存缓存、disk硬盘缓存和无缓存组成。具体实现可以总结为以下几点：</p><ul><li>当接收到<code>UIApplicationDidReceiveMemoryWarningNotification</code>通知时，会删除内存中缓存的图片</li><li>当接收到<code>UIApplicationWillTerminateNotification</code>通知时，会通过<code>deleteOldFiles</code>方法删除老的图片。具体删除规则如下：<ul><li>缓存大小、过期日期、是否解压缩缓存、是否允许内存缓存都是通过SDImageCacheConfig这个对象类配置的</li><li>首先会迭代缓存目录下的所有文件，对于大于一周的图片数据全部删除</li><li>记录缓存目录的所有大小，如果当前缓存大于默认缓存，则按照创建日期开始删除图片缓存，直接缓存大小小于默认的缓存大小。</li></ul></li><li>当接收到<code>UIApplicationDidEnterBackgroundNotification</code>通知时，会调用<code>backgroundDeleteOldFiles</code>方法来清理缓存数据</li><li>定义了一系列方法来处理图片的获取、缓存、移除操作。主要有以下几个方法：<ul><li><code>queryCacheOperationForKey</code>：查询指定key对应的缓存图片，先从内存查找，然后从磁盘查找</li><li><code>removeImageForKey</code>：移除指定的缓存图片</li><li><code>diskImageDataBySearchingAllPathsForKey</code>：在磁盘上查找指定key对应的图片</li><li><code>storeImageDataToDisk</code>：把指定的图片数据出入磁盘</li></ul></li><li>通过<code>cachedFileNameForKey</code>方法获取一张图片对应的MD5加密的缓存名字</li></ul><p>下面来看下SDImageCache的具体实现：<br>SDImageCache.h：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">    SDImageCacheTypeNone,       // 无缓存</span><br><span class="line">    SDImageCacheTypeDisk,       // 磁盘缓存</span><br><span class="line">    SDImageCacheTypeMemory      // 内存缓存</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface SDImageCache : NSObject</span><br><span class="line">#pragma mark - Properties</span><br><span class="line"></span><br><span class="line">// 缓存配置对象，包含所有配置项</span><br><span class="line">@property (nonatomic, nonnull, readonly) SDImageCacheConfig *config;</span><br><span class="line"></span><br><span class="line">// 设置内存容量大小</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCost;</span><br><span class="line"></span><br><span class="line">// 设置内存缓存最大值限制</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCountLimit;</span><br></pre></td></tr></table></figure></p><p>SDImageCache.m：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br></pre></td><td class="code"><pre><span class="line">/// 添加一个只读的缓存路径</span><br><span class="line">- (void)addReadOnlyCachePath:(nonnull NSString *)path &#123;</span><br><span class="line">    if (!self.customPaths) &#123;</span><br><span class="line">        self.customPaths = [NSMutableArray new];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (![self.customPaths containsObject:path]) &#123;</span><br><span class="line">        [self.customPaths addObject:path];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 获取给定key的缓存路径，需要一个根缓存路径</span><br><span class="line">- (nullable NSString *)cachePathForKey:(nullable NSString *)key inPath:(nonnull NSString *)path &#123;</span><br><span class="line">    NSString *filename = [self cachedFileNameForKey:key];</span><br><span class="line">    return [path stringByAppendingPathComponent:filename];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 获取给定key的默认缓存路径</span><br><span class="line">- (nullable NSString *)defaultCachePathForKey:(nullable NSString *)key &#123;</span><br><span class="line">    return [self cachePathForKey:key inPath:self.diskCachePath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 根据key值生成文件名：采用MD5加密的方式</span><br><span class="line">- (nullable NSString *)cachedFileNameForKey:(nullable NSString *)key &#123;</span><br><span class="line">    const char *str = key.UTF8String;</span><br><span class="line">    if (str == NULL) &#123;</span><br><span class="line">        str = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">    NSURL *keyURL = [NSURL URLWithString:key];</span><br><span class="line">    NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</span><br><span class="line">    NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,</span><br><span class="line">                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],</span><br><span class="line">                          r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, ext]];</span><br><span class="line">    return filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 生成磁盘路径</span><br><span class="line">- (nullable NSString *)makeDiskCachePath:(nonnull NSString*)fullNamespace &#123;</span><br><span class="line">    NSArray&lt;NSString *&gt; *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);</span><br><span class="line">    return [paths[0] stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 根据key去异步缓存image，toDisk为NO时不存储在磁盘</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">         imageData:(nullable NSData *)imageData</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    if (!image || !key) &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 缓存到内存</span><br><span class="line">    if (self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(image);</span><br><span class="line">        [self.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 缓存到磁盘，采用异步操作</span><br><span class="line">    if (toDisk) &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                NSData *data = imageData;</span><br><span class="line">                if (!data &amp;&amp; image) &#123;</span><br><span class="line">                    // 如果没有data，则采用png的格式进行format</span><br><span class="line">                    SDImageFormat format;</span><br><span class="line">                    if (SDCGImageRefContainsAlpha(image.CGImage)) &#123;</span><br><span class="line">                        format = SDImageFormatPNG;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        format = SDImageFormatJPEG;</span><br><span class="line">                    &#125;</span><br><span class="line">                    data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format];</span><br><span class="line">                &#125;</span><br><span class="line">                [self _storeImageDataToDisk:data forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (completionBlock) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completionBlock();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 利用key缓存图片的data</span><br><span class="line">- (void)storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (!imageData || !key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        [self _storeImageDataToDisk:imageData forKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)_storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (!imageData || !key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 如果文件中不存在磁盘缓存路径，则创建</span><br><span class="line">    if (![self.fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">        [self.fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取该key的缓存路径</span><br><span class="line">    NSString *cachePathForKey = [self defaultCachePathForKey:key];</span><br><span class="line">    // 将缓存路径转化为url</span><br><span class="line">    NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line">    </span><br><span class="line">    [imageData writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil];</span><br><span class="line">    </span><br><span class="line">    // 判断是否关闭了iCloud备份</span><br><span class="line">    if (self.config.shouldDisableiCloud) &#123;</span><br><span class="line">        [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 异步检查图片是否缓存在磁盘中</span><br><span class="line">- (void)diskImageExistsWithKey:(nullable NSString *)key completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        BOOL exists = [self _diskImageDataExistsWithKey:key];</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(exists);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)diskImageDataExistsWithKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    __block BOOL exists = NO;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        exists = [self _diskImageDataExistsWithKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return exists;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Make sure to call form io queue by caller</span><br><span class="line">- (BOOL)_diskImageDataExistsWithKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL exists = [self.fileManager fileExistsAtPath:[self defaultCachePathForKey:key]];</span><br><span class="line">    </span><br><span class="line">    // fallback because of https://github.com/rs/SDWebImage/pull/976 that added the extension to the disk file name</span><br><span class="line">    // checking the key with and without the extension</span><br><span class="line">    if (!exists) &#123;</span><br><span class="line">        exists = [self.fileManager fileExistsAtPath:[self defaultCachePathForKey:key].stringByDeletingPathExtension];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return exists;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 在内存缓存中查找对应key的图片</span><br><span class="line">- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key &#123;</span><br><span class="line">    return [self.memCache objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 在磁盘缓存中查询对应key的图片，并且如果允许内存缓存则在内存中缓存</span><br><span class="line">- (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key &#123;</span><br><span class="line">    UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">    if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">        [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return diskImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 在缓存中查询对应key的图片</span><br><span class="line">- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key &#123;</span><br><span class="line">    // First check the in-memory cache...</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Second check the disk cache...</span><br><span class="line">    image = [self imageFromDiskCacheForKey:key];</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 根据key在磁盘缓存中搜索图片data</span><br><span class="line">- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:(nullable NSString *)key &#123;</span><br><span class="line">    NSString *defaultPath = [self defaultCachePathForKey:key];</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfFile:defaultPath options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // fallback because of https://github.com/rs/SDWebImage/pull/976 that added the extension to the disk file name</span><br><span class="line">    // checking the key with and without the extension</span><br><span class="line">    data = [NSData dataWithContentsOfFile:defaultPath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSArray&lt;NSString *&gt; *customPaths = [self.customPaths copy];</span><br><span class="line">    for (NSString *path in customPaths) &#123;</span><br><span class="line">        NSString *filePath = [self cachePathForKey:key inPath:path];</span><br><span class="line">        NSData *imageData = [NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // fallback because of https://github.com/rs/SDWebImage/pull/976 that added the extension to the disk file name</span><br><span class="line">        // checking the key with and without the extension</span><br><span class="line">        imageData = [NSData dataWithContentsOfFile:filePath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key &#123;</span><br><span class="line">    NSData *data = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    return [self diskImageForKey:key data:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 根据key在磁盘缓存中搜索图片</span><br><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key data:(nullable NSData *)data &#123;</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:data];</span><br><span class="line">        // 根据图片的scale或图片中的图片组，重新计算返回一张新图片</span><br><span class="line">        image = [self scaledImageForKey:key image:image];</span><br><span class="line">        if (self.config.shouldDecompressImages) &#123;</span><br><span class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;data options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(NO)&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSOperation *)queryCacheOperationForKey:(NSString *)key done:(SDCacheQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    return [self queryCacheOperationForKey:key options:0 done:doneBlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 在缓存中查询对应key的图片信息</span><br><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options done:(nullable SDCacheQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(nil, nil, SDImageCacheTypeNone);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 首先从内存中进行查找</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));</span><br><span class="line">    if (shouldQueryMemoryOnly) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(image, nil, SDImageCacheTypeMemory);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    void(^queryDiskBlock)(void) =  ^&#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            // do not call the completion if cancelled</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            UIImage *diskImage;</span><br><span class="line">            SDImageCacheType cacheType = SDImageCacheTypeDisk;</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                // the image is from in-memory cache</span><br><span class="line">                diskImage = image;</span><br><span class="line">                cacheType = SDImageCacheTypeMemory;</span><br><span class="line">            &#125; else if (diskData) &#123;</span><br><span class="line">                // decode image data only if in-memory cache missed</span><br><span class="line">                diskImage = [self diskImageForKey:key data:diskData];</span><br><span class="line">                if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                    NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                    // 把从磁盘取出来的缓存图片加入到内存缓存中</span><br><span class="line">                    [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 图片处理完毕后回调Block</span><br><span class="line">            if (doneBlock) &#123;</span><br><span class="line">                if (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">                    doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    if (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">        queryDiskBlock();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, queryDiskBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 删除缓存中指定key的图片</span><br><span class="line">- (void)removeImageForKey:(nullable NSString *)key withCompletion:(nullable SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    [self removeImageForKey:key fromDisk:YES withCompletion:completion];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 删除缓存中指定key的图片，磁盘为可选项</span><br><span class="line">- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    if (key == nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果内存也缓存了，则删除内存缓存</span><br><span class="line">    if (self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        [self.memCache removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fromDisk) &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            [self.fileManager removeItemAtPath:[self defaultCachePathForKey:key] error:nil];</span><br><span class="line">            </span><br><span class="line">            if (completion) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completion();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else if (completion)&#123;</span><br><span class="line">        completion();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 清空所有的内存缓存</span><br><span class="line">- (void)clearMemory &#123;</span><br><span class="line">    [self.memCache removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 异步清除所有的磁盘缓存</span><br><span class="line">- (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        [self.fileManager removeItemAtPath:self.diskCachePath error:nil];</span><br><span class="line">        [self.fileManager createDirectoryAtPath:self.diskCachePath</span><br><span class="line">                withIntermediateDirectories:YES</span><br><span class="line">                                 attributes:nil</span><br><span class="line">                                      error:NULL];</span><br><span class="line"></span><br><span class="line">        if (completion) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completion();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)deleteOldFiles &#123;</span><br><span class="line">    [self deleteOldFilesWithCompletionBlock:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 异步清除所有失效的缓存图片</span><br><span class="line">- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line">        NSArray&lt;NSString *&gt; *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey];</span><br><span class="line"></span><br><span class="line">        // 利用目录枚举器遍历指定磁盘缓存路径目录下的文件，从而获得文件大小、缓存时间等信息.</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                 errorHandler:NULL];</span><br><span class="line"></span><br><span class="line">        // 计算过期时间，默认1周以前的缓存文件是过期失效</span><br><span class="line">        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge];</span><br><span class="line">        // 用以保存遍历的文件url</span><br><span class="line">        NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary];</span><br><span class="line">        NSUInteger currentCacheSize = 0;</span><br><span class="line"></span><br><span class="line">        // Enumerate all of the files in the cache directory.  This loop has two purposes:</span><br><span class="line">        //</span><br><span class="line">        //  1. Removing files that are older than the expiration date.</span><br><span class="line">        //  2. Storing file attributes for the size-based cleanup pass.</span><br><span class="line">        // 用以保存删除的文件url</span><br><span class="line">        NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init];</span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSError *error;</span><br><span class="line">            // 获取指定url对应文件的指定三种属性的key和value</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</span><br><span class="line"></span><br><span class="line">            // Skip directories and errors.</span><br><span class="line">            if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 获取指定url文件对应的修改日期;</span><br><span class="line">            NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];</span><br><span class="line">            // 如果修改日期大于指定日期，则加入要移除的数组中</span><br><span class="line">            if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 获取指定的url对应的文件大小，并把url与对应大小存入一个字典中.</span><br><span class="line">            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">            currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line">            cacheFiles[fileURL] = resourceValues;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 循环遍历删除所有最后修改日期大于指定日期的所有文件</span><br><span class="line">        for (NSURL *fileURL in urlsToDelete) &#123;</span><br><span class="line">            [self.fileManager removeItemAtURL:fileURL error:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果当前缓存的大小超过了默认大小，则按照日期删除，直到缓存大小小于默认大小的一半.</span><br><span class="line">        if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123;</span><br><span class="line">            // Target half of our maximum cache size for this cleanup pass.</span><br><span class="line">            const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2;</span><br><span class="line"></span><br><span class="line">            // Sort the remaining cache files by their last modification time (oldest first).</span><br><span class="line">            NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent</span><br><span class="line">                                                                     usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</span><br><span class="line">                                                                         return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];</span><br><span class="line">                                                                     &#125;];</span><br><span class="line"></span><br><span class="line">            // 循环遍历删除缓存，直到缓存大小是默认缓存大小的一半.</span><br><span class="line">            for (NSURL *fileURL in sortedFiles) &#123;</span><br><span class="line">                if ([self.fileManager removeItemAtURL:fileURL error:nil]) &#123;</span><br><span class="line">                    NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">                    currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line"></span><br><span class="line">                    if (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 在主线程中进行回调</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 应用进入后台的时候，将会接收到通知，并调用该方法清除过期图片</span><br><span class="line">- (void)backgroundDeleteOldFiles &#123;</span><br><span class="line">    Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    UIApplication *application = [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">    __block UIBackgroundTaskIdentifier bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        // 当任务非正常终止的时候，做清理工作.</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // Start the long-running task and return immediately.</span><br><span class="line">    [self deleteOldFilesWithCompletionBlock:^&#123;</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 得到磁盘缓存的大小</span><br><span class="line">- (NSUInteger)getSize &#123;</span><br><span class="line">    __block NSUInteger size = 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        for (NSString *fileName in fileEnumerator) &#123;</span><br><span class="line">            NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *attrs = [self.fileManager attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">            size += [attrs fileSize];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 得到在磁盘缓存中图片的数量</span><br><span class="line">- (NSUInteger)getDiskCount &#123;</span><br><span class="line">    __block NSUInteger count = 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        count = fileEnumerator.allObjects.count;</span><br><span class="line">    &#125;);</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 异步计算磁盘缓存的大小</span><br><span class="line">- (void)calculateSizeWithCompletionBlock:(nullable SDWebImageCalculateSizeBlock)completionBlock &#123;</span><br><span class="line">    NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line"></span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        NSUInteger fileCount = 0;</span><br><span class="line">        NSUInteger totalSize = 0;</span><br><span class="line"></span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:@[NSFileSize]</span><br><span class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                 errorHandler:NULL];</span><br><span class="line"></span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSNumber *fileSize;</span><br><span class="line">            [fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:NULL];</span><br><span class="line">            totalSize += fileSize.unsignedIntegerValue;</span><br><span class="line">            fileCount += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock(fileCount, totalSize);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h3><p>SDWebImageDownloader是一个单例对象，主要功能可以概括为：</p><ul><li>通过SDWebImageDownloaderOptions枚举来设置图片从网络加载的不同情况</li><li>定义并管理了NSURLSession对象，通过这个对象来做网络请求，并且实现对象的代理方法</li><li>定义了一个NSURLRequest对象，并且管理请求头的拼装</li><li>对于每一个网络请求，通过一个SDWebImageDownloaderOperation自定义的NSOperation来操作网络下载</li><li>管理网络加载过程和完成时的回调工作。</li></ul><p>先来看下<code>SDWebImageDownloader.h</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) &#123;</span><br><span class="line">    // 将下载放到低队列优先级和任务优先级中</span><br><span class="line">    SDWebImageDownloaderLowPriority = 1 &lt;&lt; 0,</span><br><span class="line">    </span><br><span class="line">    // 支持渐进式下载，在下载过程中会像浏览器那样逐步显示图片</span><br><span class="line">    SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1,</span><br><span class="line"></span><br><span class="line">    // 默认情况下，http请求阻止使用NSURLCache对象，如果设置了该枚举值，则NSURLCache会被http请求使用</span><br><span class="line">    SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2,</span><br><span class="line"></span><br><span class="line">    // 如果image/imageData是从NSURLCache返回的，则completion回调会返回nil</span><br><span class="line">    SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3,</span><br><span class="line">    </span><br><span class="line">    // 如果App进入后台时，是否继续下载。这个是通过在后台申请时间来完成这个操作。如果指定的时间内没有完成，则直接取消下载</span><br><span class="line">    SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4,</span><br><span class="line"></span><br><span class="line">    // 处理缓存在 NSHTTPCookieStore 对象里面的cookie</span><br><span class="line">    SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5,</span><br><span class="line"></span><br><span class="line">    // 允许非信任的SSL证书请求</span><br><span class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6,</span><br><span class="line"></span><br><span class="line">    // 把任务添加到队列的最前面</span><br><span class="line">    SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7,</span><br><span class="line">    </span><br><span class="line">    // 根据设备的内存限制调整图片的尺寸到合适的大小</span><br><span class="line">    SDWebImageDownloaderScaleDownLargeImages = 1 &lt;&lt; 8,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface SDWebImageDownloader : NSObject</span><br><span class="line"></span><br><span class="line">// 当图片下载完成，解压缩后再缓存，这样可以提升性能但会占用更多的内存。</span><br><span class="line">// 默认为YES，如果因为过多的内存消耗导致崩溃，则将此设置为NO</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">// 最大并行下载的数量</span><br><span class="line">@property (assign, nonatomic) NSInteger maxConcurrentDownloads;</span><br><span class="line"></span><br><span class="line">// 当前并行下载数量</span><br><span class="line">@property (readonly, nonatomic) NSUInteger currentDownloadCount;</span><br><span class="line"></span><br><span class="line">// 下载超时时间设置</span><br><span class="line">@property (assign, nonatomic) NSTimeInterval downloadTimeout;</span><br><span class="line"></span><br><span class="line">// 内部NSURLSession使用的配置</span><br><span class="line">@property (readonly, nonatomic, nonnull) NSURLSessionConfiguration *sessionConfiguration;</span><br><span class="line"></span><br><span class="line">// 改变下载operation的执行顺序，默认是FIFO</span><br><span class="line">@property (assign, nonatomic) SDWebImageDownloaderExecutionOrder executionOrder;</span><br></pre></td></tr></table></figure></p><p>然后是<code>SDWebImageDownloader.m</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">/// 该方法是SDWebImageDownloader的核心方法，通过该方法从网络下载图片</span><br><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    __weak SDWebImageDownloader *wself = self;</span><br><span class="line"></span><br><span class="line">    return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</span><br><span class="line">        __strong __typeof (wself) sself = wself;</span><br><span class="line">        NSTimeInterval timeoutInterval = sself.downloadTimeout;</span><br><span class="line">        if (timeoutInterval == 0.0) &#123;</span><br><span class="line">            timeoutInterval = 15.0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span><br><span class="line">        NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;</span><br><span class="line">        // 创建request  设置请求缓存策略、下载时间</span><br><span class="line">        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url</span><br><span class="line">                                                                    cachePolicy:cachePolicy</span><br><span class="line">                                                                timeoutInterval:timeoutInterval];</span><br><span class="line">        </span><br><span class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        request.HTTPShouldUsePipelining = YES;</span><br><span class="line">        if (sself.headersFilter) &#123;</span><br><span class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            request.allHTTPHeaderFields = [sself allHTTPHeaderFields];</span><br><span class="line">        &#125;</span><br><span class="line">        // 初始化一个自定义NSOperation对象</span><br><span class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</span><br><span class="line">        // 是否解压缩返回的图片</span><br><span class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</span><br><span class="line">        </span><br><span class="line">        if (sself.urlCredential) &#123;</span><br><span class="line">            // SSL验证</span><br><span class="line">            operation.credential = sself.urlCredential;</span><br><span class="line">        &#125; else if (sself.username &amp;&amp; sself.password) &#123;</span><br><span class="line">            // Basic验证</span><br><span class="line">            operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 指定优先级</span><br><span class="line">        if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">        &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">            // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</span><br><span class="line">            [sself.lastAddedOperation addDependency:operation];</span><br><span class="line">            sself.lastAddedOperation = operation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return operation;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 给下载过程添加进度</span><br><span class="line">- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">                                                   forURL:(nullable NSURL *)url</span><br><span class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback &#123;</span><br><span class="line">    // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span><br><span class="line">    if (url == nil) &#123;</span><br><span class="line">        if (completedBlock != nil) &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LOCK(self.operationsLock);</span><br><span class="line">    // 判断当前url是否有对应的operation图片的加载对象</span><br><span class="line">    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</span><br><span class="line">    // 如果没有，则直接创建一个</span><br><span class="line">    if (!operation) &#123;</span><br><span class="line">        // 创建一个operation，并且添加到URLOperation中</span><br><span class="line">        operation = createCallback();</span><br><span class="line">        __weak typeof(self) wself = self;</span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line">            __strong typeof(wself) sself = wself;</span><br><span class="line">            if (!sself) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            LOCK(sself.operationsLock);</span><br><span class="line">            [sself.URLOperations removeObjectForKey:url];</span><br><span class="line">            UNLOCK(sself.operationsLock);</span><br><span class="line">        &#125;;</span><br><span class="line">        [self.URLOperations setObject:operation forKey:url];</span><br><span class="line">        // Add operation to operation queue only after all configuration done according to Apple&apos;s doc.</span><br><span class="line">        // `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.</span><br><span class="line">        [self.downloadQueue addOperation:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(self.operationsLock);</span><br><span class="line"></span><br><span class="line">    id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">    </span><br><span class="line">    SDWebImageDownloadToken *token = [SDWebImageDownloadToken new];</span><br><span class="line">    token.downloadOperation = operation;</span><br><span class="line">    token.url = url;</span><br><span class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</span><br><span class="line"></span><br><span class="line">    return token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 移除一个图片下载操作</span><br><span class="line">- (void)cancel:(nullable SDWebImageDownloadToken *)token &#123;</span><br><span class="line">    NSURL *url = token.url;</span><br><span class="line">    if (!url) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.operationsLock);</span><br><span class="line">    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</span><br><span class="line">    if (operation) &#123;</span><br><span class="line">        BOOL canceled = [operation cancel:token.downloadOperationCancelToken];</span><br><span class="line">        if (canceled) &#123;</span><br><span class="line">            [self.URLOperations removeObjectForKey:url];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(self.operationsLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h3><p>&emsp;&emsp;SDWebImageDownloaderOperation继承自NSOperation，负责生成NSURLSessionTask进行图片请求，支持下载取消和后台下载，在下载时及时反馈下载进度，在下载成功后，对图片进行解码，缩放和压缩等操作。下面具体看下源码：<br><code>SDWebImageDownloaderOperation.h</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 开始下载通知</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadStartNotification;</span><br><span class="line">// 收到response通知</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadReceiveResponseNotification;</span><br><span class="line">// 停止下载通知</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadStopNotification;</span><br><span class="line">// 结束下载通知</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadFinishNotification;</span><br><span class="line"></span><br><span class="line">@interface SDWebImageDownloaderOperation : NSOperation &lt;SDWebImageDownloaderOperationInterface, SDWebImageOperation, NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;</span><br><span class="line"></span><br><span class="line">// operation的请求request</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) NSURLRequest *request;</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic, readonly, nullable) NSURLSessionTask *dataTask;</span><br><span class="line">// 图片是否可以被压缩</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Was used to determine whether the URL connection should consult the credential storage for authenticating the connection.</span><br><span class="line"> *  @deprecated Not used for a couple of versions</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) BOOL shouldUseCredentialStorage __deprecated_msg(&quot;Property deprecated. Does nothing. Kept only for backwards compatibility&quot;);</span><br><span class="line"></span><br><span class="line">// 身份认证</span><br><span class="line">@property (nonatomic, strong, nullable) NSURLCredential *credential;</span><br><span class="line"></span><br><span class="line">// 下载配置策略</span><br><span class="line">@property (assign, nonatomic, readonly) SDWebImageDownloaderOptions options;</span><br><span class="line"></span><br><span class="line">// 期望data的大小</span><br><span class="line">@property (assign, nonatomic) NSInteger expectedSize;</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic, nullable) NSURLResponse *response;</span><br><span class="line"></span><br><span class="line">// 初始化一个SDWebImageDownloaderOperation对象</span><br><span class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</span><br><span class="line">                              inSession:(nullable NSURLSession *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">// 绑定DownloaderOperation的下载进度block和结束block</span><br><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Cancels a set of callbacks. Once all callbacks are canceled, the operation is cancelled.</span><br><span class="line"> *</span><br><span class="line"> *  @param token the token representing a set of callbacks to cancel</span><br><span class="line"> *</span><br><span class="line"> *  @return YES if the operation was stopped because this was the last token to be canceled. NO otherwise.</span><br><span class="line"> */</span><br><span class="line">- (BOOL)cancel:(nullable id)token;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p><code>SDWebImageDownloaderOperation.m</code>：的具体分析如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line">/// 绑定DownloaderOperation的下载进度block和下载结束block</span><br><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    SDCallbacksDictionary *callbacks = [NSMutableDictionary new];</span><br><span class="line">    if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</span><br><span class="line">    if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    [self.callbackBlocks addObject:callbacks];</span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    return callbacks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 根据key获取回调块数组中所有对应key的回调块</span><br><span class="line">- (nullable NSArray&lt;id&gt; *)callbacksForKey:(NSString *)key &#123;</span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    NSMutableArray&lt;id&gt; *callbacks = [[self.callbackBlocks valueForKey:key] mutableCopy];</span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    // We need to remove [NSNull null] because there might not always be a progress block for each callback</span><br><span class="line">    [callbacks removeObjectIdenticalTo:[NSNull null]];</span><br><span class="line">    return [callbacks copy]; // strip mutability here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 取消方法</span><br><span class="line">- (BOOL)cancel:(nullable id)token &#123;</span><br><span class="line">    BOOL shouldCancel = NO;</span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    // 删除数组中block数组中的token对象，key为token</span><br><span class="line">    [self.callbackBlocks removeObjectIdenticalTo:token];</span><br><span class="line">    // 判断数组count为0时，则取消下载任务</span><br><span class="line">    if (self.callbackBlocks.count == 0) &#123;</span><br><span class="line">        shouldCancel = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    if (shouldCancel) &#123;</span><br><span class="line">        [self cancel];</span><br><span class="line">    &#125;</span><br><span class="line">    return shouldCancel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 当任务添加到NSOperationQueue后会执行该方法，启动下载任务</span><br><span class="line">- (void)start &#123;</span><br><span class="line">    // 添加同步锁，防止多线程数据竞争</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        if (self.isCancelled) &#123;</span><br><span class="line">            self.finished = YES;</span><br><span class="line">            [self reset];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">#if SD_UIKIT</span><br><span class="line">        // 如果设置了在后台可以继续下载图片，则会调用下面的方法，继续下载</span><br><span class="line">        Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">        BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</span><br><span class="line">        if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">            __weak __typeof__ (self) wself = self;</span><br><span class="line">            UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</span><br><span class="line">            self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">                __strong __typeof (wself) sself = wself;</span><br><span class="line"></span><br><span class="line">                if (sself) &#123;</span><br><span class="line">                    [sself cancel];</span><br><span class="line"></span><br><span class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">                    sself.backgroundTaskId = UIBackgroundTaskInvalid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        NSURLSession *session = self.unownedSession;</span><br><span class="line">        // 判断session是否为nil，如果为nil，则重新创建一个ownedSession</span><br><span class="line">        if (!session) &#123;</span><br><span class="line">            NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">            sessionConfig.timeoutIntervalForRequest = 15;</span><br><span class="line">            </span><br><span class="line">            /**</span><br><span class="line">             *  Create the session for this task</span><br><span class="line">             *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate</span><br><span class="line">             *  method calls and completion handler calls.</span><br><span class="line">             */</span><br><span class="line">            session = [NSURLSession sessionWithConfiguration:sessionConfig</span><br><span class="line">                                                    delegate:self</span><br><span class="line">                                               delegateQueue:nil];</span><br><span class="line">            self.ownedSession = session;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123;</span><br><span class="line">            // Grab the cached data for later check</span><br><span class="line">            NSURLCache *URLCache = session.configuration.URLCache;</span><br><span class="line">            if (!URLCache) &#123;</span><br><span class="line">                URLCache = [NSURLCache sharedURLCache];</span><br><span class="line">            &#125;</span><br><span class="line">            NSCachedURLResponse *cachedResponse;</span><br><span class="line">            // NSURLCache&apos;s `cachedResponseForRequest:` is not thread-safe, see https://developer.apple.com/documentation/foundation/nsurlcache#2317483</span><br><span class="line">            @synchronized (URLCache) &#123;</span><br><span class="line">                cachedResponse = [URLCache cachedResponseForRequest:self.request];</span><br><span class="line">            &#125;</span><br><span class="line">            if (cachedResponse) &#123;</span><br><span class="line">                self.cachedData = cachedResponse.data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 使用session创建一个NSURLSessionDataTask类型的下载任务</span><br><span class="line">        self.dataTask = [session dataTaskWithRequest:self.request];</span><br><span class="line">        self.executing = YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.dataTask) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wunguarded-availability&quot;</span><br><span class="line">        if ([self.dataTask respondsToSelector:@selector(setPriority:)]) &#123;</span><br><span class="line">            if (self.options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">                self.dataTask.priority = NSURLSessionTaskPriorityHigh;</span><br><span class="line">            &#125; else if (self.options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">                self.dataTask.priority = NSURLSessionTaskPriorityLow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        [self.dataTask resume];</span><br><span class="line">        // 任务开始，遍历进度block数组，执行第一个下载进度</span><br><span class="line">        for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(0, NSURLResponseUnknownLength, self.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:weakSelf];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果创建dataTask失败就回调失败block</span><br><span class="line">        [self callCompletionBlocksWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorUnknown userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Task can&apos;t be initialized&quot;&#125;]];</span><br><span class="line">        [self done];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    // 后台继续下载</span><br><span class="line">    Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.backgroundTaskId != UIBackgroundTaskInvalid) &#123;</span><br><span class="line">        UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">        [app endBackgroundTask:self.backgroundTaskId];</span><br><span class="line">        self.backgroundTaskId = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 取消下载方法</span><br><span class="line">- (void)cancelInternal &#123;</span><br><span class="line">    if (self.isFinished) return;</span><br><span class="line">    [super cancel];</span><br><span class="line">    // 如果下载图片的任务还在执行时，则立即取消cancel并且在主线程发送结束下载的通知</span><br><span class="line">    if (self.dataTask) &#123;</span><br><span class="line">        [self.dataTask cancel];</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // As we cancelled the task, its callback won&apos;t be called and thus won&apos;t</span><br><span class="line">        // maintain the isFinished and isExecuting flags.</span><br><span class="line">        if (self.isExecuting) self.executing = NO;</span><br><span class="line">        if (!self.isFinished) self.finished = YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self reset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark NSURLSessionDataDelegate</span><br><span class="line">/// 收到服务端相应，在一次请求中只会执行一次</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line">    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;</span><br><span class="line">    NSInteger expected = (NSInteger)response.expectedContentLength;</span><br><span class="line">    expected = expected &gt; 0 ? expected : 0;</span><br><span class="line">    self.expectedSize = expected;</span><br><span class="line">    self.response = response;</span><br><span class="line">    NSInteger statusCode = [response respondsToSelector:@selector(statusCode)] ? ((NSHTTPURLResponse *)response).statusCode : 200;</span><br><span class="line">    BOOL valid = statusCode &lt; 400;</span><br><span class="line">    //&apos;304 Not Modified&apos; is an exceptional one. It should be treated as cancelled if no cache data</span><br><span class="line">    //URLSession current behavior will return 200 status code when the server respond 304 and URLCache hit. But this is not a standard behavior and we just add a check</span><br><span class="line">    if (statusCode == 304 &amp;&amp; !self.cachedData) &#123;</span><br><span class="line">        valid = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (valid) &#123;</span><br><span class="line">        for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(0, expected, self.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Status code invalid and marked as cancelled. Do not call `[self.dataTask cancel]` which may mass up URLSession life cycle</span><br><span class="line">        disposition = NSURLSessionResponseCancel;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:weakSelf];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 每次收到数据都会触发，会多次调用</span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123;</span><br><span class="line">    if (!self.imageData) &#123;</span><br><span class="line">        self.imageData = [[NSMutableData alloc] initWithCapacity:self.expectedSize];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.imageData appendData:data];</span><br><span class="line"></span><br><span class="line">    if ((self.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; self.expectedSize &gt; 0) &#123;</span><br><span class="line">        // Get the image data</span><br><span class="line">        __block NSData *imageData = [self.imageData copy];</span><br><span class="line">        // Get the total bytes downloaded</span><br><span class="line">        const NSInteger totalSize = imageData.length;</span><br><span class="line">        // 获取下载状态标志</span><br><span class="line">        BOOL finished = (totalSize &gt;= self.expectedSize);</span><br><span class="line">        // 判断是否有解压对象，若不存在则创建一个新的解压对象</span><br><span class="line">        if (!self.progressiveCoder) &#123;</span><br><span class="line">            // We need to create a new instance for progressive decoding to avoid conflicts</span><br><span class="line">            for (id&lt;SDWebImageCoder&gt;coder in [SDWebImageCodersManager sharedInstance].coders) &#123;</span><br><span class="line">                if ([coder conformsToProtocol:@protocol(SDWebImageProgressiveCoder)] &amp;&amp;</span><br><span class="line">                    [((id&lt;SDWebImageProgressiveCoder&gt;)coder) canIncrementallyDecodeFromData:imageData]) &#123;</span><br><span class="line">                    self.progressiveCoder = [[[coder class] alloc] init];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 逐步解码编码器队列中的图片</span><br><span class="line">        dispatch_async(self.coderQueue, ^&#123;</span><br><span class="line">            UIImage *image = [self.progressiveCoder incrementallyDecodedImageWithData:imageData finished:finished];</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                // 通过URL获取缓存的key</span><br><span class="line">                NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</span><br><span class="line">                image = [self scaledImageForKey:key image:image];</span><br><span class="line">                if (self.shouldDecompressImages) &#123;</span><br><span class="line">                    image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(NO)&#125;];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                // We do not keep the progressive decoding image even when `finished`=YES. Because they are for view rendering but not take full function from downloader options. And some coders implementation may not keep consistent between progressive decoding and normal decoding.</span><br><span class="line">                </span><br><span class="line">                [self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 循环进行下载进度的block回调</span><br><span class="line">    for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">        progressBlock(self.imageData.length, self.expectedSize, self.request.URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line"> willCacheResponse:(NSCachedURLResponse *)proposedResponse</span><br><span class="line"> completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    NSCachedURLResponse *cachedResponse = proposedResponse;</span><br><span class="line"></span><br><span class="line">    if (!(self.options &amp; SDWebImageDownloaderUseNSURLCache)) &#123;</span><br><span class="line">        // Prevents caching of responses</span><br><span class="line">        cachedResponse = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(cachedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体的下载流程可以概括为：</p><ul><li>首先生成继承自NSOperation的SDWebImageDownloaderOperation，配置当前operation，并将operation添加到NSOperationQueue下载队列中，添加到下载队列会出发operation的start方法。</li><li>如果operation的isCancelled为YES时，说明下载已经被取消，则结束下载。</li><li>创建NSURLSessionTask并执行resume方法开始下载。</li><li>当收到服务端的响应式根据code判断请求状态，如果是正常状态则发送正在接收response的通知以及下载进度。如果是304或者其他异常状态则cancel下载操作。</li><li>在didReceiveData每次收到服务器返回的response时，给data数据中追加图片当前下载的data，并回调下载的进度。</li><li>在didCompleteWithError下载结束时，如果下载成功则进行图片data解码，图片的缩放或者压缩操作，发送下载结束通知。若下载失败，则回调失败block。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;本文中，主要详细分析了SDWebImage的SDImageCache、SDWebImageDownloader和SDWebImageDownloaderOperation核心类。到此，SDWebImage的源码解析也结束了，由于技术水平有限，所以有相关错误和遗漏的，欢迎邮件（<a href="mailto:jiang.shunjin@icloud.com" target="_blank" rel="noopener">jiang.shunjin@icloud.com</a>）给我进行指正和补充。</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发 - 深入理解Objective-C：Category</title>
      <link href="//category-principle.html"/>
      <url>//category-principle.html</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>&emsp;&emsp;无论一个类设计得多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了Category这个语言特性，可以动态地为已有类添加新方法。如今Category已经遍布于Objective-C代码的每个角落，从Apple官方的的framework到各个开源框架，从功能繁复的大型App到简单的应用，Category无处不在。本文对Category做了比较前面的整理，希望对读者有所裨益。<br><a id="more"></a></p><h1 id="初入宝地-Category简介"><a href="#初入宝地-Category简介" class="headerlink" title="初入宝地-Category简介"></a>初入宝地-Category简介</h1><p>&emsp;&emsp;Category是Objective-C 2.0之后添加的语言特性，Category的主要作用是为已存在的类添加方法。除此之外，Apple还推荐了Category的另外<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html" target="_blank" rel="noopener">两个使用场景</a>：</p><ul><li>可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处：<ul><li>可以减少单个文件的体积</li><li>可以把不同的功能组织到不同的Category里</li><li>可以由多个开发者共同完成一个类</li><li>可以按需加载想要的Category等等。</li></ul></li><li>声明私有方法</li></ul><p>&emsp;&emsp;不过除了Apple推荐的使用场景，广大开发者脑洞大开，还衍生出了Category的其他几个使用场景：</p><ul><li>模拟多继承</li><li>把framework的私有方法公开</li></ul><h1 id="连类比事-Category和Extension"><a href="#连类比事-Category和Extension" class="headerlink" title="连类比事-Category和Extension"></a>连类比事-Category和Extension</h1><p>&emsp;&emsp;Extension看起来很像一个匿名的Category，但是Extension和有名字的Category几乎完全是两个东西。Extension是在编译器决议，它就是类的一部分，在编译期和头文件里的<code>@interface</code>以及实现文件里的<code>@implement</code>一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。Extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加Extension，所以你无法为系统的类，比如NSString，添加Extension，详情请见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="noopener">官方文档说明</a>。<br>&emsp;&emsp;但是Category则完全不一样，它是在运行期决议的。<br>&emsp;&emsp;就Category和Extension的区别来看，我们可以推导出一个明显的事实，Extension可以添加实例变量，而Category是无法添加实例变量的（对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）</p><h1 id="挑灯细览-Category真面目"><a href="#挑灯细览-Category真面目" class="headerlink" title="挑灯细览-Category真面目"></a>挑灯细览-Category真面目</h1><p>&emsp;&emsp;我们知道，所有的OC类和对象，在runtime层都是用struct表示的，Category也不例外，在runtime层，Category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了：</p><ul><li>类的名字（name）</li><li>类（cls）</li><li>Category中所有给类添加的实例方法的列表（instanceMethods）</li><li>Category中所有添加的类方法的列表（classMethods）</li><li>Category实现的所有协议的列表（protocols）</li><li>Category中添加的所有属性（instanceProperties）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    struct method_list_t *instanceMethods;</span><br><span class="line">    struct method_list_t *classMethods;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    struct property_list_t *instanceProperties;</span><br><span class="line">&#125; category_t;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从Category的定义也可以看出Category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。<br>&emsp;&emsp;ok，我们先去写一个Category，看一个Category到底为何物：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface MyClass : NSObject</span><br><span class="line"></span><br><span class="line">- (void)printName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface MyClass(MyAddition)</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">- (void)printName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;MyClass.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation MyClass</span><br><span class="line"></span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,@&quot;MyClass&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass(MyAddition)</span><br><span class="line"></span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,@&quot;MyAddition&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们使用clang的命令（<code>clang -rewrite-objc MyClass.m</code>），得到了一个3M大小，10w多行的.cpp文件，我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">1,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;printName&quot;, &quot;v16@0:8&quot;, (void *)_I_MyClass_MyAddition_printName&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct /*_prop_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _prop_t)</span><br><span class="line">unsigned int count_of_properties;</span><br><span class="line">struct _prop_t prop_list[1];</span><br><span class="line">&#125; _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section     (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_prop_t),</span><br><span class="line">1,</span><br><span class="line">&#123;&#123;&quot;name&quot;,&quot;T@\&quot;NSString\&quot;,C,N&quot;&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_MyClass;</span><br><span class="line"></span><br><span class="line">static struct _category_t _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) =</span><br><span class="line">&#123;</span><br><span class="line">&quot;MyClass&quot;,</span><br><span class="line">0, // &amp;OBJC_CLASS_$_MyClass,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br><span class="line">static void OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(void ) &#123;</span><br><span class="line">_OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &amp;OBJC_CLASS_$_MyClass;</span><br><span class="line">&#125;</span><br><span class="line">#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)</span><br><span class="line">__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">(void *)&amp;OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;OBJC_CLASS_$_MyClass,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _class_t *_OBJC_LABEL_NONLAZY_CLASS_$[] = &#123;</span><br><span class="line">&amp;OBJC_CLASS_$_MyClass,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;_OBJC_$_CATEGORY_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们可以看到：</p><ul><li>首先编译器生成了实例方法列表<code>OBJC$_CATEGORY_INSTANCE_METHODSMyClass$_MyAddition</code>和属性列表<code>OBJC$_PROP_LISTMyClass$_MyAddition</code>，两者的命名都遵循了公共前缀+类名+Category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个Category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是Category的名字用来给各种列表以及后面的Category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的Category名不能重复，否则会出现编译错误。</li><li>其次，编译器生成了Category本身<code>OBJC$_CATEGORYMyClass$_MyAddition</code>，并用前面生成的列表来初始化Category本身。</li><li>最后，编译器在DATA段下的<code>objc_catlist section</code>里保存了一个大小为1的category_t的数组<code>L_OBJC_LABELCATEGORY$</code>（当然，如果有多个Category，会生成对应长度的数组），用于运行期Category的加载。</li></ul><h1 id="追本溯源-Category如何加载"><a href="#追本溯源-Category如何加载" class="headerlink" title="追本溯源-Category如何加载"></a>追本溯源-Category如何加载</h1><p>&emsp;&emsp;我们知道，Objective-C的运行时是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。想了解更多dyld的同学可以移步这里：<a href="https://link.jianshu.com/?t=https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="noopener">传送门</a><br>&emsp;&emsp;对于OC运行时，入口方法如下（在objc-os.mm文件中）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized = true;</span><br><span class="line"></span><br><span class="line">    // fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    // Register for unmap first, in case some +load unmaps something</span><br><span class="line">    _dyld_register_func_for_remove_image(&amp;unmap_image);</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_bound,</span><br><span class="line">                                         1/*batch*/, &amp;map_images);</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;Category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc_runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// Discover categories. </span><br><span class="line">    for (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist =</span><br><span class="line">        _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            class_t *cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">            if (!cls) &#123;</span><br><span class="line">                // Category&apos;s target class is missing (probably weak-linked).</span><br><span class="line">                // Disavow any knowledge of this category.</span><br><span class="line">                catlist[i] = NULL;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span><br><span class="line">                                 &quot;missing weak-linked target class&quot;,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Process this category. </span><br><span class="line">            // First, register the category with its target class. </span><br><span class="line">            // Then, rebuild the class&apos;s method lists (etc) if </span><br><span class="line">            // the class is realized. </span><br><span class="line">            BOOL classExists = NO;</span><br><span class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols </span><br><span class="line">            ||  cat-&gt;instanceProperties)</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                if (isRealized(cls)) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,</span><br><span class="line">                                 getName(cls), cat-&gt;name,</span><br><span class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols </span><br><span class="line">            /* ||  cat-&gt;classProperties */)</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;isa, hi);</span><br><span class="line">                if (isRealized(cls-&gt;isa)) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;isa);</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,</span><br><span class="line">                                 getName(cls), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和Category本身的关系也不大，有兴趣的同学可以去研究下Apple的二进制格式和load机制。<br>&emsp;&emsp;略去PrintConnecting这个用于log的东西，这段代码很容易理解：</p><ul><li>把Category的实例方法、协议以及属性添加到类上</li><li>把Category的类方法和协议添加到类的metaclass上</li></ul><p>&emsp;&emsp;值得注意的是，在代码中有一小段注释 <code>/ || cat-&gt;classProperties /</code>，看来苹果有过给类添加属性的计划啊。<br>&emsp;&emsp;ok，我们接着往里看，Category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：在上述的代码片段里，<code>addUnattachedCategoryForClass</code>只是把类和Category做一个关联映射，而<code>remethodizeClass</code>才是真正去处理添加事宜的功臣。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">static void remethodizeClass(class_t *cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    BOOL isMeta;</span><br><span class="line"></span><br><span class="line">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class="line"></span><br><span class="line">    isMeta = isMetaClass(cls);</span><br><span class="line"></span><br><span class="line">    // Re-methodizing: check for more categories</span><br><span class="line">    if ((cats = unattachedCategoriesForClass(cls))) &#123;</span><br><span class="line">        chained_property_list *newproperties;</span><br><span class="line">        const protocol_list_t **newprotos;</span><br><span class="line"></span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,</span><br><span class="line">                     getName(cls), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Update methods, properties, protocols</span><br><span class="line"></span><br><span class="line">        BOOL vtableAffected = NO;</span><br><span class="line">        attachCategoryMethods(cls, cats, &amp;vtableAffected);</span><br><span class="line"></span><br><span class="line">        newproperties = buildPropertyList(NULL, cats, isMeta);</span><br><span class="line">        if (newproperties) &#123;</span><br><span class="line">            newproperties-&gt;next = cls-&gt;data()-&gt;properties;</span><br><span class="line">            cls-&gt;data()-&gt;properties = newproperties;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newprotos = buildProtocolList(cats, NULL, cls-&gt;data()-&gt;protocols);</span><br><span class="line">        if (cls-&gt;data()-&gt;protocols  &amp;&amp;  cls-&gt;data()-&gt;protocols != newprotos) &#123;</span><br><span class="line">            _free_internal(cls-&gt;data()-&gt;protocols);</span><br><span class="line">        &#125;</span><br><span class="line">        cls-&gt;data()-&gt;protocols = newprotos;</span><br><span class="line"></span><br><span class="line">        _free_internal(cats);</span><br><span class="line"></span><br><span class="line">        // Update method caches and vtables</span><br><span class="line">        flushCaches(cls);</span><br><span class="line">        if (vtableAffected) flushVtables(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;而对于添加类的实例方法而言，又会去调用<code>attachCategoryMethods</code>这个方法，我们去看下<code>attachCategoryMethods</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void attachCategoryMethods(class_t *cls, category_list *cats,</span><br><span class="line">                  BOOL *inoutVtablesAffected)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    BOOL isMeta = isMetaClass(cls);</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">    _malloc_internal(cats-&gt;count * sizeof(*mlists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    BOOL fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= cats-&gt;list[i].fromBundle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);</span><br><span class="line"></span><br><span class="line">    _free_internal(mlists);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>attachCategoryMethods</code>做的工作相对比较简单，它只是把所有Category的实例方法列表拼成了一个大的实例方法列表，然后转交给了<code>attachMethodLists</code>方法，这个方法有点长，我们只看一小段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">for (uint32_t m = 0; (scanForCustomRR || scanForCustomAWZ)  &amp;&amp;  m &lt; mlist-&gt;count;</span><br><span class="line">         m++)</span><br><span class="line">&#123;</span><br><span class="line">    SEL sel = method_list_nth(mlist, m)-&gt;name;</span><br><span class="line">    if (scanForCustomRR  &amp;&amp;  isRRSelector(sel)) &#123;</span><br><span class="line">            cls-&gt;setHasCustomRR();</span><br><span class="line">            scanForCustomRR = false;</span><br><span class="line">        &#125; else if (scanForCustomAWZ  &amp;&amp;  isAWZSelector(sel)) &#123;</span><br><span class="line">            cls-&gt;setHasCustomAWZ();</span><br><span class="line">            scanForCustomAWZ = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Fill method list array</span><br><span class="line">    newLists[newCount++] = mlist;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"></span><br><span class="line">    // Copy old methods to the method list array</span><br><span class="line">    for (i = 0; i &lt; oldCount; i++) &#123;</span><br><span class="line">    newLists[newCount++] = oldLists[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;需要注意的有两点：</p><ul><li>Category的方法没有“完全替换掉”原来类已经有的方法，也就说如果Category和原来类都有methodA，那么Category附件完成之后，类的方法列表里会有两个methodA。</li><li>Category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的Category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它主要一找到对应名字的方法，就会罢休，殊不知后面可能还有一样名字的方法。</li></ul><h1 id="旁支末叶-Category和-load方法"><a href="#旁支末叶-Category和-load方法" class="headerlink" title="旁支末叶-Category和+load方法"></a>旁支末叶-Category和+load方法</h1><p>&emsp;&emsp;我们知道，在类和Category中都可以有+load方法，那么有两个问题：</p><ul><li>在类的+load方法调用的时候，我们可以调用Category中声明的方法么？</li><li>这么几个+load方法，调用顺序是怎样的呢？</li></ul><p>&emsp;&emsp;鉴于上述几节我们看的代码太多了，对于这两个问题，我们先来看一点直观的<br><img src="http://pic.cloverkim.com/006tNc79gy1g02j2m78u0j308c04l74u.jpg" alt=""><br>&emsp;&emsp;我们的代码里有MyClass和MyClass的两个Category（Category1和Category2），MyClass和两个Category都添加了+load方法，并且Category1和Category2都写了MyClass的printName方法。<br>&emsp;&emsp;在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行load方法以及加载Category的时候打印log信息，更多的环境变量选项可参见objc-private.h）：<br><img src="http://pic.cloverkim.com/006tNc79gy1g02j5obh5bj30qk08qgmb.jpg" alt=""><br>&emsp;&emsp;运行项目，我们会看到控制台打印很多东西，我们只找我们想要的信息，顺序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">objc[1187]: REPLACED: -[MyClass printName] by category Category1</span><br><span class="line">objc[1187]: REPLACED: -[MyClass printName] by category Category2</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[1187]: LOAD: class &apos;MyClass&apos; scheduled for +load</span><br><span class="line">objc[1187]: LOAD: category &apos;MyClass(Category1)&apos; scheduled for +load</span><br><span class="line">objc[1187]: LOAD: category &apos;MyClass(Category2)&apos; scheduled for +load</span><br><span class="line">objc[1187]: LOAD: +[MyClass load]</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[1187]: LOAD: +[MyClass(Category1) load]</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[1187]: LOAD: +[MyClass(Category2) load]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;所以，对于上面两个问题，答案是很明显的：</p><ul><li>可以调用，因为附加Category到类的工作会先于+load方法的执行</li><li>+load的执行顺序是先类，后Category，而Category的+load执行顺序是根据编译顺序决定的。</li></ul><p>&emsp;&emsp;目前的编译顺序是这样的：<br><img src="http://pic.cloverkim.com/006tNc79gy1g02j978gp0j30mw09o75k.jpg" alt=""><br>&emsp;&emsp;我们调整一下Category1和Category2的编译顺序，如下图所示，run。ok，我们可以看到控制台的输出顺序变了：<br><img src="http://pic.cloverkim.com/006tNc79gy1g02jgvfocnj30lu09u3zm.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">objc[1187]: REPLACED: -[MyClass printName] by category Category2</span><br><span class="line">objc[1187]: REPLACED: -[MyClass printName] by category Category1</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[1187]: LOAD: class &apos;MyClass&apos; scheduled for +load</span><br><span class="line">objc[1187]: LOAD: category &apos;MyClass(Category2)&apos; scheduled for +load</span><br><span class="line">objc[1187]: LOAD: category &apos;MyClass(Category1)&apos; scheduled for +load</span><br><span class="line">objc[1187]: LOAD: +[MyClass load]</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[1187]: LOAD: +[MyClass(Category2) load]</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[1187]: LOAD: +[MyClass(Category1) load]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;虽然对于+load的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的Category里的对应方法。<br>&emsp;&emsp;这一节我们只是用很直观的方式得到了问题的答案，有兴趣的同学可以继续去研究一下OC的运行时代码。</p><h1 id="触类旁通-Category和方法覆盖"><a href="#触类旁通-Category和方法覆盖" class="headerlink" title="触类旁通-Category和方法覆盖"></a>触类旁通-Category和方法覆盖</h1><p>&emsp;&emsp;鉴于上面几节我们已经把原理都讲了，这一节只有一个问题：怎么调用到原来类中被Category覆盖掉的方法？<br>&emsp;&emsp;对于这个问题，我们已经知道Category其实并不是完全替换掉原来类的同名方法，只是Category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Class currentClass = [MyClass class];</span><br><span class="line">MyClass *my = [[MyClass alloc] init];</span><br><span class="line"></span><br><span class="line">if (currentClass) &#123;</span><br><span class="line">    unsigned int methodCount;</span><br><span class="line">    Method *methodList = class_copyMethodList(currentClass, &amp;methodCount);</span><br><span class="line">    IMP lastImp = NULL;</span><br><span class="line">    SEL lastSel = NULL;</span><br><span class="line">    for (NSInteger i = 0; i &lt; methodCount; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) </span><br><span class="line">                                    encoding:NSUTF8StringEncoding];</span><br><span class="line">        if ([@&quot;printName&quot; isEqualToString:methodName]) &#123;</span><br><span class="line">            lastImp = method_getImplementation(method);</span><br><span class="line">            lastSel = method_getName(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    typedef void (*fn)(id,SEL);</span><br><span class="line"></span><br><span class="line">    if (lastImp != NULL) &#123;</span><br><span class="line">        fn f = (fn)lastImp;</span><br><span class="line">        f(my,lastSel);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="更上一层-Category和关联对象"><a href="#更上一层-Category和关联对象" class="headerlink" title="更上一层-Category和关联对象"></a>更上一层-Category和关联对象</h1><p>&emsp;&emsp;如上所见，我们知道在Category里面是无法为Category添加实例变量的。但是我们很多时候需要在Category中添加和对象关联的值，这个时候可以求助关联对象来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/// MyClass+Category1.h:</span><br><span class="line"></span><br><span class="line">#import &quot;MyClass.h&quot;</span><br><span class="line"></span><br><span class="line">@interface MyClass (Category1)</span><br><span class="line">@property(nonatomic,copy) NSString *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/// MyClass+Category1.m:</span><br><span class="line"></span><br><span class="line">#import &quot;MyClass+Category1.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation MyClass (Category1)</span><br><span class="line"></span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,@&quot;load in Category1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self,</span><br><span class="line">                         &quot;name&quot;,</span><br><span class="line">                         name,</span><br><span class="line">                         OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString*)name</span><br><span class="line">&#123;</span><br><span class="line">    NSString *nameObject = objc_getAssociatedObject(self, &quot;name&quot;);</span><br><span class="line">    return nameObject;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是关联对象又是存在什么地方的呢？如何存储？对象销毁时候如何处理关联对象呢？我们去翻一下runtime的源码，在<code>objc-references.mm</code>文件中有个方法<code>_object_set_associative_reference</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    // retain the new value (if any) outside the lock.</span><br><span class="line">    ObjcAssociation old_association(0, nil);</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            // break any existing association.</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i != associations.end()) &#123;</span><br><span class="line">                // secondary table exists</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // create the new association (first time).</span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // setting the association to nil breaks the association.</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // release the old value (outside of the lock).</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class AssociationsManager &#123;</span><br><span class="line">    static OSSpinLock _lock;</span><br><span class="line">    static AssociationsHashMap *_map;               // associative references:  object pointer -&gt;       PtrPtrHashMap.</span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; OSSpinLockLock(&amp;_lock); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; OSSpinLockUnlock(&amp;_lock); &#125;</span><br><span class="line"></span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        if (_map == NULL)</span><br><span class="line">            _map = new AssociationsHashMap();</span><br><span class="line">        return *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的key-value对。<br>&emsp;&emsp;而在对象的销毁逻辑里面，见<code>objc-runtime-new.mm</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        Class isa_gen = _object_getClass(obj);</span><br><span class="line">        class_t *isa = newcls(isa_gen);</span><br><span class="line"></span><br><span class="line">        // Read all of the flags at once for performance.</span><br><span class="line">        bool cxx = hasCxxStructors(isa);</span><br><span class="line">        bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);</span><br><span class="line"></span><br><span class="line">        // This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line"></span><br><span class="line">        if (!UseGC) objc_clear_deallocating(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;runtime的销毁对象函数<code>objc_destructInstance</code>里面会判断这个对象有没有关联对象，如果有，会调用<code>_object_remove_assocations</code>做关联对象的清理工作。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>&emsp;&emsp;正如侯捷先生所讲“源码面前，了无秘密”，Apple的Cocoa Touch框架虽然并不开源，但是Objective-C的runtime和Core Foundation却是完全开放源码的（在<a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/</a> 可以下载到全部的开源代码）</p><h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p>&emsp;&emsp;本文转自<a href="https://tech.meituan.com/2015/03/03/diveintocategory.html" target="_blank" rel="noopener">美团技术团队 - zj - 深入理解Objective-C：Category</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SDWebImage相关面试题</title>
      <link href="//SDWebImage-interview-question.html"/>
      <url>//SDWebImage-interview-question.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;在之前的三篇文章中（<a href="http://cloverkim.com/SDWebImage-source-code-analysis-1.html">SDWebImage源码解析（一）</a>、<a href="http://cloverkim.com/SDWebImage-source-code-analysis-2.html">SDWebImage源码解析（二）</a>、<a href="http://cloverkim.com/SDWebImage-source-code-analysis-3.html">SDWebImage源码解析（三）</a>），对<a href="https://github.com/SDWebImage/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>的源码进行了详细的解析，阅读优秀的源码是一种很好的学习方式，对自己的技术成长有着一定的帮助。本文中，是对网上一些关于SDWebImage面试题的相关列举和分析解答。<a id="more"></a></p><h1 id="SDWebImage支持GIF图吗？"><a href="#SDWebImage支持GIF图吗？" class="headerlink" title="SDWebImage支持GIF图吗？"></a>SDWebImage支持GIF图吗？</h1><h2 id="FLAnimatedImage"><a href="#FLAnimatedImage" class="headerlink" title="FLAnimatedImage"></a>FLAnimatedImage</h2><p>&emsp;&emsp;在SDWebImage 4.0版本之后，可以用<a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage</a>来加载GIF图，官方文档说明如下：</p><blockquote><p>Starting with the 4.0 version, we rely on <a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage</a> to take care of our animated images.<br>If you use cocoapods, add <code>pod &#39;SDWebImage/GIF&#39;</code> to your podfile.<br>To use it, simply make sure you use FLAnimatedImageView instead of UIImageView.</p></blockquote><blockquote><p>Note: there is a backwards compatible feature, so if you are still trying to load a GIF into a UIImageView, it will only show the 1st frame as a static image by default. However, you can enable the full GIF support by using the built-in GIF coder. See <a href="https://github.com/SDWebImage/SDWebImage/wiki/Advanced-Usage#gif-coder" target="_blank" rel="noopener">GIF coder</a></p></blockquote><blockquote><p>Important: FLAnimatedImage only works on the iOS platform. For macOS, use NSImageView with animates set to YES to show the entire animated images and NO to only show the 1st frame. For all the other platforms (tvOS, watchOS) we will fallback to the backwards compatibility feature described above</p></blockquote><p>FLAnimatedImage使用流程大致可以概括为：</p><ul><li>CocoaPods单独倒入库<code>pod &#39;SDWebImage/GIF&#39;</code>,并引入<code>import FLAnimatedImage</code></li><li>使用<code>initWithAnimatedGIFData:</code>方法新建FLAnimatedImage类</li><li>然后再新建FLAnimatedImageView类，将刚刚新建的FLAnimatedImage赋值给FLAnimatedImageView的animatedImage变量即可。</li></ul><p>简易demo代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let gifPath = Bundle.main.path(forResource: &quot;gif_test&quot;, ofType: &quot;gif&quot;)</span><br><span class="line">if let imageData = NSData(contentsOfFile: gifPath ?? &quot;&quot;) &#123;</span><br><span class="line">    let animatedImageView = FLAnimatedImageView(frame: animatedBgView.bounds)</span><br><span class="line">    animatedImageView.animatedImage = FLAnimatedImage(animatedGIFData: imageData as Data)</span><br><span class="line">    animatedBgView.addSubview(animatedImageView)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="SDWebImage-4-4-2版本的sd-animatedGIFWithData方法"><a href="#SDWebImage-4-4-2版本的sd-animatedGIFWithData方法" class="headerlink" title="SDWebImage 4.4.2版本的sd_animatedGIFWithData方法"></a>SDWebImage 4.4.2版本的<code>sd_animatedGIFWithData</code>方法</h2><p>&emsp;&emsp;在SDWebImage的4.4.2版本中，已经支持加载GIF图，使用的是<code>UIImage+GIF</code>分类中的<code>sd_animatedGIFWithData</code>方法，具体使用方法如下demo所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let gifPath = Bundle.main.path(forResource: &quot;gif_test&quot;, ofType: &quot;gif&quot;)</span><br><span class="line">if let imageData = NSData(contentsOfFile: gifPath ?? &quot;&quot;) &#123;</span><br><span class="line">    gifImageView.image = UIImage.sd_animatedGIF(with: imageData as Data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下图所示：<br><img src="http://pic.cloverkim.com/006tKfTcgy1g0e679vq7dg30aw0lkkjm.gif" alt=""></p><h1 id="SDWebImage如何区分图片格式？"><a href="#SDWebImage如何区分图片格式？" class="headerlink" title="SDWebImage如何区分图片格式？"></a>SDWebImage如何区分图片格式？</h1><p>常见的三种图片格式：</p><ul><li>PNG：压缩比没有JPG高，但是无损压缩，解压缩性能高，苹果推荐的图片格式</li><li>JPG：压缩比最高的一种图片格式，有损压缩。</li><li>GIF：序列帧动图。特点：只支持256种颜色。</li></ul><p>在<code>NSData+ImageContentType</code>分类中，对图片格式枚举的定义，以及根据图片data获取图片类型的定义实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDImageFormat) &#123;</span><br><span class="line">    SDImageFormatUndefined = -1,        // 未知类型</span><br><span class="line">    SDImageFormatJPEG = 0,              // JPG</span><br><span class="line">    SDImageFormatPNG,                   // PNG</span><br><span class="line">    SDImageFormatGIF,                   // GIF</span><br><span class="line">    SDImageFormatTIFF,                  // TIFF</span><br><span class="line">    SDImageFormatWebP,                  // WEBP</span><br><span class="line">    SDImageFormatHEIC                   // HEIC</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// 根据图片NSData获取图片的类型</span><br><span class="line">+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data &#123;</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return SDImageFormatUndefined;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // File signatures table: http://www.garykessler.net/library/file_sigs.html</span><br><span class="line">    uint8_t c;</span><br><span class="line">    // 获取图片data数据的第一个字节数据</span><br><span class="line">    [data getBytes:&amp;c length:1];</span><br><span class="line">    // 根据字母的ASCII码比较，返回对应的图片类型枚举</span><br><span class="line">    switch (c) &#123;</span><br><span class="line">        case 0xFF:</span><br><span class="line">            return SDImageFormatJPEG;</span><br><span class="line">        case 0x89:</span><br><span class="line">            return SDImageFormatPNG;</span><br><span class="line">        case 0x47:</span><br><span class="line">            return SDImageFormatGIF;</span><br><span class="line">        case 0x49:</span><br><span class="line">        case 0x4D:</span><br><span class="line">            return SDImageFormatTIFF;</span><br><span class="line">        case 0x52: &#123;</span><br><span class="line">            if (data.length &gt;= 12) &#123;</span><br><span class="line">                // RIFF....WEBP</span><br><span class="line">                NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];</span><br><span class="line">                if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123;</span><br><span class="line">                    return SDImageFormatWebP;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case 0x00: &#123;</span><br><span class="line">            if (data.length &gt;= 12) &#123;</span><br><span class="line">                // ....ftypheic ....ftypheix ....ftyphevc ....ftyphevx</span><br><span class="line">                NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(4, 8)] encoding:NSASCIIStringEncoding];</span><br><span class="line">                if ([testString isEqualToString:@&quot;ftypheic&quot;]</span><br><span class="line">                    || [testString isEqualToString:@&quot;ftypheix&quot;]</span><br><span class="line">                    || [testString isEqualToString:@&quot;ftyphevc&quot;]</span><br><span class="line">                    || [testString isEqualToString:@&quot;ftyphevx&quot;]) &#123;</span><br><span class="line">                    return SDImageFormatHEIC;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return SDImageFormatUndefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="SDWebImage缓存图片的名称如何避免重名"><a href="#SDWebImage缓存图片的名称如何避免重名" class="headerlink" title="SDWebImage缓存图片的名称如何避免重名"></a>SDWebImage缓存图片的名称如何避免重名</h1><p>&emsp;&emsp;如果单纯使用文件名保存，重名的几率非常高。因此，使用MD5的散列函数，对完整的图片url进行MD5，结果是一个32个字符长度的字符串。</p><h1 id="SDWebImage如何保证UI操作放在主线程中执行？"><a href="#SDWebImage如何保证UI操作放在主线程中执行？" class="headerlink" title="SDWebImage如何保证UI操作放在主线程中执行？"></a>SDWebImage如何保证UI操作放在主线程中执行？</h1><p>&emsp;&emsp;在SDWebImage的<code>SDWebImageCompat.h</code>中，有如下的宏定义，用来保证主线程操作，可为什么要这么写？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ifndef dispatch_queue_async_safe</span><br><span class="line">#define dispatch_queue_async_safe(queue, block)\</span><br><span class="line">    if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(queue)) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(queue, block);\</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef dispatch_main_async_safe</span><br><span class="line">#define dispatch_main_async_safe(block) dispatch_queue_async_safe(dispatch_get_main_queue(), block)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>之前比较常见的写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define dispatch_main_async_safe(block)\</span><br><span class="line">    if ([NSThread isMainThread]) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;对比两个宏定义可以发现前者两个地方改变了，一是多了<code>#ifndef</code>，二是判断条件改变了。增加<code>ifndef</code>是为了提高代码的严谨，防止重复定义<code>dispatch_main_async_safe</code>，而关于判断条件改变的的原因则可以参考以下两篇文档：1.<a href="http://blog.benjamin-encz.de/post/main-queue-vs-main-thread/" target="_blank" rel="noopener">GCD’s Main Queue vs. Main Thread</a>、2.<a href="https://blog.krzyzanowskim.com/2016/06/03/queues-are-not-bound-to-any-specific-thread/" target="_blank" rel="noopener">Queues are not bound to any specific thread</a></p><h2 id="分析：如何判断当前是否在主线程？"><a href="#分析：如何判断当前是否在主线程？" class="headerlink" title="分析：如何判断当前是否在主线程？"></a>分析：如何判断当前是否在主线程？</h2><h3 id="最简单的方法"><a href="#最简单的方法" class="headerlink" title="最简单的方法"></a>最简单的方法</h3><p>&emsp;&emsp;判断当前是否在主线程最简单的方法是使用<code>[NSThread isMainThread]</code>，GCD缺少一个类似的方便的API来判断当前是否在主队列上运行，因此一般是使用NSThread的API，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ([NSThread isMainThread]) &#123;</span><br><span class="line">    block();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这在大多数情况下是有效的，直到它出现了异常。下面是关于ReactiveCocoa repo问题的摘录：<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2635#issuecomment-170215083" target="_blank" rel="noopener">ReactiveCocoa issue</a><br><img src="http://pic.cloverkim.com/006tKfTcgy1g0e7ys9bihj317m0eagpe.jpg" alt=""><br>&emsp;&emsp;潜在的问题是VektorKit API正在检查是否在主队列上调用它，而不是检查它是否在主线程上运行。虽然每个应用程序都只有一个主线程，但是在这个主线程上执行许多不同的队列是可能的。<br>&emsp;&emsp;如果库（如VektorKit）依赖于在主队列上检查执行，那么从主线程上执行的非主队列调用API将导致问题。也就是说，如果主线程执行非主队列调度的API，而这个API需要检查是否由主队列上调度，那么将会出现问题。</p><h3 id="更安全的方法一"><a href="#更安全的方法一" class="headerlink" title="更安全的方法一"></a>更安全的方法一</h3><p>&emsp;&emsp;从技术上讲，我认为这是一个<code>MapKit/VektorKit</code>漏洞，苹果的UI框架通常保证在从主线程调用时正确工作，没有任何文档提到需要在主队列上执行代码。<br>&emsp;&emsp;但是，现在我们知道某些api不仅依赖于主线程上的运行，而且还依赖于主队列，因此检查当前队列而不是检查当前线程更安全。<br>&emsp;&emsp;检查当前队列还可以更好地利用GCD为线程提供的抽象。从技术上讲，我们不应该知道/关心主队列是一种总是绑定到主线程的特殊队列。<br>&emsp;&emsp;我们需要使用<code>dispatch_queue_set_specific</code>函数来将键值与主队列相关联，稍后，我们可以使用<code>dispatch_queue_get_specific</code>来检查键和值的存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)function &#123;</span><br><span class="line">    static void *mainQueueKey = &quot;mainQueueKey&quot;;</span><br><span class="line">    dispatch_queue_set_specific(dispatch_get_main_queue(), mainQueueKey, &amp;mainQueueKey, NULL);</span><br><span class="line">    if (dispatch_get_specific(mainQueueKey)) &#123;</span><br><span class="line">        // do something in main queue</span><br><span class="line">        //通过这样判断，就可以真正保证(我们在不主动搞事的情况下)，任务一定是放在主队列中的</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // do something in other queue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="更安全的方法二（SDWEbImage使用的方法）"><a href="#更安全的方法二（SDWEbImage使用的方法）" class="headerlink" title="更安全的方法二（SDWEbImage使用的方法）"></a>更安全的方法二（SDWEbImage使用的方法）</h3><p>&emsp;&emsp;我们知道在使用GCD创建一个queeu的时候回指定queue_label，可以理解为队列名，就像下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t myQueue = dispatch_queue_create(&quot;com.apple.threadQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;而第一个参数就是queue_label，根据官方文档解释，这个queue_label是唯一的，所以SDWebImage就采用了这个方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//取得当前队列的队列名</span><br><span class="line">dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL)</span><br><span class="line">   </span><br><span class="line">//取得主队列的队列名</span><br><span class="line">dispatch_queue_get_label(dispatch_get_main_queue())</span><br><span class="line"></span><br><span class="line">然后通过 strcmp 函数进行比较，如果为0 则证明当前队列就是主队列。</span><br></pre></td></tr></table></figure></p><p>SDWebImage中的实例：判断当前是否是IOQueue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)checkIfQueueIsIOQueue &#123;</span><br><span class="line">    const char *currentQueueLabel = dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL);</span><br><span class="line">    const char *ioQueueLabel = dispatch_queue_get_label(self.ioQueue);</span><br><span class="line">    if (strcmp(currentQueueLabel, ioQueueLabel) != 0) &#123;</span><br><span class="line">        NSLog(@&quot;This method should be called from the ioQueue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>&emsp;&emsp;SDWebImage就是从判断是否在主线程执行改为判断是否由主队列上调度。而由于主队列是一个穿行队列，无论任务是异步同步都不会开辟新线程，所以当前队列是主队列等价于当前在主线程上执行。可以这样说，在主队列调度的任务肯定在主线程执行，而在主线程执行的任务不一定是由主队列调度的。</p><h1 id="SDWebImage的最大并发数和超时时长"><a href="#SDWebImage的最大并发数和超时时长" class="headerlink" title="SDWebImage的最大并发数和超时时长"></a>SDWebImage的最大并发数和超时时长</h1><p>&emsp;&emsp;在SDWebImageDownloader类的初始化方法中，对SDWebImage图片下载的最大并发数和超时时长进行了赋值，分别为6和15.0，具体如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 最大并发数</span><br><span class="line">_downloadQueue.maxConcurrentOperationCount = 6;</span><br><span class="line">// 超时时长</span><br><span class="line">_downloadTimeout = 15.0;</span><br></pre></td></tr></table></figure></p><h1 id="SDWebImage的内存缓存和磁盘缓存是用什么实现的？"><a href="#SDWebImage的内存缓存和磁盘缓存是用什么实现的？" class="headerlink" title="SDWebImage的内存缓存和磁盘缓存是用什么实现的？"></a>SDWebImage的内存缓存和磁盘缓存是用什么实现的？</h1><h2 id="内存缓存实现——SDMemoryCache"><a href="#内存缓存实现——SDMemoryCache" class="headerlink" title="内存缓存实现——SDMemoryCache"></a>内存缓存实现——SDMemoryCache</h2><p>&emsp;&emsp;SDWebImage使用SDMemoryCache（继承自NSCache）来实现内存缓存。NSCache可以设置totalCostLimit来限制缓存的总成本消耗，所以我们再添加缓存的时候需要通过以下代码来指定缓存对象消耗的成本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;SDMemoryCache在初始化时，会初始化一个弱引用表，当收到内存警告时，会移除内存中缓存的图片，同时保留weakCache，维持对被强引用着的图片的访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // 初始化弱引用表，当收到内存警告，内存缓存虽然被清理，但是有些图片已经被其他对象强引用着，.</span><br><span class="line">        // 这时weakCache维持这些图片的弱引用。如果需要获取这些图片就不用去硬盘获取了</span><br><span class="line">        // NSPointerFunctionsStrongMemory 对值进行弱引用，不会对引用计数+1</span><br><span class="line">        self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</span><br><span class="line">        self.weakCacheLock = dispatch_semaphore_create(1);</span><br><span class="line">        self.config = config;</span><br><span class="line">        // 监听内存警告通知</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(didReceiveMemoryWarning:)</span><br><span class="line">                                                     name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning:(NSNotification *)notification &#123;</span><br><span class="line">    // 当收到内存警告通知，移除内存中缓存的图片，同时保留weakCache，维持对被强引用着的图片的访问</span><br><span class="line">    [super removeAllObjects];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="磁盘缓存实现——NSFileManager"><a href="#磁盘缓存实现——NSFileManager" class="headerlink" title="磁盘缓存实现——NSFileManager"></a>磁盘缓存实现——NSFileManager</h2><p>&emsp;&emsp;SDImageCache的磁盘缓存是通过异步操作NSFileManager存储缓存文件到沙盒来实现的。</p><h1 id="读取内存缓存和磁盘缓存的时候如何保证线程安全？"><a href="#读取内存缓存和磁盘缓存的时候如何保证线程安全？" class="headerlink" title="读取内存缓存和磁盘缓存的时候如何保证线程安全？"></a>读取内存缓存和磁盘缓存的时候如何保证线程安全？</h1><h2 id="读取内存缓存"><a href="#读取内存缓存" class="headerlink" title="读取内存缓存"></a>读取内存缓存</h2><p>&emsp;&emsp;NSCache是线程安全的，在多线程操作中，不需要对Cache加锁。读取缓存的时候是在主线程中进行，由于使用NSCache进行存储，所以不需要担心单个value对象的线程安全。</p><h2 id="读取磁盘缓存"><a href="#读取磁盘缓存" class="headerlink" title="读取磁盘缓存"></a>读取磁盘缓存</h2><ul><li><p>创建了一个名为IO的串行队列，所有磁盘操作都在此队列中，逐个执行</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic, nullable) dispatch_queue_t ioQueue;</span><br><span class="line"></span><br><span class="line">// Create IO serial queue</span><br><span class="line">_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>主要存储函数中<code>dispatch_async(self.ioQueue, ^{})</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">         imageData:(nullable NSData *)imageData</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    // .....</span><br><span class="line">    </span><br><span class="line">    if (toDisk) &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                NSData *data = imageData;</span><br><span class="line">                if (!data &amp;&amp; image) &#123;</span><br><span class="line">                    // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format</span><br><span class="line">                    SDImageFormat format;</span><br><span class="line">                    if (SDCGImageRefContainsAlpha(image.CGImage)) &#123;</span><br><span class="line">                        format = SDImageFormatPNG;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        format = SDImageFormatJPEG;</span><br><span class="line">                    &#125;</span><br><span class="line">                    data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format];</span><br><span class="line">                &#125;</span><br><span class="line">                [self _storeImageDataToDisk:data forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (completionBlock) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completionBlock();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h2><ul><li>真正的磁盘缓存是在另一个IO专属线程中的一个串行队列下进行的。</li><li>包括删除、写入等所有磁盘内容都是在这个IO线程中进行，以保证线程安全。</li><li><p>但计算大小、获取文件总数等操作，则在主线程中进行，如下代码所示：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)getSize &#123;</span><br><span class="line">    __block NSUInteger size = 0;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath];</span><br><span class="line">        for (NSString *fileName in fileEnumerator) &#123;</span><br><span class="line">            NSString *filePath = [self.diskCachePath stringByAppendingPathComponent:fileName];</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *attrs = [self.fileManager attributesOfItemAtPath:filePath error:nil];</span><br><span class="line">            size += [attrs fileSize];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="SDWebImage的内存警告是如何处理的？"><a href="#SDWebImage的内存警告是如何处理的？" class="headerlink" title="SDWebImage的内存警告是如何处理的？"></a>SDWebImage的内存警告是如何处理的？</h1><p>&emsp;&emsp;利用通知的方式，当收到内存警告的通知（<code>UIApplicationDidReceiveMemoryWarningNotification</code>）时，会执行<code>didReceiveMemoryWarning:</code>方法，清理内存缓存。</p><h1 id="SDWebImage磁盘缓存的时长是多少？清理操作时间点和清理原则是什么？"><a href="#SDWebImage磁盘缓存的时长是多少？清理操作时间点和清理原则是什么？" class="headerlink" title="SDWebImage磁盘缓存的时长是多少？清理操作时间点和清理原则是什么？"></a>SDWebImage磁盘缓存的时长是多少？清理操作时间点和清理原则是什么？</h1><h2 id="磁盘缓存的时长默认为一周"><a href="#磁盘缓存的时长默认为一周" class="headerlink" title="磁盘缓存的时长默认为一周"></a>磁盘缓存的时长默认为一周</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// SDImageCacheConfig.m</span><br><span class="line">static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</span><br></pre></td></tr></table></figure><h2 id="磁盘清理时间点"><a href="#磁盘清理时间点" class="headerlink" title="磁盘清理时间点"></a>磁盘清理时间点</h2><p>分别在『应用被杀死时』和『应用进入后台时』进行清理操作，分别会收到<code>UIApplicationWillTerminateNotification</code> 和 <code>UIApplicationDidEnterBackgroundNotification</code>两个通知，添加通知的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(deleteOldFiles)</span><br><span class="line">                                             name:UIApplicationWillTerminateNotification</span><br><span class="line">                                           object:nil];</span><br><span class="line"></span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(backgroundDeleteOldFiles)</span><br><span class="line">                                             name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                           object:nil];</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当应用程序进入后台时，会涉及到『Long-Running Task』，正常情况下，程序进入后台时，虽然可以继续执行任务，但是在短时间内就会被挂起待机。Long-Running可以让系统为App再多分配一些时间来处理一些耗时任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)backgroundDeleteOldFiles &#123;</span><br><span class="line">    Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    UIApplication *application = [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">    // 后台任务标识——注册一个</span><br><span class="line">    __block UIBackgroundTaskIdentifier bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        // Clean up any unfinished task business by marking where you</span><br><span class="line">        // stopped or ending the task outright.</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 启动long-running任务并立即返回.</span><br><span class="line">    [self deleteOldFilesWithCompletionBlock:^&#123;</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="磁盘清理原则"><a href="#磁盘清理原则" class="headerlink" title="磁盘清理原则"></a>磁盘清理原则</h2><p>&emsp;&esmp;清理缓存的规则分两步进行：第一步先清除过期的缓存文件，如果清除掉过期的缓存之后，空间还不够。那么久继续按文件时间从早到晚的排序，先清除最早的缓存文件，直到剩余的空间达到要求。具体的说，SDWebImage是通过以下两个属性控制缓存过期以及剩余空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在缓存中保存图片的最长时间，以秒为单位</span><br><span class="line">@property (assign, nonatomic) NSInteger maxCacheAge;</span><br><span class="line"></span><br><span class="line">// 缓存最大大小，以字节为单位</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxCacheSize;</span><br></pre></td></tr></table></figure></p><p>对于maxCacheAge和maxCacheSize相关说明：</p><ul><li>maxCacheAge：默认值为1周，单位是秒</li><li><p>maxCacheSize：没有默认值，意味着默认情况下不会对缓存空间设限制。我们可以通过以下代码进行设置：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SDImageCache sharedImageCache].maxCacheSize = 1024 * 1024 * 50;    // 50M</span><br></pre></td></tr></table></figure><p>  maxCacheSize是以字节来表示的，上面的代码中，设置的是50M的最大缓存空间，把maxCacheSize的设置代码写在App启动的时候，这样SDWebImage在清理缓存的时候，就会清理多余的缓存文件了。</p></li></ul><h1 id="SDWebImage-磁盘目录位于哪里？"><a href="#SDWebImage-磁盘目录位于哪里？" class="headerlink" title="SDWebImage 磁盘目录位于哪里？"></a>SDWebImage 磁盘目录位于哪里？</h1><ul><li>缓存在沙盒目录下<code>Library/Caches</code>，默认情况下，二级目录为<code>~/Library/Caches/default/com.hackemist.SDWebImageCache.default</code></li><li><p>也可以自定义缓存文件名，相关代码（SDImageCache）如下： </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    return [self initWithNamespace:@&quot;default&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns &#123;</span><br><span class="line">    NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">    return [self initWithNamespace:ns diskCacheDirectory:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line">        </span><br><span class="line">        // Create IO serial queue</span><br><span class="line">        _ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        </span><br><span class="line">        _config = [[SDImageCacheConfig alloc] init];</span><br><span class="line">        </span><br><span class="line">        // Init the memory cache</span><br><span class="line">        _memCache = [[SDMemoryCache alloc] initWithConfig:_config];</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line"></span><br><span class="line">        // .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="下载图片的URL必须是NSURL吗？"><a href="#下载图片的URL必须是NSURL吗？" class="headerlink" title="下载图片的URL必须是NSURL吗？"></a>下载图片的URL必须是NSURL吗？</h1><p>&emsp;&emsp;不是必须传NSURL，在SDWebImageManager中有容错处理。所以即使传入一个字符串依旧可以正确的下载图片，相关代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">    url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">    url = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/b8517dc833c7" target="_blank" rel="noopener">简书 - lionsom_lin - SDWebImage4.0源码探究（一）面试题</a></li><li><a href="http://www.cocoachina.com/ios/20180413/23006.html" target="_blank" rel="noopener">cocoachina - yyuuzhu - iOS源码补完计划–SDWebImage4.0+源码参阅(附面试题/流程图)</a></li><li><a href="http://swiftcafe.io/2017/02/19/sdimage-cache/" target="_blank" rel="noopener">Swift Cafe - swift - 天天都在用的 SDWebImage， 你了解它的缓存策略吗？</a></li><li><a href="https://www.jianshu.com/p/06f0265c22eb#" target="_blank" rel="noopener">简书 - ShannonChenCHN - SDWebImage 源码阅读笔记</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SDWebImage源码解析（一）</title>
      <link href="//SDWebImage-source-code-analysis-1.html"/>
      <url>//SDWebImage-source-code-analysis-1.html</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;<a href="https://github.com/SDWebImage/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>是我们常用的图片缓存加载库，基本是iOS项目中标配的第三方库。SDWebImage提供了图片从加载、解析、处理、缓存、清理等一系列功能。对于一个我们常用的库，就很有必要对源码进行仔细阅读与学习，以便了解更多SDWebImage支持的功能与实现原理，当然学习和分析优秀的源码，也能为我们在调试解决问题时提供一定帮助。<a id="more"></a><br><img src="http://pic.cloverkim.com/006tKfTcgy1g05syshw7tj30ct0360so.jpg" alt="" title="SDWebImage"></p><h1 id="基本架构图"><a href="#基本架构图" class="headerlink" title="基本架构图"></a>基本架构图</h1><p>下图为作者给出的SDWebImage基本架构图：<br><img src="http://pic.cloverkim.com/006tKfTcgy1g05wka6jb7j314q0u0dox.jpg" alt="" title="基本架构图"><br>由上图架构图，我们将SDWebImage的相关类分为以下三种：</p><ul><li>各种分类：<ul><li>UIButton+WebCache：为UIButton类添加加载图片的方法。</li><li>MKAnnotationView+WebCache：为MKAnnotationView类添加各种加载图片的方法。</li><li>UIImageView+WebCache：为UIImageView类添加加载图片的方法。</li><li>UIImageView+HighlightedWebCache：为UIImageView类添加高亮状态下加载图片的方法。</li></ul></li><li><p>工具类：</p><ul><li>NSData+ImageContentType：根据图片数据获取图片的类型，比如GIF、PNG等。</li><li>UIImage+MultiFormat：根据UIImage的data生成指定格式的UIImage。</li><li>UIImage+GIF：判断一张图是否为GIF。</li><li>SDWebImageCompat：根据屏幕的分辨倍数成倍放大或者缩小图片的大小。</li><li>SDImageCacheConfig：图片缓存策略记录。比如是否解压缩、是否允许iCloud、是否允许内存缓存、缓存时间等。</li><li>SDWebImageCodersManager：编码解码管理器，处理多个图片编码解码任务，编码器是一个优先队列，这意味着后面添加的编码器将具有最高优先级。</li></ul></li><li><p>核心类：</p><ul><li>UIView+WebCache：所有的UIView及其子类都会调用这个分类的方法来完成图片加载的处理，同时通过UIView+WebCacheOperation分类来管理请求的取消和记录工作。</li><li>SDImageCache：负责SDWebImage的整个缓存工作，是一个单例对象。缓存路径处理、缓存名字处理、管理内存缓存和磁盘缓存的创建和删除、根据指定key获取图片、存入图片的处理、根据缓存的创建和修改日期来删除缓存等。</li><li>SDWebImageManager：拥有一个SDImageCache和SDWebImageDownloader属性，分别用于图片的缓存和加载处理。为UIView及其子类提供了加载图片的统一接口。</li><li>SDWebImageDownloader：图片下载中心，管理下载队列。</li><li>SDWebImageDownloaderOperation：用于下载图片，管理NSURLRequest对象请求头的封装、缓存、cookie的设置、加载选项的处理等。</li></ul></li></ul><p>当然，SDWebImage框架所包含的类不仅仅是上面罗列的，具体的相关类可以阅读源码。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>下图为SDWebImage图片加载的时序图，实现了图片加载、数据处理、图片缓存等一系列工作。<br><img src="http://pic.cloverkim.com/006tKfTcgy1g05xvrthcvj321m0r4q68.jpg" alt="" title="SDWebImage图片加载时序图"><br>由上图时序图，SDWebImage加载图片的流程大致如下：</p><ol><li>对象调用暴露的接口方法<code>sd_setImageWithURL()</code>时，会再调用<code>setImageWithURL:placeholderImage:options:</code>方法，先把占位图placeholderImage显示，然后SDWebImageManager根据URL开始处理图片。</li><li>SDImageCache类先从内存缓存查找是否有图片缓存，如果内存中已经有图片缓存，则直接回调到前端进行图片的显示。</li><li>如果内存缓存中没有，则生成NSInvocationOperation添加到队列开始从硬盘中查找图片是否已经缓存。根据url为key在硬盘缓存目录下尝试读取图片文件，这一步是在NSOperation下进行的操作，所以需要回到主线程进行查找结果的回调。如果从硬盘读取到了图片，则将图片添加到内存缓存中，然后再回调到前端进行图片的显示。如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，则需要下载图片。</li><li>共享或重新生成一个下载器SDWebImageDownloader开始下载图片。图片的下载由NSURLConnection来处理，实现相关delegate来判断的下载状态：下载中、下载完成和下载失败。</li><li>图片数据下载完成之后，交给SDWebImageDecoder类做图片解码处理，图片的解码处理在NSOperationQueue完成，不会阻塞主线程。在图片解码完成后，会回调给SDWebImageDownloader，然后回调给SDWebImageManager告知图片下载完成，通知所有的downloadDelegates下载完成，回调给需要的地方显示图片。</li><li>最后将图片通过SDImageCache类，同时保存到内存缓存和硬盘缓存中。写文件到硬盘的过程也在以单独NSInvocationOperation完成，避免阻塞主线程。</li></ol><p>这里借用一下在网上看到的一张非常详细的流程图：<br><img src="http://pic.cloverkim.com/006tKfTcgy1g063b1fc81j321e0lrdms.jpg" alt=""></p><h1 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h1><h2 id="相关工具类分析"><a href="#相关工具类分析" class="headerlink" title="相关工具类分析"></a>相关工具类分析</h2><h3 id="NSData-ImageContentType"><a href="#NSData-ImageContentType" class="headerlink" title="NSData + ImageContentType"></a>NSData + ImageContentType</h3><p>&emsp;&emsp;这个分类提供了一个类方法<code>sd_contentTypeForImageData:</code>。通过这个方法传入图片的NSData数据，然后返回图片类型。图片类型通过SDImageFormat的枚举来定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDImageFormat) &#123;</span><br><span class="line">    SDImageFormatUndefined = -1,        // 未知类型</span><br><span class="line">    SDImageFormatJPEG = 0,              // JPG</span><br><span class="line">    SDImageFormatPNG,                   // PNG</span><br><span class="line">    SDImageFormatGIF,                   // GIF</span><br><span class="line">    SDImageFormatTIFF,                  // TIFF</span><br><span class="line">    SDImageFormatWebP,                  // WEBP</span><br><span class="line">    SDImageFormatHEIC                   // HEIC</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// 根据图片NSData获取图片的类型</span><br><span class="line">+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data &#123;</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return SDImageFormatUndefined;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // File signatures table: http://www.garykessler.net/library/file_sigs.html</span><br><span class="line">    uint8_t c;</span><br><span class="line">    // 获取图片data数据的第一个字节数据</span><br><span class="line">    [data getBytes:&amp;c length:1];</span><br><span class="line">    // 根据字母的ASCII码比较，返回对应的图片枚举类型</span><br><span class="line">    switch (c) &#123;</span><br><span class="line">        case 0xFF:</span><br><span class="line">            return SDImageFormatJPEG;</span><br><span class="line">        case 0x89:</span><br><span class="line">            return SDImageFormatPNG;</span><br><span class="line">        case 0x47:</span><br><span class="line">            return SDImageFormatGIF;</span><br><span class="line">        case 0x49:</span><br><span class="line">        case 0x4D:</span><br><span class="line">            return SDImageFormatTIFF;</span><br><span class="line">        case 0x52: &#123;</span><br><span class="line">            if (data.length &gt;= 12) &#123;</span><br><span class="line">                // RIFF....WEBP</span><br><span class="line">                NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];</span><br><span class="line">                if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123;</span><br><span class="line">                    return SDImageFormatWebP;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case 0x00: &#123;</span><br><span class="line">            if (data.length &gt;= 12) &#123;</span><br><span class="line">                // ....ftypheic ....ftypheix ....ftyphevc ....ftyphevx</span><br><span class="line">                NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(4, 8)] encoding:NSASCIIStringEncoding];</span><br><span class="line">                if ([testString isEqualToString:@&quot;ftypheic&quot;]</span><br><span class="line">                    || [testString isEqualToString:@&quot;ftypheix&quot;]</span><br><span class="line">                    || [testString isEqualToString:@&quot;ftyphevc&quot;]</span><br><span class="line">                    || [testString isEqualToString:@&quot;ftyphevx&quot;]) &#123;</span><br><span class="line">                    return SDImageFormatHEIC;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return SDImageFormatUndefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="SDWebImageCodersManager"><a href="#SDWebImageCodersManager" class="headerlink" title="SDWebImageCodersManager"></a>SDWebImageCodersManager</h3><p>&emsp;&emsp;编码解码管理器，处理多个图片编码解码任务，编码器是一个优先队列，这意味着后面添加的编码器将具有最高优先级。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageCodersManager : NSObject&lt;SDWebImageCoder&gt;</span><br><span class="line"></span><br><span class="line">/// 管理器管理</span><br><span class="line">+ (nonnull instancetype)sharedInstance;</span><br><span class="line"></span><br><span class="line">/// 编码管理器中的所有编码器。编码器数组是一个优先级队列，这意味着后面添加的编码器将具有最高优先级</span><br><span class="line">@property (nonatomic, strong, readwrite, nullable) NSArray&lt;SDWebImageCoder&gt;* coders;</span><br><span class="line"></span><br><span class="line">/// 在编码器数组的末尾添加一个新的编码器，并且该编码器拥有最高的优先级</span><br><span class="line">- (void)addCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder;</span><br><span class="line"></span><br><span class="line">/// 从编码器数组中删除一个编码器</span><br><span class="line">- (void)removeCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>相关方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/// 添加编码器</span><br><span class="line">- (void)addCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder &#123;</span><br><span class="line">    /// 判断该编码器是否实现了SDWebImageCode协议</span><br><span class="line">    if ([coder conformsToProtocol:@protocol(SDWebImageCoder)]) &#123;</span><br><span class="line">        dispatch_barrier_sync(self.mutableCodersAccessQueue, ^&#123;</span><br><span class="line">            [self.mutableCoders addObject:coder];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 删除编码器</span><br><span class="line">- (void)removeCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder &#123;</span><br><span class="line">    /// 同步删除编码器</span><br><span class="line">    dispatch_barrier_sync(self.mutableCodersAccessQueue, ^&#123;</span><br><span class="line">        [self.mutableCoders removeObject:coder];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 判断该图片是否可用编码</span><br><span class="line">- (BOOL)canEncodeToFormat:(SDImageFormat)format &#123;</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in self.coders) &#123;</span><br><span class="line">        if ([coder canEncodeToFormat:format]) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 图像解码方法</span><br><span class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in self.coders) &#123;</span><br><span class="line">        if ([coder canDecodeFromData:data]) &#123;</span><br><span class="line">            return [coder decodedImageWithData:data];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 压缩图像</span><br><span class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</span><br><span class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</span><br><span class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in self.coders) &#123;</span><br><span class="line">        if ([coder canDecodeFromData:*data]) &#123;</span><br><span class="line">            return [coder decompressedImageWithImage:image data:data options:optionsDict];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 根据image和format（类型）编码图像</span><br><span class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in self.coders) &#123;</span><br><span class="line">        if ([coder canEncodeToFormat:format]) &#123;</span><br><span class="line">            return [coder encodedDataWithImage:image format:format];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="SDWebImageImageIOCoder"><a href="#SDWebImageImageIOCoder" class="headerlink" title="SDWebImageImageIOCoder"></a>SDWebImageImageIOCoder</h3><p>&emsp;&emsp;通过该类可以实现图片的解压缩操作，对于太大的图片，先按照一定比例缩小图片，然后再进行解压缩。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">// 每个像素占用的字节数</span><br><span class="line">static const size_t kBytesPerPixel = 4;</span><br><span class="line">// 色彩空间占用的字节数</span><br><span class="line">static const size_t kBitsPerComponent = 8;</span><br><span class="line">// 定义一张图片可以占用的最大空间</span><br><span class="line">static const CGFloat kDestImageSizeMB = 60.0f;</span><br><span class="line"></span><br><span class="line">static const CGFloat kSourceImageTileSizeMB = 20.0f;</span><br><span class="line"></span><br><span class="line">static const CGFloat kBytesPerMB = 1024.0f * 1024.0f;</span><br><span class="line">// 1MB可以存储多少像素</span><br><span class="line">static const CGFloat kPixelsPerMB = kBytesPerMB / kBytesPerPixel;</span><br><span class="line">// 如果像素小于这个值，则不解压缩</span><br><span class="line">static const CGFloat kDestTotalPixels = kDestImageSizeMB * kPixelsPerMB;</span><br><span class="line">static const CGFloat kTileTotalPixels = kSourceImageTileSizeMB * kPixelsPerMB;</span><br><span class="line"></span><br><span class="line">static const CGFloat kDestSeemOverlap = 2.0f;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/// 判断是否可以解码</span><br><span class="line">- (BOOL)canDecodeFromData:(nullable NSData *)data &#123;</span><br><span class="line">    switch ([NSData sd_imageFormatForImageData:data]) &#123;</span><br><span class="line">        case SDImageFormatWebP:</span><br><span class="line">            // WebP类型不支持解码</span><br><span class="line">            return NO;</span><br><span class="line">        case SDImageFormatHEIC:</span><br><span class="line">            // 检查HEIC解码的兼容性</span><br><span class="line">            return [[self class] canDecodeFromHEICFormat];</span><br><span class="line">        default:</span><br><span class="line">            return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 判断是否可以解码，并且实现逐渐显示效果</span><br><span class="line">- (BOOL)canIncrementallyDecodeFromData:(NSData *)data &#123;</span><br><span class="line">    switch ([NSData sd_imageFormatForImageData:data]) &#123;</span><br><span class="line">        case SDImageFormatWebP:</span><br><span class="line">            // 不支持WebP渐进解码</span><br><span class="line">            return NO;</span><br><span class="line">        case SDImageFormatHEIC:</span><br><span class="line">            // Check HEIC decoding compatibility</span><br><span class="line">            return [[self class] canDecodeFromHEICFormat];</span><br><span class="line">        default:</span><br><span class="line">            return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 解压缩图片</span><br><span class="line">- (nullable UIImage *)sd_decompressedImageWithImage:(nullable UIImage *)image &#123;</span><br><span class="line">    // 判断图片是否能解压缩</span><br><span class="line">    if (![[self class] shouldDecodeImage:image]) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // autorelease the bitmap context and all vars to help system to free memory when there are memory warning.</span><br><span class="line">    // on iOS7, do not forget to call [[SDImageCache sharedImageCache] clearMemory];</span><br><span class="line">    // 解压缩操作放入一个自动释放池里面，以便自动释放所有的变量</span><br><span class="line">    @autoreleasepool&#123;</span><br><span class="line">        </span><br><span class="line">        CGImageRef imageRef = image.CGImage;</span><br><span class="line">        // 获取图片的色彩空间</span><br><span class="line">        CGColorSpaceRef colorspaceRef = [[self class] colorSpaceForImageRef:imageRef];</span><br><span class="line">        </span><br><span class="line">        size_t width = CGImageGetWidth(imageRef);</span><br><span class="line">        size_t height = CGImageGetHeight(imageRef);</span><br><span class="line">        </span><br><span class="line">        // kCGImageAlphaNone is not supported in CGBitmapContextCreate.</span><br><span class="line">        // Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast</span><br><span class="line">        // to create bitmap graphics contexts without alpha info.</span><br><span class="line">        CGContextRef context = CGBitmapContextCreate(NULL,</span><br><span class="line">                                                     width,</span><br><span class="line">                                                     height,</span><br><span class="line">                                                     kBitsPerComponent,</span><br><span class="line">                                                     0,</span><br><span class="line">                                                     colorspaceRef,</span><br><span class="line">                                                     kCGBitmapByteOrderDefault|kCGImageAlphaNoneSkipLast);</span><br><span class="line">        if (context == NULL) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // Draw the image into the context and retrieve the new bitmap image without alpha</span><br><span class="line">        // 绘制一个和图片大小一样的图片</span><br><span class="line">        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</span><br><span class="line">        // 创建一个没有alpha通道的图片</span><br><span class="line">        CGImageRef imageRefWithoutAlpha = CGBitmapContextCreateImage(context);</span><br><span class="line">        // 得到解压缩以后的图片</span><br><span class="line">        UIImage *imageWithoutAlpha = [[UIImage alloc] initWithCGImage:imageRefWithoutAlpha scale:image.scale orientation:image.imageOrientation];</span><br><span class="line">        CGContextRelease(context);</span><br><span class="line">        CGImageRelease(imageRefWithoutAlpha);</span><br><span class="line">        </span><br><span class="line">        return imageWithoutAlpha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 是否需要减少原始图片的大小</span><br><span class="line">+ (BOOL)shouldScaleDownImage:(nonnull UIImage *)image &#123;</span><br><span class="line">    BOOL shouldScaleDown = YES;</span><br><span class="line">    </span><br><span class="line">    CGImageRef sourceImageRef = image.CGImage;</span><br><span class="line">    CGSize sourceResolution = CGSizeZero;</span><br><span class="line">    sourceResolution.width = CGImageGetWidth(sourceImageRef);</span><br><span class="line">    sourceResolution.height = CGImageGetHeight(sourceImageRef);</span><br><span class="line">    // 图片总共像素</span><br><span class="line">    float sourceTotalPixels = sourceResolution.width * sourceResolution.height;</span><br><span class="line">    // 如果图片的总像素大于一定比例，则需要做简化处理</span><br><span class="line">    float imageScale = kDestTotalPixels / sourceTotalPixels;</span><br><span class="line">    if (imageScale &lt; 1) &#123;</span><br><span class="line">        shouldScaleDown = YES;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        shouldScaleDown = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return shouldScaleDown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取图片的色彩空间</span><br><span class="line">+ (CGColorSpaceRef)colorSpaceForImageRef:(CGImageRef)imageRef &#123;</span><br><span class="line">    // current</span><br><span class="line">    CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(CGImageGetColorSpace(imageRef));</span><br><span class="line">    CGColorSpaceRef colorspaceRef = CGImageGetColorSpace(imageRef);</span><br><span class="line">    </span><br><span class="line">    BOOL unsupportedColorSpace = (imageColorSpaceModel == kCGColorSpaceModelUnknown ||</span><br><span class="line">                                  imageColorSpaceModel == kCGColorSpaceModelMonochrome ||</span><br><span class="line">                                  imageColorSpaceModel == kCGColorSpaceModelCMYK ||</span><br><span class="line">                                  imageColorSpaceModel == kCGColorSpaceModelIndexed);</span><br><span class="line">    if (unsupportedColorSpace) &#123;</span><br><span class="line">        colorspaceRef = SDCGColorSpaceGetDeviceRGB();</span><br><span class="line">    &#125;</span><br><span class="line">    return colorspaceRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="SDWebImageCompat"><a href="#SDWebImageCompat" class="headerlink" title="SDWebImageCompat"></a>SDWebImageCompat</h3><p>&emsp;&emsp;该类就提供了一个全局方法<code>SDScaledImageForKey</code>，这个方法根据原始图片绘制一张放大或者缩小的图片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/// 给定一张图片，通过scale属性返回一个放大的图片</span><br><span class="line">inline UIImage *SDScaledImageForKey(NSString * _Nullable key, UIImage * _Nullable image) &#123;</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#if SD_MAC</span><br><span class="line">    return image;</span><br><span class="line">#elif SD_UIKIT || SD_WATCH</span><br><span class="line">    // 如果是动图，则迭代处理</span><br><span class="line">    if ((image.images).count &gt; 0) &#123;</span><br><span class="line">        NSMutableArray&lt;UIImage *&gt; *scaledImages = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">        for (UIImage *tempImage in image.images) &#123;</span><br><span class="line">            [scaledImages addObject:SDScaledImageForKey(key, tempImage)];</span><br><span class="line">        &#125;</span><br><span class="line">        // 把处理结束的图片再合成一张动态图片</span><br><span class="line">        UIImage *animatedImage = [UIImage animatedImageWithImages:scaledImages duration:image.duration];</span><br><span class="line">        if (animatedImage) &#123;</span><br><span class="line">            animatedImage.sd_imageLoopCount = image.sd_imageLoopCount;</span><br><span class="line">        &#125;</span><br><span class="line">        return animatedImage;</span><br><span class="line">    &#125; else &#123;        // 非动图的情况</span><br><span class="line">#if SD_WATCH</span><br><span class="line">        if ([[WKInterfaceDevice currentDevice] respondsToSelector:@selector(screenScale)]) &#123;</span><br><span class="line">#elif SD_UIKIT</span><br><span class="line">        if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) &#123;</span><br><span class="line">#endif</span><br><span class="line">            CGFloat scale = 1;</span><br><span class="line">            if (key.length &gt;= 8) &#123;</span><br><span class="line">                NSRange range = [key rangeOfString:@&quot;@2x.&quot;];</span><br><span class="line">                if (range.location != NSNotFound) &#123;</span><br><span class="line">                    scale = 2.0;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                range = [key rangeOfString:@&quot;@3x.&quot;];</span><br><span class="line">                if (range.location != NSNotFound) &#123;</span><br><span class="line">                    scale = 3.0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            // 返回对应分辨率下的图片</span><br><span class="line">            UIImage *scaledImage = [[UIImage alloc] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation];</span><br><span class="line">            image = scaledImage;</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;本文中，主要介绍了SDWebImage的基本架构、各种类的作用、相关工具类（NSData+ImageContentType、SDWebImageCodersManager、SDWebImageImageIOCoder以及SDWebImageCompat）的详细分析。在下文中<a href="http://cloverkim.com/SDWebImage-source-code-analysis-2.html">SDWebImage源码解析（二）</a>，将会继续分析SDWebImage的相关核心类。</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SDWebImage源码解析（二）</title>
      <link href="//SDWebImage-source-code-analysis-2.html"/>
      <url>//SDWebImage-source-code-analysis-2.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;在上一篇文章<a href="http://cloverkim.com/SDWebImage-source-code-analysis-1.html">SDWebImage源码解析（一）</a>中，主要介绍了SDWebImage的基本架构、各种类的作用、相关工具类（NSData+ImageContentType、SDWebImageCodersManager、SDWebImageImageIOCoder以及SDWebImageCompat）的详细分析。在本文中，将会分析SDWebImage的UIView+WebCache、UIWebImageManager相关核心类。<a id="more"></a></p><h1 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h1><h2 id="核心类分析"><a href="#核心类分析" class="headerlink" title="核心类分析"></a>核心类分析</h2><h3 id="UIView-WebCache"><a href="#UIView-WebCache" class="headerlink" title="UIView+WebCache"></a>UIView+WebCache</h3><p>&emsp;&emsp;在UIImageView+WebCache和UIButton+WebCache等分类中，提供了以下对外使用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url NS_REFINED_FOR_SWIFT;</span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder;</span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;从上面分类的接口中，可以看出其体现了设计模式五大原则之一的接口分离原则，那何为接口分离分则：<strong>为特定功能提供特定的接口，不要使用单一的总接口包括所有功能，而是应该根据功能把这些接口分割，减少依赖，不能强迫用户去依赖那些他们不使用的接口。</strong>当调用了上面几个接口时，又会调用UIView+WebCache分类的<code>sd_internalSetImageWithURL</code>方法来做图片加载请求。具体是通过SDWebImageManager调用来实现的。同时实现了Operation取消、ActivityIndicator的添加和取消。下面先来看下<code>sd_internalSetImageWithURL</code>方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</span><br><span class="line">                  placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(nullable NSString *)operationKey</span><br><span class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(nullable SDExternalCompletionBlock)completedBlock</span><br><span class="line">                           context:(nullable NSDictionary&lt;NSString *, id&gt; *)context &#123;</span><br><span class="line">    // 根据参数operationKey取消当前类所对应的下载Operation对象，如果operationKey为nil，则key取NSStringFromClass([self class])</span><br><span class="line">    NSString *validOperationKey = operationKey ?: NSStringFromClass([self class]);</span><br><span class="line">    // 具体的取消操作在UIView+WebCacheOperation中实现</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:validOperationKey];</span><br><span class="line">    // 利用关联对象给当前self实例绑定url，key为imageURLKey，value为url</span><br><span class="line">    objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    // 利用与运算判断调用者是否需要设置占位图</span><br><span class="line">    if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        if ([context valueForKey:SDWebImageInternalSetImageGroupKey]) &#123;</span><br><span class="line">            dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey];</span><br><span class="line">            dispatch_group_enter(group);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (url) &#123;</span><br><span class="line">        // 判断之前是否利用关联对象给self添加了显示loading加载</span><br><span class="line">        if ([self sd_showActivityIndicatorView]) &#123;</span><br><span class="line">            [self sd_addActivityIndicator];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // reset the progress</span><br><span class="line">        self.sd_imageProgress.totalUnitCount = 0;</span><br><span class="line">        self.sd_imageProgress.completedUnitCount = 0;</span><br><span class="line">        </span><br><span class="line">        SDWebImageManager *manager;</span><br><span class="line">        if ([context valueForKey:SDWebImageExternalCustomManagerKey]) &#123;</span><br><span class="line">            manager = (SDWebImageManager *)[context valueForKey:SDWebImageExternalCustomManagerKey];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            manager = [SDWebImageManager sharedManager];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        __weak __typeof(self)wself = self;</span><br><span class="line">        // 图片下载进度block回调</span><br><span class="line">        SDWebImageDownloaderProgressBlock combinedProgressBlock = ^(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL) &#123;</span><br><span class="line">            wself.sd_imageProgress.totalUnitCount = expectedSize;</span><br><span class="line">            wself.sd_imageProgress.completedUnitCount = receivedSize;</span><br><span class="line">            if (progressBlock) &#123;</span><br><span class="line">                progressBlock(receivedSize, expectedSize, targetURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 调用SDWebImageManager的loadImageWithURL方法加载图片，返回值是SDWebImageCombinedOperation</span><br><span class="line">        id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options progress:combinedProgressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">            __strong __typeof (wself) sself = wself;</span><br><span class="line">            if (!sself) &#123; return; &#125;</span><br><span class="line">            // 移除loading加载</span><br><span class="line">            [sself sd_removeActivityIndicator];</span><br><span class="line">            // 如果没有更新进度，则将其标记为完成状态</span><br><span class="line">            if (finished &amp;&amp; !error &amp;&amp; sself.sd_imageProgress.totalUnitCount == 0 &amp;&amp; sself.sd_imageProgress.completedUnitCount == 0) &#123;</span><br><span class="line">                sself.sd_imageProgress.totalUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">                sself.sd_imageProgress.completedUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">            &#125;</span><br><span class="line">            BOOL shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);</span><br><span class="line">            BOOL shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</span><br><span class="line">                                      (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</span><br><span class="line">            SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">                if (!sself) &#123; return; &#125;</span><br><span class="line">                if (!shouldNotSetImage) &#123;</span><br><span class="line">                    [sself sd_setNeedsLayout];</span><br><span class="line">                &#125;</span><br><span class="line">                if (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            // case 1a: we got an image, but the SDWebImageAvoidAutoSetImage flag is set</span><br><span class="line">            // OR</span><br><span class="line">            // case 1b: we got no image and the SDWebImageDelayPlaceholder is not set</span><br><span class="line">            // 如果设置了不自动显示图片，则回调让调用者手动添加显示图片</span><br><span class="line">            if (shouldNotSetImage) &#123;</span><br><span class="line">                dispatch_main_async_safe(callCompletedBlockClojure);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            UIImage *targetImage = nil;</span><br><span class="line">            NSData *targetData = nil;</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                // case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set</span><br><span class="line">                targetImage = image;</span><br><span class="line">                targetData = data;</span><br><span class="line">            &#125; else if (options &amp; SDWebImageDelayPlaceholder) &#123;</span><br><span class="line">                // case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set</span><br><span class="line">                targetImage = placeholder;</span><br><span class="line">                targetData = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // check whether we should use the image transition</span><br><span class="line">            SDWebImageTransition *transition = nil;</span><br><span class="line">            if (finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</span><br><span class="line">                transition = sself.sd_imageTransition;</span><br><span class="line">            &#125;</span><br><span class="line">            if ([context valueForKey:SDWebImageInternalSetImageGroupKey]) &#123;</span><br><span class="line">                dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey];</span><br><span class="line">                dispatch_group_enter(group);</span><br><span class="line">                dispatch_main_async_safe(^&#123;</span><br><span class="line">                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</span><br><span class="line">                &#125;);</span><br><span class="line">                // ensure completion block is called after custom setImage process finish</span><br><span class="line">                dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    callCompletedBlockClojure();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dispatch_main_async_safe(^&#123;</span><br><span class="line">                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</span><br><span class="line">                    callCompletedBlockClojure();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        // 绑定operation到当前self，key为validOperationKey，value为operation</span><br><span class="line">        [self sd_setImageLoadOperation:operation forKey:validOperationKey];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 移除loading加载框，并抛出异常的回调</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [self sd_removeActivityIndicator];</span><br><span class="line">            if (completedBlock) &#123;</span><br><span class="line">                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];</span><br><span class="line">                completedBlock(nil, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>UIView+WebCache</code>是通过<code>UIView+WebCacheOperation</code>分类来实现UIView的图片下载Operation的关联和取消。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/// 关联operation对象与key对象</span><br><span class="line">- (void)sd_setImageLoadOperation:(nullable id&lt;SDWebImageOperation&gt;)operation forKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (key) &#123;</span><br><span class="line">        [self sd_cancelImageLoadOperationWithKey:key];</span><br><span class="line">        if (operation) &#123;</span><br><span class="line">            SDOperationsDictionary *operationDictionary = [self sd_operationDictionary];</span><br><span class="line">            @synchronized (self) &#123;</span><br><span class="line">                [operationDictionary setObject:operation forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 取消当前key对应的所有实现了SDWebImageOperation协议的Operation对象</span><br><span class="line">- (void)sd_cancelImageLoadOperationWithKey:(nullable NSString *)key &#123;</span><br><span class="line">    // 获取当前view对应的所有key</span><br><span class="line">    SDOperationsDictionary *operationDictionary = [self sd_operationDictionary];</span><br><span class="line">    id&lt;SDWebImageOperation&gt; operation;</span><br><span class="line">    // 获取对应的图片加载operation</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        operation = [operationDictionary objectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    // 取消所有当前view对应的所有operation</span><br><span class="line">    if (operation) &#123;</span><br><span class="line">        if ([operation conformsToProtocol:@protocol(SDWebImageOperation)])&#123;</span><br><span class="line">            [operation cancel];</span><br><span class="line">        &#125;</span><br><span class="line">        @synchronized (self) &#123;</span><br><span class="line">            [operationDictionary removeObjectForKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 移除operation对象与key对象的关联</span><br><span class="line">- (void)sd_removeImageLoadOperationWithKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (key) &#123;</span><br><span class="line">        SDOperationsDictionary *operationDictionary = [self sd_operationDictionary];</span><br><span class="line">        @synchronized (self) &#123;</span><br><span class="line">            [operationDictionary removeObjectForKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="UIWebImageManager"><a href="#UIWebImageManager" class="headerlink" title="UIWebImageManager"></a>UIWebImageManager</h3><p>&emsp;&emsp;UIWebImageManager类是SDWebImage中的核心类，主要负责调用SDWebImageDownloader进行图片下载，以及在下载完之后利用SDImageCache进行图片的缓存。UIImageView等各种视图都是通过UIView+WebCache分类的<code>sd_internalSetImageWithURL</code>方法来调用SDWebImageManager类的如下方法来实现图片加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// 这个方法为核心方法，UIImageView等分类都默认通过调用这个方法来获取数据</span><br><span class="line">- (nullable id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                              options:(SDWebImageOptions)options</span><br><span class="line">                                             progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                            completed:(nullable SDInternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在上面的方法中，第二个参数options，这个参数指定了图片加载过程中的不同选项，SDWebImage可以根据不同的选项做不同的处理，这一个枚举类型，具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，当URL无法下载时，该URL将被列入黑名单，下次再有该URL的请求时，将不会继续尝试.</span><br><span class="line">     * 如果为true，则禁用黑名单，表示需要再尝试请求.</span><br><span class="line">     */</span><br><span class="line">    SDWebImageRetryFailed = 1 &lt;&lt; 0,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，图片加载是在交互期间启动的，这个标志可以禁用这个时候加载,</span><br><span class="line">     * 而是当UIScrollView开始减速滑动的时候开始加载.</span><br><span class="line">     */</span><br><span class="line">    SDWebImageLowPriority = 1 &lt;&lt; 1,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 此标志在下载完成后禁止磁盘上缓存，仅在内存中缓存</span><br><span class="line">     */</span><br><span class="line">    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 该标记支持渐进式下载，在下载过程中会像浏览器那样逐步显示图像.</span><br><span class="line">     * 默认情况下，图片只会在加载完成以后再显示.</span><br><span class="line">     */</span><br><span class="line">    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 即使本地已经缓存了图片，但是也要根据HTTP的缓存策略去网上加载图片.</span><br><span class="line">     * 磁盘缓存将由NSURLCache来处理，而不是SDWebImage，这会导致性能轻微下降.</span><br><span class="line">     * 这个选项专门用于处理，url地址没有变，但是url对应的图片数据在服务器改变的情况.</span><br><span class="line">     * 如果一个缓存图片更新了，则completion这个回调会被调用两次，一次返回缓存图片，一次返回最终图片.</span><br><span class="line">     *</span><br><span class="line">     * 只有在不能确保URL和他对应的内容不能完全对应的时候才使用此标志.</span><br><span class="line">     */</span><br><span class="line">    SDWebImageRefreshCached = 1 &lt;&lt; 4,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在iOS 4+中，如果应用进入后台，继续下载图片。这是通过请求系统来实现的</span><br><span class="line">     * 额外的后台时间让请求完成。如果后台任务超时，操作将被取消.</span><br><span class="line">     */</span><br><span class="line">    SDWebImageContinueInBackground = 1 &lt;&lt; 5,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理储存在NSHTTPCookieStore中的cookie，通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES来实现的</span><br><span class="line">     */</span><br><span class="line">    SDWebImageHandleCookies = 1 &lt;&lt; 6,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 启用不受信任的SSL证书.</span><br><span class="line">     * 用于测试目的，但在生产环境中小心使用</span><br><span class="line">     */</span><br><span class="line">    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，图片加载的顺序是根据假如队列的顺序加载的。但是这个标记会把任务添加到队列的最前面.</span><br><span class="line">     */</span><br><span class="line">    SDWebImageHighPriority = 1 &lt;&lt; 8,</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，在加载图片时会加载占位图。</span><br><span class="line">     * 此标记会阻止显示占位图直到图片加载完成.</span><br><span class="line">     */</span><br><span class="line">    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 我们通常不会再动画图像上调用transformDownloadedImage代理方法,</span><br><span class="line">     * 因为大部分transformation操作会对图片做无用处理.</span><br><span class="line">     * 用这个标记表示无论如何都要对图片做transform处理.</span><br><span class="line">     */</span><br><span class="line">    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，图片在下载后被添加到imageView上。但在某些情况下，我们希望</span><br><span class="line">     * UIImageView加载我们手动处理之后的图片</span><br><span class="line">     * 这个标记允许我们在completion这个Block中手动设置处理好以后的图片。</span><br><span class="line">     */</span><br><span class="line">    SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，图片会根据其原始大小进行解码。在iOS上，这个标记会将图片缩小到与设备受限内存兼容的大小</span><br><span class="line">     * 如果 `SDWebImageProgressiveDownload` 标记被设置了，则这个flag不起作用.</span><br><span class="line">     */</span><br><span class="line">    SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12,</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，当图片缓存在内存中时，我们不会查询磁盘数据。这个掩码可以强制同时查询磁盘数据.</span><br><span class="line">     * 建议将此标记与 `SDWebImageQueryDiskSync` 一起使用，以确保在相同的runloop中加载图片.</span><br><span class="line">     */</span><br><span class="line">    SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13,</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，我们同步查询内存缓存，异步查询磁盘缓存。这个掩码可以强制同步查询磁盘缓存，以确保在相同的runloop循环中加载图片.</span><br><span class="line">     */</span><br><span class="line">    SDWebImageQueryDiskSync = 1 &lt;&lt; 14,</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，当缓存丢失时，会从网络下载图片。此标记仅能防止网络从缓存加载.</span><br><span class="line">     */</span><br><span class="line">    SDWebImageFromCacheOnly = 1 &lt;&lt; 15,</span><br><span class="line">    /**</span><br><span class="line">     * 默认情况下，当使用`SDWebImageTransition`在图片加载完成后执行一些视图转换时，此转换仅适用于从网络下载的图片。这个掩码还可以强制将视图转换应用于内存和磁盘缓存.</span><br><span class="line">     */</span><br><span class="line">    SDWebImageForceTransition = 1 &lt;&lt; 16</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来看下SDWebImageManager的初始化过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/// 单例</span><br><span class="line">+ (nonnull instancetype)sharedManager &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    SDImageCache *cache = [SDImageCache sharedImageCache];</span><br><span class="line">    SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</span><br><span class="line">    return [self initWithCache:cache downloader:downloader];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 初始化SDImageCache和SDWebImageDownloader对象</span><br><span class="line">- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _imageCache = cache;</span><br><span class="line">        _imageDownloader = downloader;</span><br><span class="line">        // 用于保存加载失败的url集合</span><br><span class="line">        _failedURLs = [NSMutableSet new];</span><br><span class="line">        // 用于保存当前正在加载的Operation</span><br><span class="line">        _runningOperations = [NSMutableArray new];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后是SDWebImageManager的核心方法<code>loadImageWithURL</code>，其实现过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                     options:(SDWebImageOptions)options</span><br><span class="line">                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                   completed:(nullable SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    // 利用NSAssert预处理宏，进行判断参数completedBlock，如果为nil，则抛出异常，反之继续执行</span><br><span class="line">    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line"></span><br><span class="line">    // 如果传入的url是NSString类型的，则转换为NSURL类型再进行处理.</span><br><span class="line">    if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果url不是NSURL类型的对象，则将其置为nil</span><br><span class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 图片加载获取过程中绑定一个 SDWebImageCombinedOperation 对象，方便接下来再通过找个对象对url的加载控制</span><br><span class="line">    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    operation.manager = self;</span><br><span class="line"></span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    // 判断url是否在加载失败的url集合里面</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        @synchronized (self.failedURLs) &#123;</span><br><span class="line">            isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果url是失败的url或者有其他错误时，则直接根据operation来做异常情况处理</span><br><span class="line">    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url];</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 把加载图片的一个载体存入runningOperations。里面是所有正在做图片加载过程的operation的集合    </span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据url获取url对应的key</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">    </span><br><span class="line">    SDImageCacheOptions cacheOptions = 0;</span><br><span class="line">    if (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;</span><br><span class="line">    if (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;</span><br><span class="line">    </span><br><span class="line">    // 如果图片是从内存缓存加载，则返回的cacheOperation为nil</span><br><span class="line">    // 如果是从磁盘加载，则返回的cacheOperation是NSOperation对象</span><br><span class="line">    // 如果是从网络加载，则返回的cacheOperation对象是 SDWebImageDownloaderOperation 对象</span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line">    operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key options:cacheOptions done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123;</span><br><span class="line">        __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">        // 如果已经取消了操作，则直接返回并且移除对应的operation对象</span><br><span class="line">        if (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 检查判断是否需要从网络上下载图片</span><br><span class="line">        BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly))</span><br><span class="line">            &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached)</span><br><span class="line">            &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]);</span><br><span class="line">        if (shouldDownload) &#123;</span><br><span class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                // 如果在缓存中获取到了图片，但设置了SDWebImageRefreshCached来忽略缓存，则通知缓存的图片并尝试重新下载它.</span><br><span class="line">                [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果没有图片或者请求刷新，则下载图片</span><br><span class="line">            // 把图片加载的 SDWebImageOperations 类型枚举转换为图片下载的 SDWebImageDownloaderOptions 类型的枚举</span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = 0;</span><br><span class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</span><br><span class="line">            </span><br><span class="line">            // 如果设置了强制刷新缓存的选项，则 SDWebImageDownloaderProgressiveDownload 选项失效并且添加 SDWebImageDownloaderIgnoreCachedResponse 选项</span><br><span class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                // 如果图片已经缓存但强制刷新，则强制关闭渐进</span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                // 忽略从NSURLCache获取的图片（如果有缓存），但需要强制刷新</span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle</span><br><span class="line">            __weak typeof(strongOperation) weakSubOperation = strongOperation;</span><br><span class="line">            strongOperation.downloadToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123;</span><br><span class="line">                __strong typeof(weakSubOperation) strongSubOperation = weakSubOperation;</span><br><span class="line">                // 如果图片下载结束以后，对应的图片加载操作已经取消，则不做任何处理</span><br><span class="line">                if (!strongSubOperation || strongSubOperation.isCancelled) &#123;</span><br><span class="line">                    // Do nothing if the operation was cancelled</span><br><span class="line">                    // See #699 for more details</span><br><span class="line">                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">                &#125; else if (error) &#123;</span><br><span class="line">                    // 如果加载出错，则直接返回回调，并且添加failedURLs集合中</span><br><span class="line">                    [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock error:error url:url];</span><br><span class="line">                    BOOL shouldBlockFailedURL;</span><br><span class="line">                    // Check whether we should block failed url</span><br><span class="line">                    if ([self.delegate respondsToSelector:@selector(imageManager:shouldBlockFailedURL:withError:)]) &#123;</span><br><span class="line">                        shouldBlockFailedURL = [self.delegate imageManager:self shouldBlockFailedURL:url withError:error];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        shouldBlockFailedURL = (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorCannotConnectToHost</span><br><span class="line">                                                &amp;&amp; error.code != NSURLErrorNetworkConnectionLost);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    if (shouldBlockFailedURL) &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs addObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;       // 网络图片加载成功</span><br><span class="line">                    // 如果有重试失败下载的选项，则把url从failedURLs集合中移除</span><br><span class="line">                    if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs removeObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line">                    </span><br><span class="line">                    // We&apos;ve done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale.</span><br><span class="line">                    if (self != [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123;</span><br><span class="line">                        downloadedImage = [self scaledImageForKey:key image:downloadedImage];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        // Image refresh hit the NSURLCache cache, do not call the completion block</span><br><span class="line">                    &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                            // 获取transform后的图片</span><br><span class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line"></span><br><span class="line">                            // 存储transform以后的图片</span><br><span class="line">                            if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                NSData *cacheData;</span><br><span class="line">                                // pass nil if the image was transformed, so we can recalculate the data from the image</span><br><span class="line">                                if (self.cacheSerializer) &#123;</span><br><span class="line">                                    cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    cacheData = (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">                                &#125;</span><br><span class="line">                                [self.imageCache storeImage:transformedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            // 回调拼接</span><br><span class="line">                            [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 下载完成并且有image，则缓存图片</span><br><span class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            if (self.cacheSerializer) &#123;</span><br><span class="line">                                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                                    NSData *cacheData = self.cacheSerializer(downloadedImage, downloadedData, url);</span><br><span class="line">                                    [self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 如果下载和缓存都完成了，则删除操作队列中的operation</span><br><span class="line">                if (finished) &#123;</span><br><span class="line">                    [self safelyRemoveOperationFromRunning:strongSubOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; else if (cachedImage) &#123;</span><br><span class="line">            // 有图片且线程没有被取消，则回调有图片的completeBlock</span><br><span class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 图片没有在缓存中，并且代理方法也不允许下载则回调失败</span><br><span class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url];</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过对<code>loadImageWithURL</code>方法的分析，主要实现的功能有：</p><ul><li><p>创建一个<code>SDWebImageCombinedOperation</code>对象，调用者可以通过这个对象来对加载做取消等操作，这个对象的cancelOperation属性有以下几种情况：</p><ul><li>如果图片是从内存加载，则返回的cacheOperation为nil</li><li>如果是从磁盘加载，则返回的cacheOperation是NSOperation对象</li><li>如果是从网络加载，则返回的cacheOperation是SDWebImageDownloaderOperation对象</li></ul></li><li><p>通过failedURLs集合存储加载失败的url，防止失败的url再次加载</p></li><li>通过runningOperations来存储正在执行下载图片的操作</li><li>图片加载结束以后，通过<code>callCompletionBlockForOperation</code>方法来拼接回调Block</li><li>图片成功从网络下载以后，通过imageCache的<code>storeImage</code>方法来缓存图片</li></ul><p>SDWebImageManager类其它方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">/// 根据URL获取缓存中的key</span><br><span class="line">- (nullable NSString *)cacheKeyForURL:(nullable NSURL *)url &#123;</span><br><span class="line">    if (!url) &#123;</span><br><span class="line">        return @&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.cacheKeyFilter) &#123;</span><br><span class="line">        return self.cacheKeyFilter(url);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return url.absoluteString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 检查缓存中是否缓存了当前url对应的图片，先判断内存缓存，再判断磁盘缓存</span><br><span class="line">- (void)cachedImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">                     completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">    // 判断是否存在内存缓存</span><br><span class="line">    BOOL isInMemoryCache = ([self.imageCache imageFromMemoryCacheForKey:key] != nil);</span><br><span class="line">    </span><br><span class="line">    if (isInMemoryCache) &#123;</span><br><span class="line">        // making sure we call the completion block on the main queue</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (completionBlock) &#123;</span><br><span class="line">                completionBlock(YES);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断是否存在磁盘缓存</span><br><span class="line">    [self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) &#123;</span><br><span class="line">        // the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(isInDiskCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 根据url判断磁盘中是否存在图片 </span><br><span class="line">- (void)diskImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">                   completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">    </span><br><span class="line">    [self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) &#123;</span><br><span class="line">        // the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(isInDiskCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/// 将图片存入缓存中</span><br><span class="line">- (void)saveImageToCache:(nullable UIImage *)image forURL:(nullable NSURL *)url &#123;</span><br><span class="line">    if (image &amp;&amp; url) &#123;</span><br><span class="line">        NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">        [self.imageCache storeImage:image forKey:key toDisk:YES completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/// 取消所有下载操作</span><br><span class="line">- (void)cancelAll &#123;</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        NSArray&lt;SDWebImageCombinedOperation *&gt; *copiedOperations = [self.runningOperations copy];</span><br><span class="line">        [copiedOperations makeObjectsPerformSelector:@selector(cancel)];</span><br><span class="line">        [self.runningOperations removeObjectsInArray:copiedOperations];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 判断当前是否有图片正在下载</span><br><span class="line">- (BOOL)isRunning &#123;</span><br><span class="line">    BOOL isRunning = NO;</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        isRunning = (self.runningOperations.count &gt; 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return isRunning;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 线程安全地移除下载operation</span><br><span class="line">- (void)safelyRemoveOperationFromRunning:(nullable SDWebImageCombinedOperation*)operation &#123;</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        if (operation) &#123;</span><br><span class="line">            [self.runningOperations removeObject:operation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;本文中，主要详细分析了SDWebImage的UIView+WebCache、UIWebImageManager两个核心类。在下文中<a href="http://cloverkim.com/SDWebImage-source-code-analysis-3.html">SDWebImage源码解析（三）</a>，将会继续分析SDWebImage的相关核心类。</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
